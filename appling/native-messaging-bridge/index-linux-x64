24150
{"version":0,"id":"7cdef2f741205a94a7188525d5d1a176a65ecd63a8e3ae94191f8169e2bab1d0","main":"/index.js","imports":{},"resolutions":{"/../../node_modules/events/events.js":{"#package":"/../../node_modules/events/package.json"},"/../../node_modules/events/package.json":{},"/commandDefinitions.js":{"#package":"/package.json"},"/index.js":{"#package":"/package.json","./commandDefinitions.js":"/commandDefinitions.js","./nativeMessagingHandler.js":"/nativeMessagingHandler.js","./utils.js":"/utils.js","pear-ipc":"/node_modules/pear-ipc/index.js"},"/nativeMessagingHandler.js":{"#package":"/package.json","./nativeMessagingProtocol.js":"/nativeMessagingProtocol.js","./utils":"/utils.js","events":"/../../node_modules/events/events.js"},"/nativeMessagingProtocol.js":{"#package":"/package.json"},"/node_modules/b4a/index.js":{"#package":"/node_modules/b4a/package.json"},"/node_modules/b4a/package.json":{},"/node_modules/bare-addon-resolve/index.js":{"#package":"/node_modules/bare-addon-resolve/package.json","./lib/errors":"/node_modules/bare-addon-resolve/lib/errors.js","bare-module-resolve":"/node_modules/bare-module-resolve/index.js","bare-semver":"/node_modules/bare-semver/index.js"},"/node_modules/bare-addon-resolve/lib/errors.js":{"#package":"/node_modules/bare-addon-resolve/package.json"},"/node_modules/bare-addon-resolve/package.json":{},"/node_modules/bare-events/index.js":{"#package":"/node_modules/bare-events/package.json","./lib/errors":"/node_modules/bare-events/lib/errors.js"},"/node_modules/bare-events/lib/errors.js":{"#package":"/node_modules/bare-events/package.json"},"/node_modules/bare-events/package.json":{},"/node_modules/bare-fs/binding.js":{"#package":"/node_modules/bare-fs/package.json",".":"/node_modules/bare-fs/prebuilds/linux-x64/bare-fs.bare"},"/node_modules/bare-fs/index.js":{"#package":"/node_modules/bare-fs/package.json","./binding":"/node_modules/bare-fs/binding.js","./lib/constants":"/node_modules/bare-fs/lib/constants.js","./lib/errors":"/node_modules/bare-fs/lib/errors.js","./promises":"/node_modules/bare-fs/promises.js","bare-events":"/node_modules/bare-events/index.js","bare-path":"/node_modules/bare-path/index.js","bare-stream":"/node_modules/bare-stream/index.js","bare-url":"/node_modules/bare-url/index.js","fast-fifo":"/node_modules/fast-fifo/index.js"},"/node_modules/bare-fs/lib/constants.js":{"#package":"/node_modules/bare-fs/package.json","../binding":"/node_modules/bare-fs/binding.js"},"/node_modules/bare-fs/lib/errors.js":{"#package":"/node_modules/bare-fs/package.json","bare-os":"/node_modules/bare-os/index.js"},"/node_modules/bare-fs/package.json":{},"/node_modules/bare-fs/prebuilds/linux-x64/bare-fs.bare":{"#package":"/node_modules/bare-fs/package.json"},"/node_modules/bare-fs/promises.js":{"#package":"/node_modules/bare-fs/package.json",".":"/node_modules/bare-fs/index.js","bare-events":"/node_modules/bare-events/index.js"},"/node_modules/bare-module-resolve/index.js":{"#package":"/node_modules/bare-module-resolve/package.json","./lib/errors":"/node_modules/bare-module-resolve/lib/errors.js","bare-semver":"/node_modules/bare-semver/index.js"},"/node_modules/bare-module-resolve/lib/errors.js":{"#package":"/node_modules/bare-module-resolve/package.json"},"/node_modules/bare-module-resolve/package.json":{},"/node_modules/bare-os/binding.js":{"#package":"/node_modules/bare-os/package.json",".":"/node_modules/bare-os/prebuilds/linux-x64/bare-os.bare"},"/node_modules/bare-os/index.js":{"#package":"/node_modules/bare-os/package.json","./binding":"/node_modules/bare-os/binding.js","./lib/constants":"/node_modules/bare-os/lib/constants.js","./lib/errors":"/node_modules/bare-os/lib/errors.js"},"/node_modules/bare-os/lib/constants.js":{"#package":"/node_modules/bare-os/package.json","../binding":"/node_modules/bare-os/binding.js"},"/node_modules/bare-os/lib/errors.js":{"#package":"/node_modules/bare-os/package.json"},"/node_modules/bare-os/package.json":{},"/node_modules/bare-os/prebuilds/linux-x64/bare-os.bare":{"#package":"/node_modules/bare-os/package.json"},"/node_modules/bare-path/index.js":{"#package":"/node_modules/bare-path/package.json","./lib/posix":"/node_modules/bare-path/lib/posix.js","./lib/win32":"/node_modules/bare-path/lib/win32.js"},"/node_modules/bare-path/lib/constants.js":{"#package":"/node_modules/bare-path/package.json"},"/node_modules/bare-path/lib/posix.js":{"#package":"/node_modules/bare-path/package.json","./constants":"/node_modules/bare-path/lib/constants.js","./shared":"/node_modules/bare-path/lib/shared.js","./win32":"/node_modules/bare-path/lib/win32.js","bare-os":"/node_modules/bare-os/index.js"},"/node_modules/bare-path/lib/shared.js":{"#package":"/node_modules/bare-path/package.json","./constants":"/node_modules/bare-path/lib/constants.js"},"/node_modules/bare-path/lib/win32.js":{"#package":"/node_modules/bare-path/package.json","./constants":"/node_modules/bare-path/lib/constants.js","./posix":"/node_modules/bare-path/lib/posix.js","./shared":"/node_modules/bare-path/lib/shared.js","bare-os":"/node_modules/bare-os/index.js"},"/node_modules/bare-path/package.json":{},"/node_modules/bare-pipe/binding.js":{"#package":"/node_modules/bare-pipe/package.json",".":"/node_modules/bare-pipe/prebuilds/linux-x64/bare-pipe.bare"},"/node_modules/bare-pipe/index.js":{"#package":"/node_modules/bare-pipe/package.json","./binding":"/node_modules/bare-pipe/binding.js","./lib/constants":"/node_modules/bare-pipe/lib/constants.js","./lib/errors":"/node_modules/bare-pipe/lib/errors.js","bare-events":"/node_modules/bare-events/index.js","bare-stream":"/node_modules/bare-stream/index.js"},"/node_modules/bare-pipe/lib/constants.js":{"#package":"/node_modules/bare-pipe/package.json"},"/node_modules/bare-pipe/lib/errors.js":{"#package":"/node_modules/bare-pipe/package.json"},"/node_modules/bare-pipe/package.json":{},"/node_modules/bare-pipe/prebuilds/linux-x64/bare-pipe.bare":{"#package":"/node_modules/bare-pipe/package.json"},"/node_modules/bare-semver/index.js":{"#package":"/node_modules/bare-semver/package.json","./lib/comparator":"/node_modules/bare-semver/lib/comparator.js","./lib/constants":"/node_modules/bare-semver/lib/constants.js","./lib/errors":"/node_modules/bare-semver/lib/errors.js","./lib/range":"/node_modules/bare-semver/lib/range.js","./lib/version":"/node_modules/bare-semver/lib/version.js"},"/node_modules/bare-semver/lib/comparator.js":{"#package":"/node_modules/bare-semver/package.json","./constants":"/node_modules/bare-semver/lib/constants.js"},"/node_modules/bare-semver/lib/constants.js":{"#package":"/node_modules/bare-semver/package.json"},"/node_modules/bare-semver/lib/errors.js":{"#package":"/node_modules/bare-semver/package.json"},"/node_modules/bare-semver/lib/range.js":{"#package":"/node_modules/bare-semver/package.json","./comparator":"/node_modules/bare-semver/lib/comparator.js","./constants":"/node_modules/bare-semver/lib/constants.js","./errors":"/node_modules/bare-semver/lib/errors.js","./version":"/node_modules/bare-semver/lib/version.js"},"/node_modules/bare-semver/lib/version.js":{"#package":"/node_modules/bare-semver/package.json","./errors":"/node_modules/bare-semver/lib/errors.js"},"/node_modules/bare-semver/package.json":{},"/node_modules/bare-stream/index.js":{"#package":"/node_modules/bare-stream/package.json","streamx":"/node_modules/streamx/index.js"},"/node_modules/bare-stream/package.json":{},"/node_modules/bare-url/binding.js":{"#package":"/node_modules/bare-url/package.json",".":"/node_modules/bare-url/prebuilds/linux-x64/bare-url.bare"},"/node_modules/bare-url/index.js":{"#package":"/node_modules/bare-url/package.json","./binding":"/node_modules/bare-url/binding.js","./lib/errors":"/node_modules/bare-url/lib/errors.js","./lib/url-search-params":"/node_modules/bare-url/lib/url-search-params.js","bare-path":"/node_modules/bare-path/index.js"},"/node_modules/bare-url/lib/errors.js":{"#package":"/node_modules/bare-url/package.json"},"/node_modules/bare-url/lib/url-search-params.js":{"#package":"/node_modules/bare-url/package.json"},"/node_modules/bare-url/package.json":{},"/node_modules/bare-url/prebuilds/linux-x64/bare-url.bare":{"#package":"/node_modules/bare-url/package.json"},"/node_modules/compact-encoding/endian.js":{"#package":"/node_modules/compact-encoding/package.json"},"/node_modules/compact-encoding/index.js":{"#package":"/node_modules/compact-encoding/package.json","./endian":"/node_modules/compact-encoding/endian.js","./lexint":"/node_modules/compact-encoding/lexint.js","./raw":"/node_modules/compact-encoding/raw.js","b4a":"/node_modules/b4a/index.js"},"/node_modules/compact-encoding/lexint.js":{"#package":"/node_modules/compact-encoding/package.json"},"/node_modules/compact-encoding/package.json":{},"/node_modules/compact-encoding/raw.js":{"#package":"/node_modules/compact-encoding/package.json","./endian":"/node_modules/compact-encoding/endian.js","b4a":"/node_modules/b4a/index.js"},"/node_modules/fast-fifo/fixed-size.js":{"#package":"/node_modules/fast-fifo/package.json"},"/node_modules/fast-fifo/index.js":{"#package":"/node_modules/fast-fifo/package.json","./fixed-size":"/node_modules/fast-fifo/fixed-size.js"},"/node_modules/fast-fifo/package.json":{},"/node_modules/framed-stream/index.js":{"#package":"/node_modules/framed-stream/package.json","b4a":"/node_modules/b4a/index.js","streamx":"/node_modules/streamx/index.js"},"/node_modules/framed-stream/package.json":{},"/node_modules/fs-native-extensions/binding.js":{"#package":"/node_modules/fs-native-extensions/package.json",".":"/node_modules/fs-native-extensions/prebuilds/linux-x64/fs-native-extensions.bare","require-addon":"/node_modules/require-addon/index.js"},"/node_modules/fs-native-extensions/index.js":{"#package":"/node_modules/fs-native-extensions/package.json","./binding":"/node_modules/fs-native-extensions/binding.js","which-runtime":"/node_modules/which-runtime/index.js"},"/node_modules/fs-native-extensions/package.json":{},"/node_modules/fs-native-extensions/prebuilds/linux-x64/fs-native-extensions.bare":{"#package":"/node_modules/fs-native-extensions/package.json"},"/node_modules/pear-ipc/api.js":{"#package":"/node_modules/pear-ipc/package.json","fs":"/node_modules/bare-fs/index.js","fs-native-extensions":"/node_modules/fs-native-extensions/index.js"},"/node_modules/pear-ipc/client.js":{"#package":"/node_modules/pear-ipc/package.json","./api":"/node_modules/pear-ipc/api.js","./constants":"/node_modules/pear-ipc/constants.js","./methods":"/node_modules/pear-ipc/methods.js","framed-stream":"/node_modules/framed-stream/index.js","net":"/node_modules/bare-pipe/index.js","path":"/node_modules/bare-path/index.js","ready-resource":"/node_modules/ready-resource/index.js","tiny-buffer-rpc":"/node_modules/tiny-buffer-rpc/index.js","tiny-buffer-rpc/any":"/node_modules/tiny-buffer-rpc/any.js","which-runtime":"/node_modules/which-runtime/index.js"},"/node_modules/pear-ipc/constants.js":{"#package":"/node_modules/pear-ipc/package.json","os":"/node_modules/bare-os/index.js","path":"/node_modules/bare-path/index.js","which-runtime":"/node_modules/which-runtime/index.js"},"/node_modules/pear-ipc/index.js":{"#package":"/node_modules/pear-ipc/package.json","./client":"/node_modules/pear-ipc/client.js","./server":"/node_modules/pear-ipc/server.js"},"/node_modules/pear-ipc/methods.js":{"#package":"/node_modules/pear-ipc/package.json"},"/node_modules/pear-ipc/package.json":{},"/node_modules/pear-ipc/server.js":{"#package":"/node_modules/pear-ipc/package.json","./api":"/node_modules/pear-ipc/api.js","./constants":"/node_modules/pear-ipc/constants.js","./methods":"/node_modules/pear-ipc/methods.js","framed-stream":"/node_modules/framed-stream/index.js","fs":"/node_modules/bare-fs/index.js","net":"/node_modules/bare-pipe/index.js","path":"/node_modules/bare-path/index.js","ready-resource":"/node_modules/ready-resource/index.js","streamx":"/node_modules/streamx/index.js","tiny-buffer-rpc":"/node_modules/tiny-buffer-rpc/index.js","tiny-buffer-rpc/any":"/node_modules/tiny-buffer-rpc/any.js","which-runtime":"/node_modules/which-runtime/index.js"},"/node_modules/ready-resource/index.js":{"#package":"/node_modules/ready-resource/package.json","events":"/node_modules/bare-events/index.js"},"/node_modules/ready-resource/package.json":{},"/node_modules/require-addon/index.js":{"#package":"/node_modules/require-addon/package.json","./lib/runtime":"/node_modules/require-addon/lib/runtime.js","./lib/runtime/bare":"/node_modules/require-addon/lib/runtime/bare.js","./lib/runtime/default":"/node_modules/require-addon/lib/runtime/default.js","./lib/runtime/node":"/node_modules/require-addon/lib/runtime/node.js"},"/node_modules/require-addon/lib/runtime.js":{"#package":"/node_modules/require-addon/package.json"},"/node_modules/require-addon/lib/runtime/bare.js":{"#package":"/node_modules/require-addon/package.json"},"/node_modules/require-addon/lib/runtime/default.js":{"#package":"/node_modules/require-addon/package.json"},"/node_modules/require-addon/lib/runtime/node.js":{"#package":"/node_modules/require-addon/package.json","bare-addon-resolve":"/node_modules/bare-addon-resolve/index.js","url":"/node_modules/bare-url/index.js"},"/node_modules/require-addon/package.json":{},"/node_modules/safety-catch/index.js":{"#package":"/node_modules/safety-catch/package.json"},"/node_modules/safety-catch/package.json":{},"/node_modules/streamx/index.js":{"#package":"/node_modules/streamx/package.json","events":"/node_modules/bare-events/index.js","fast-fifo":"/node_modules/fast-fifo/index.js","text-decoder":"/node_modules/text-decoder/index.js"},"/node_modules/streamx/package.json":{},"/node_modules/text-decoder/index.js":{"#package":"/node_modules/text-decoder/package.json","./lib/pass-through-decoder":"/node_modules/text-decoder/lib/pass-through-decoder.js","./lib/utf8-decoder":"/node_modules/text-decoder/lib/utf8-decoder.js"},"/node_modules/text-decoder/lib/pass-through-decoder.js":{"#package":"/node_modules/text-decoder/package.json","b4a":"/node_modules/b4a/index.js"},"/node_modules/text-decoder/lib/utf8-decoder.js":{"#package":"/node_modules/text-decoder/package.json","b4a":"/node_modules/b4a/index.js"},"/node_modules/text-decoder/package.json":{},"/node_modules/tiny-buffer-rpc/any.js":{"#package":"/node_modules/tiny-buffer-rpc/package.json","b4a":"/node_modules/b4a/index.js","compact-encoding":"/node_modules/compact-encoding/index.js"},"/node_modules/tiny-buffer-rpc/index.js":{"#package":"/node_modules/tiny-buffer-rpc/package.json","./messages.js":"/node_modules/tiny-buffer-rpc/messages.js","b4a":"/node_modules/b4a/index.js","compact-encoding":"/node_modules/compact-encoding/index.js","safety-catch":"/node_modules/safety-catch/index.js","streamx":"/node_modules/streamx/index.js"},"/node_modules/tiny-buffer-rpc/messages.js":{"#package":"/node_modules/tiny-buffer-rpc/package.json","compact-encoding":"/node_modules/compact-encoding/index.js"},"/node_modules/tiny-buffer-rpc/package.json":{},"/node_modules/which-runtime/index.js":{"#package":"/node_modules/which-runtime/package.json"},"/node_modules/which-runtime/package.json":{},"/package.json":{},"/utils.js":{"#package":"/package.json","bare-fs":"/node_modules/bare-fs/index.js","bare-os":"/node_modules/bare-os/index.js","bare-path":"/node_modules/bare-path/index.js"}},"addons":["/node_modules/bare-fs/prebuilds/linux-x64/bare-fs.bare","/node_modules/bare-os/prebuilds/linux-x64/bare-os.bare","/node_modules/bare-pipe/prebuilds/linux-x64/bare-pipe.bare","/node_modules/bare-url/prebuilds/linux-x64/bare-url.bare","/node_modules/fs-native-extensions/prebuilds/linux-x64/fs-native-extensions.bare"],"assets":[],"files":{"/../../node_modules/events/events.js":{"offset":0,"length":14890,"mode":420},"/../../node_modules/events/package.json":{"offset":14890,"length":859,"mode":420},"/commandDefinitions.js":{"offset":15749,"length":2206,"mode":420},"/index.js":{"offset":17955,"length":12092,"mode":420},"/nativeMessagingHandler.js":{"offset":30047,"length":9099,"mode":420},"/nativeMessagingProtocol.js":{"offset":39146,"length":1410,"mode":420},"/node_modules/b4a/index.js":{"offset":40556,"length":4092,"mode":420},"/node_modules/b4a/package.json":{"offset":44648,"length":701,"mode":420},"/node_modules/bare-addon-resolve/index.js":{"offset":45349,"length":10801,"mode":420},"/node_modules/bare-addon-resolve/lib/errors.js":{"offset":56150,"length":642,"mode":420},"/node_modules/bare-addon-resolve/package.json":{"offset":56792,"length":1175,"mode":420},"/node_modules/bare-events/index.js":{"offset":57967,"length":7322,"mode":420},"/node_modules/bare-events/lib/errors.js":{"offset":65289,"length":711,"mode":420},"/node_modules/bare-events/package.json":{"offset":66000,"length":944,"mode":420},"/node_modules/bare-fs/binding.js":{"offset":66944,"length":33,"mode":420},"/node_modules/bare-fs/index.js":{"offset":66977,"length":48249,"mode":420},"/node_modules/bare-fs/lib/constants.js":{"offset":115226,"length":1494,"mode":420},"/node_modules/bare-fs/lib/errors.js":{"offset":116720,"length":1163,"mode":420},"/node_modules/bare-fs/package.json":{"offset":117883,"length":1546,"mode":420},"/node_modules/bare-fs/prebuilds/linux-x64/bare-fs.bare":{"offset":119429,"length":45944,"mode":420},"/node_modules/bare-fs/promises.js":{"offset":165373,"length":1866,"mode":420},"/node_modules/bare-module-resolve/index.js":{"offset":167239,"length":21131,"mode":420},"/node_modules/bare-module-resolve/lib/errors.js":{"offset":188370,"length":1195,"mode":420},"/node_modules/bare-module-resolve/package.json":{"offset":189565,"length":1143,"mode":420},"/node_modules/bare-os/binding.js":{"offset":190708,"length":33,"mode":420},"/node_modules/bare-os/index.js":{"offset":190741,"length":2433,"mode":420},"/node_modules/bare-os/lib/constants.js":{"offset":193174,"length":113,"mode":420},"/node_modules/bare-os/lib/errors.js":{"offset":193287,"length":479,"mode":420},"/node_modules/bare-os/package.json":{"offset":193766,"length":1023,"mode":420},"/node_modules/bare-os/prebuilds/linux-x64/bare-os.bare":{"offset":194789,"length":31040,"mode":420},"/node_modules/bare-path/index.js":{"offset":225829,"length":306,"mode":420},"/node_modules/bare-path/lib/constants.js":{"offset":226135,"length":247,"mode":420},"/node_modules/bare-path/lib/posix.js":{"offset":226382,"length":5991,"mode":420},"/node_modules/bare-path/lib/shared.js":{"offset":232373,"length":1888,"mode":420},"/node_modules/bare-path/lib/win32.js":{"offset":234261,"length":13427,"mode":420},"/node_modules/bare-path/package.json":{"offset":247688,"length":796,"mode":420},"/node_modules/bare-pipe/binding.js":{"offset":248484,"length":33,"mode":420},"/node_modules/bare-pipe/index.js":{"offset":248517,"length":10662,"mode":420},"/node_modules/bare-pipe/lib/constants.js":{"offset":259179,"length":188,"mode":420},"/node_modules/bare-pipe/lib/errors.js":{"offset":259367,"length":711,"mode":420},"/node_modules/bare-pipe/package.json":{"offset":260078,"length":1255,"mode":420},"/node_modules/bare-pipe/prebuilds/linux-x64/bare-pipe.bare":{"offset":261333,"length":18632,"mode":420},"/node_modules/bare-semver/index.js":{"offset":279965,"length":469,"mode":420},"/node_modules/bare-semver/lib/comparator.js":{"offset":280434,"length":705,"mode":420},"/node_modules/bare-semver/lib/constants.js":{"offset":281139,"length":67,"mode":420},"/node_modules/bare-semver/lib/errors.js":{"offset":281206,"length":529,"mode":420},"/node_modules/bare-semver/lib/range.js":{"offset":281735,"length":2429,"mode":420},"/node_modules/bare-semver/lib/version.js":{"offset":284164,"length":3824,"mode":420},"/node_modules/bare-semver/package.json":{"offset":287988,"length":868,"mode":420},"/node_modules/bare-stream/index.js":{"offset":288856,"length":7649,"mode":420},"/node_modules/bare-stream/package.json":{"offset":296505,"length":1237,"mode":420},"/node_modules/bare-url/binding.js":{"offset":297742,"length":33,"mode":420},"/node_modules/bare-url/index.js":{"offset":297775,"length":9506,"mode":420},"/node_modules/bare-url/lib/errors.js":{"offset":307281,"length":881,"mode":420},"/node_modules/bare-url/lib/url-search-params.js":{"offset":308162,"length":3883,"mode":420},"/node_modules/bare-url/package.json":{"offset":312045,"length":1104,"mode":420},"/node_modules/bare-url/prebuilds/linux-x64/bare-url.bare":{"offset":313149,"length":101232,"mode":420},"/node_modules/compact-encoding/endian.js":{"offset":414381,"length":103,"mode":420},"/node_modules/compact-encoding/index.js":{"offset":414484,"length":19082,"mode":420},"/node_modules/compact-encoding/lexint.js":{"offset":433566,"length":2824,"mode":420},"/node_modules/compact-encoding/package.json":{"offset":436390,"length":713,"mode":420},"/node_modules/compact-encoding/raw.js":{"offset":437103,"length":4118,"mode":420},"/node_modules/fast-fifo/fixed-size.js":{"offset":441221,"length":875,"mode":420},"/node_modules/fast-fifo/index.js":{"offset":442096,"length":972,"mode":420},"/node_modules/fast-fifo/package.json":{"offset":443068,"length":682,"mode":420},"/node_modules/framed-stream/index.js":{"offset":443750,"length":3358,"mode":420},"/node_modules/framed-stream/package.json":{"offset":447108,"length":720,"mode":420},"/node_modules/fs-native-extensions/binding.js":{"offset":447828,"length":90,"mode":420},"/node_modules/fs-native-extensions/index.js":{"offset":447918,"length":6339,"mode":420},"/node_modules/fs-native-extensions/package.json":{"offset":454257,"length":1609,"mode":420},"/node_modules/fs-native-extensions/prebuilds/linux-x64/fs-native-extensions.bare":{"offset":455866,"length":50624,"mode":420},"/node_modules/pear-ipc/api.js":{"offset":506490,"length":1527,"mode":420},"/node_modules/pear-ipc/client.js":{"offset":508017,"length":5035,"mode":420},"/node_modules/pear-ipc/constants.js":{"offset":513052,"length":721,"mode":420},"/node_modules/pear-ipc/index.js":{"offset":513773,"length":164,"mode":420},"/node_modules/pear-ipc/methods.js":{"offset":513937,"length":1625,"mode":420},"/node_modules/pear-ipc/package.json":{"offset":515562,"length":1300,"mode":420},"/node_modules/pear-ipc/server.js":{"offset":516862,"length":7600,"mode":420},"/node_modules/ready-resource/index.js":{"offset":524462,"length":1091,"mode":420},"/node_modules/ready-resource/package.json":{"offset":525553,"length":769,"mode":420},"/node_modules/require-addon/index.js":{"offset":526322,"length":262,"mode":420},"/node_modules/require-addon/lib/runtime.js":{"offset":526584,"length":130,"mode":420},"/node_modules/require-addon/lib/runtime/bare.js":{"offset":526714,"length":45,"mode":420},"/node_modules/require-addon/lib/runtime/default.js":{"offset":526759,"length":260,"mode":420},"/node_modules/require-addon/lib/runtime/node.js":{"offset":527019,"length":1073,"mode":420},"/node_modules/require-addon/package.json":{"offset":528092,"length":1335,"mode":420},"/node_modules/safety-catch/index.js":{"offset":529427,"length":506,"mode":420},"/node_modules/safety-catch/package.json":{"offset":529933,"length":547,"mode":420},"/node_modules/streamx/index.js":{"offset":530480,"length":33340,"mode":420},"/node_modules/streamx/package.json":{"offset":563820,"length":912,"mode":420},"/node_modules/text-decoder/index.js":{"offset":564732,"length":1378,"mode":420},"/node_modules/text-decoder/lib/pass-through-decoder.js":{"offset":566110,"length":273,"mode":420},"/node_modules/text-decoder/lib/utf8-decoder.js":{"offset":566383,"length":2529,"mode":420},"/node_modules/text-decoder/package.json":{"offset":568912,"length":987,"mode":420},"/node_modules/tiny-buffer-rpc/any.js":{"offset":569899,"length":2475,"mode":420},"/node_modules/tiny-buffer-rpc/index.js":{"offset":572374,"length":11956,"mode":420},"/node_modules/tiny-buffer-rpc/messages.js":{"offset":584330,"length":2160,"mode":420},"/node_modules/tiny-buffer-rpc/package.json":{"offset":586490,"length":713,"mode":420},"/node_modules/which-runtime/index.js":{"offset":587203,"length":1248,"mode":420},"/node_modules/which-runtime/package.json":{"offset":588451,"length":602,"mode":420},"/package.json":{"offset":589053,"length":835,"mode":420},"/utils.js":{"offset":589888,"length":1391,"mode":420}}}
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
{
  "name": "events",
  "version": "3.3.0",
  "description": "Node's event emitter for all engines.",
  "keywords": [
    "events",
    "eventEmitter",
    "eventDispatcher",
    "listeners"
  ],
  "author": "Irakli Gozalishvili <rfobic@gmail.com> (http://jeditoolkit.com)",
  "repository": {
    "type": "git",
    "url": "git://github.com/Gozala/events.git",
    "web": "https://github.com/Gozala/events"
  },
  "bugs": {
    "url": "http://github.com/Gozala/events/issues/"
  },
  "main": "./events.js",
  "engines": {
    "node": ">=0.8.x"
  },
  "devDependencies": {
    "airtap": "^1.0.0",
    "functions-have-names": "^1.2.1",
    "has": "^1.0.3",
    "has-symbols": "^1.0.1",
    "isarray": "^2.0.5",
    "tape": "^5.0.0"
  },
  "scripts": {
    "test": "node tests/index.js",
    "test:browsers": "airtap -- tests/index.js"
  },
  "license": "MIT"
}
/**
 * Command definitions for the native messaging bridge
 */

/**
 * @typedef {Object} CommandDefinition
 * @property {number} id - Unique command ID
 * @property {string} name - Command name
 */

/** @type {CommandDefinition[]} */
const COMMAND_DEFINITIONS = [
  // Encryption commands
  { id: 1001, name: 'encryptionInit' },
  { id: 1002, name: 'encryptionGetStatus' },
  { id: 1003, name: 'encryptionGet' },
  { id: 1004, name: 'encryptionAdd' },

  // Vaults commands
  { id: 1005, name: 'vaultsInit' },
  { id: 1006, name: 'vaultsGetStatus' },
  { id: 1007, name: 'vaultsGet' },
  { id: 1008, name: 'vaultsList' },
  { id: 1009, name: 'vaultsAdd' },
  { id: 1010, name: 'vaultsClose' },

  // Active vault commands
  { id: 1011, name: 'activeVaultInit' },
  { id: 1012, name: 'activeVaultGetStatus' },
  { id: 1013, name: 'activeVaultGet' },
  { id: 1014, name: 'activeVaultList' },
  { id: 1015, name: 'activeVaultAdd' },
  { id: 1016, name: 'activeVaultRemove' },
  { id: 1017, name: 'activeVaultClose' },
  { id: 1018, name: 'activeVaultCreateInvite' },
  { id: 1019, name: 'activeVaultDeleteInvite' },

  // Password and encryption key commands
  { id: 1020, name: 'hashPassword' },
  { id: 1021, name: 'encryptVaultKeyWithHashedPassword' },
  { id: 1022, name: 'encryptVaultWithKey' },
  { id: 1023, name: 'getDecryptionKey' },
  { id: 1024, name: 'decryptVaultKey' },

  // Native Messaging secure channel (pairing/handshake)
  { id: 1100, name: 'nmGetAppIdentity' },
  { id: 1102, name: 'nmBeginHandshake' },
  { id: 1103, name: 'nmFinishHandshake' },
  { id: 1104, name: 'nmSecureRequest' },
  { id: 1105, name: 'nmCloseSession' },

  // Pairing and misc commands
  { id: 1025, name: 'pairActiveVault' },
  { id: 1026, name: 'initListener' },
  { id: 1027, name: 'closeAllInstances' },
  { id: 1028, name: 'cancelPairActiveVault' }
]

/** @type {string[]} */
const COMMAND_NAMES = COMMAND_DEFINITIONS.map((cmd) => cmd.name)

/**
 * Check if a command name is valid
 * @param {string} commandName - The command name to validate
 * @returns {boolean}
 */
const isValidCommand = (commandName) => COMMAND_NAMES.includes(commandName)

module.exports = {
  COMMAND_DEFINITIONS,
  isValidCommand
}
#!/usr/bin/env node

// Native messaging host - bridges browser extension to PearPass desktop app via IPC

const IPC = require('pear-ipc')

const {
  COMMAND_DEFINITIONS,
  isValidCommand
} = require('./commandDefinitions.js')
const { NativeMessagingHandler } = require('./nativeMessagingHandler.js')
const { getIpcPath, log } = require('./utils.js')

// Desktop app status constants
const DESKTOP_APP_STATUS = Object.freeze({
  CONNECTED: 'connected',
  NOT_RUNNING: 'not-running',
  INTEGRATION_DISABLED: 'integration-disabled',
  CONNECTING: 'connecting',
  UNKNOWN: 'unknown'
})

// Timeout constants (in milliseconds)
const TIMEOUTS = Object.freeze({
  IPC_CONNECTION: 3000, // 3 seconds to establish IPC connection
  IPC_CALL: 3000 // 3 seconds for IPC method calls
})

// Error messages for each status
const STATUS_MESSAGES = Object.freeze({
  [DESKTOP_APP_STATUS.NOT_RUNNING]: 'PearPass desktop app is not running',
  [DESKTOP_APP_STATUS.INTEGRATION_DISABLED]:
    'Browser extension integration is disabled in PearPass desktop app. Please enable it in Settings > Privacy',
  [DESKTOP_APP_STATUS.CONNECTING]: 'Connecting to PearPass desktop app...',
  [DESKTOP_APP_STATUS.UNKNOWN]: 'Unable to connect to PearPass desktop app'
})

/**
 * @typedef {Object} Message
 * @property {string} id - Unique message identifier
 * @property {string} [method] - Method to call
 * @property {string} [command] - Command to execute (alternative to method)
 * @property {Object} [params] - Parameters for the method/command
 */

/**
 * @typedef {Object} Response
 * @property {string} id - Message identifier
 * @property {boolean} success - Whether the operation succeeded
 * @property {*} [result] - Operation result
 * @property {string} [error] - Error message if failed
 * @property {string} [errorCode] - Error code if failed
 */

class NativeMessagingHost {
  constructor() {
    /** @type {NativeMessagingHandler} */
    this.handler = new NativeMessagingHandler()
    /** @type {import('pear-ipc').Client|null} */
    this.ipcClient = null
    /** @type {boolean} */
    this.isRunning = false
    /** @type {string} */
    this.socketPath = getIpcPath('pearpass-native-messaging')
    /** @type {string} */
    this.desktopAppStatus = DESKTOP_APP_STATUS.UNKNOWN
  }

  /**
   * @returns {Promise<void>}
   */
  async start() {
    if (this.isRunning) {
      return
    }

    try {
      log('INFO', 'Starting simple native messaging host...')

      // Set up native messaging handler first
      this.handler.on('message', async (message) => {
        log(
          'INFO',
          'Received message from extension: ' + JSON.stringify(message)
        )
        await this.handleMessage(message)
      })

      this.handler.on('disconnect', () => {
        log('INFO', 'Native messaging disconnected')
        this.stop()
      })

      this.handler.on('error', (error) => {
        log('INFO', 'Native messaging handler error: ' + error.message)
        if (error.stack) {
          log('INFO', 'Error stack: ' + error.stack)
        }
        this.stop()
      })

      // Start the native messaging handler
      this.handler.start()
      this.isRunning = true

      log(
        'INFO',
        'Simple native messaging host started, attempting IPC connection...'
      )

      // Try to connect to IPC server (non-blocking)
      this.connectToIPC().catch((error) => {
        log('INFO', 'Initial IPC connection failed: ' + error.message)
        this.updateDesktopAppStatus(error)
      })
    } catch (error) {
      log(
        'INFO',
        'Failed to start simple native messaging host: ' + error.message
      )
      throw error
    }
  }

  /**
   * @returns {Promise<void>}
   */
  async connectToIPC() {
    try {
      this.desktopAppStatus = DESKTOP_APP_STATUS.CONNECTING
      log('INFO', `Attempting to connect to IPC server at: ${this.socketPath}`)

      // Create new IPC client connection
      this.ipcClient = new IPC.Client({
        socketPath: this.socketPath,
        connect: true,
        connectTimeout: TIMEOUTS.IPC_CONNECTION,
        methods: COMMAND_DEFINITIONS
      })

      // Wait for connection with timeout
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => {
          reject(new Error('Connection timed out'))
        }, TIMEOUTS.IPC_CONNECTION)
      })

      await Promise.race([this.ipcClient.ready(), timeoutPromise])

      log('INFO', 'Successfully connected to IPC server')

      // Update status
      this.desktopAppStatus = DESKTOP_APP_STATUS.CONNECTED

      // Set up disconnect handler
      this.ipcClient.on('close', () => {
        log('INFO', 'IPC client disconnected')
        this.desktopAppStatus = DESKTOP_APP_STATUS.NOT_RUNNING
        this.ipcClient = null
      })
    } catch (error) {
      log('INFO', `Failed to connect to IPC server: ${error.message}`)
      this.updateDesktopAppStatus(error)

      // Clean up client on failure
      if (this.ipcClient) {
        try {
          this.ipcClient.close()
        } catch {
          // Ignore close errors
        }
        this.ipcClient = null
      }
    }
  }

  /**
   * @param {Error} error
   */
  updateDesktopAppStatus(error) {
    if (error.message.includes('ENOENT')) {
      this.desktopAppStatus = DESKTOP_APP_STATUS.NOT_RUNNING
    } else {
      this.desktopAppStatus = DESKTOP_APP_STATUS.INTEGRATION_DISABLED
    }
  }

  /**
   * @param {Message} message
   * @returns {Promise<void>}
   */
  async handleMessage(message) {
    const { id, method, command, params } = message
    const methodName = method || command

    try {
      // Remove any padding added to work around Chrome 255-byte bug
      const cleanParams = params ? { ...params } : {}
      delete cleanParams.padding

      log(
        'INFO',
        `Processing request: ${methodName} with params: ${JSON.stringify(cleanParams)}`
      )

      // Handle special checkAvailability command
      if (methodName === 'checkAvailability') {
        // Always try to connect when checking availability
        if (this.desktopAppStatus !== DESKTOP_APP_STATUS.CONNECTED) {
          log('INFO', 'Checking availability - attempting to connect...')
          try {
            await this.connectToIPC()
          } catch (connectError) {
            log(
              'INFO',
              `Availability check - connection failed: ${connectError.message}`
            )
          }
        }

        const response = {
          id,
          success: true,
          result: {
            available: this.desktopAppStatus === DESKTOP_APP_STATUS.CONNECTED,
            status: this.desktopAppStatus,
            message:
              STATUS_MESSAGES[this.desktopAppStatus] ||
              STATUS_MESSAGES[DESKTOP_APP_STATUS.UNKNOWN]
          }
        }
        this.handler.send(response)
        log(
          'INFO',
          `Sent availability check response: ${JSON.stringify(response)}`
        )
        return
      }

      // For all other commands, check if desktop app is available
      if (this.desktopAppStatus !== DESKTOP_APP_STATUS.CONNECTED) {
        // Try to reconnect first
        log('INFO', 'Desktop app not connected, attempting to connect...')
        try {
          await this.connectToIPC()
        } catch (connectError) {
          log('INFO', `Failed to connect: ${connectError.message}`)
        }

        // Check again after connection attempt
        if (this.desktopAppStatus !== DESKTOP_APP_STATUS.CONNECTED) {
          const errorMessage =
            STATUS_MESSAGES[this.desktopAppStatus] ||
            STATUS_MESSAGES[DESKTOP_APP_STATUS.UNKNOWN]
          this.handler.send({
            id,
            success: false,
            error: errorMessage,
            errorCode: this.desktopAppStatus
          })
          log('INFO', `Sent error response: ${errorMessage}`)
          return
        }
      }

      // Check if IPC client is still connected
      if (!this.ipcClient || this.ipcClient.closed) {
        log('INFO', 'IPC client is not connected, attempting to reconnect...')
        await this.reconnectIPC()
      }

      let result = null

      // Call the appropriate method on the IPC client with timeout
      if (isValidCommand(methodName) && this.ipcClient[methodName]) {
        // Create a timeout promise
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => {
            reject(
              new Error(
                `IPC call timed out after ${TIMEOUTS.IPC_CALL / 1000} seconds`
              )
            )
          }, TIMEOUTS.IPC_CALL)
        })

        try {
          // Race between the IPC call and timeout
          result = await Promise.race([
            this.ipcClient[methodName](cleanParams),
            timeoutPromise
          ])
        } catch (error) {
          // If it's a timeout or connection error, update status
          if (
            error.message.includes('timed out') ||
            error.message.includes('RPC destroyed')
          ) {
            log('INFO', 'IPC call failed, desktop app may have been closed')
            this.desktopAppStatus = DESKTOP_APP_STATUS.NOT_RUNNING
            this.ipcClient = null
          }
          throw error
        }
      } else {
        throw new Error(`Unknown method: ${methodName}`)
      }

      // Send success response
      this.handler.send({
        id,
        success: true,
        result
      })

      log('INFO', `Sent response for ${methodName}: ${JSON.stringify(result)}`)
    } catch (error) {
      log('INFO', `Error handling message: ${error.message}`)

      // If it's an RPC destroyed error, try to reconnect
      if (error.message.includes('RPC destroyed')) {
        log('INFO', 'RPC destroyed detected, attempting to reconnect...')
        try {
          await this.reconnectIPC()
          // Retry the message after reconnection
          return this.handleMessage(message)
        } catch (reconnectError) {
          log('INFO', `Failed to reconnect: ${reconnectError.message}`)
          this.updateDesktopAppStatus(reconnectError)
        }
      }

      // Send error response
      this.handler.send({
        id,
        success: false,
        error: error.message
      })
    }
  }

  /**
   * @returns {Promise<void>}
   */
  async reconnectIPC() {
    try {
      // Close existing client if any
      if (this.ipcClient) {
        try {
          this.ipcClient.close()
        } catch {
          // Ignore close errors
        }
        this.ipcClient = null
      }

      // Use connectToIPC which handles status updates
      await this.connectToIPC()

      if (this.desktopAppStatus !== DESKTOP_APP_STATUS.CONNECTED) {
        throw new Error(STATUS_MESSAGES[this.desktopAppStatus])
      }
    } catch (error) {
      log('INFO', `Failed to reconnect to IPC server: ${error.message}`)
      throw error
    }
  }

  stop() {
    if (!this.isRunning) {
      return
    }

    this.isRunning = false

    if (this.ipcClient) {
      this.ipcClient.close()
      this.ipcClient = null
    }

    if (this.handler) {
      this.handler.stop()
    }

    log('INFO', 'Simple native messaging host stopped')
  }
}

// Log early to verify logging works
log('INFO', 'Native messaging host script started')

// Create and start the host
const host = new NativeMessagingHost()

// Graceful shutdown
process.on('SIGINT', () => {
  host.stop()
  process.exit(0)
})

process.on('SIGTERM', () => {
  host.stop()
  process.exit(0)
})

process.on('uncaughtException', (error) => {
  log('INFO', 'Uncaught exception: ' + error.message)
  log('INFO', 'Stack trace: ' + error.stack)
  host.stop()
  process.exit(1)
})

process.on('unhandledRejection', (reason, promise) => {
  log('INFO', 'Unhandled rejection at: ' + promise + ' reason: ' + reason)
  host.stop()
  process.exit(1)
})

// Start the host
log('INFO', 'About to start host...')
host.start().catch((error) => {
  log('INFO', 'Failed to start host: ' + error.message)
  log('INFO', 'Stack trace: ' + error.stack)
  process.exit(1)
})
const { EventEmitter } = require('events')

const {
  wrapMessage,
  unwrapMessage,
  isWrappedMessage
} = require('./nativeMessagingProtocol.js')
const { log } = require('./utils')

// Constants
const MESSAGE_SIZE_LIMIT = 1024 * 1024 // 1MB
const HEADER_SIZE = 4

/**
 * Native Messaging Handler - handles Chrome native messaging protocol
 * Includes robust parsing to handle Chrome's length header bugs
 * @extends EventEmitter
 */
class NativeMessagingHandler extends EventEmitter {
  constructor() {
    super()
    /** @type {Buffer} */
    this.inputBuffer = Buffer.alloc(0)
    /** @type {boolean} */
    this.messageInProgress = false
    /** @type {number} */
    this.expectedMessageLength = 0
    /** @type {string} */
    this.accumulatedString = ''
    /** @type {boolean} */
    this.useRobustParsing = true // Use robust parsing by default
  }

  start() {
    log('INFO', 'Starting native messaging handler')
    this._setupStdinListeners()
    process.stdin.resume()
    log('INFO', 'Native messaging handler started')
  }

  /**
   * @private
   */
  _setupStdinListeners() {
    process.stdin.setEncoding(null)
    process.stdin.on('data', (chunk) => this.handleIncomingChunk(chunk))
    process.stdin.on('end', () => this.emit('disconnect'))
    process.stdin.on('error', (err) => {
      log('ERROR', `stdin error: ${err.message}`)
      this.emit('error', err)
    })
  }

  /**
   * @param {Buffer|string} chunk
   */
  handleIncomingChunk(chunk) {
    const buffer = this._ensureBuffer(chunk)
    this.inputBuffer = Buffer.concat([this.inputBuffer, buffer])

    while (this.processNextMessage()) {
      // Continue processing while we have complete messages
    }
  }

  /**
   * @private
   * @param {Buffer|string} chunk
   * @returns {Buffer}
   */
  _ensureBuffer(chunk) {
    return Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, 'binary')
  }

  /**
   * @returns {boolean}
   */
  processNextMessage() {
    if (this.useRobustParsing) {
      return this.processNextMessageRobust()
    }
    return this._processStandardMessage()
  }

  /**
   * @private
   * @returns {boolean}
   */
  _processStandardMessage() {
    if (this.inputBuffer.length < HEADER_SIZE) {
      return false
    }

    if (!this.messageInProgress) {
      if (!this._readMessageLength()) {
        return false
      }
    }

    const totalLength = HEADER_SIZE + this.expectedMessageLength
    if (this.inputBuffer.length < totalLength) {
      return false
    }

    const messageBuffer = this.inputBuffer.slice(HEADER_SIZE, totalLength)
    this.inputBuffer = this.inputBuffer.slice(totalLength)
    this._resetMessageState()

    return this._parseAndEmitMessage(messageBuffer)
  }

  /**
   * @private
   * @returns {boolean}
   */
  _readMessageLength() {
    this.expectedMessageLength = this.inputBuffer.readUInt32LE(0)
    this.messageInProgress = true

    if (this.expectedMessageLength > MESSAGE_SIZE_LIMIT) {
      log('ERROR', `Message too large: ${this.expectedMessageLength}`)
      this._resetBuffer()
      return false
    }
    return true
  }

  /**
   * @private
   */
  _resetMessageState() {
    this.messageInProgress = false
    this.expectedMessageLength = 0
  }

  /**
   * @private
   */
  _resetBuffer() {
    this.inputBuffer = Buffer.alloc(0)
    this._resetMessageState()
  }

  /**
   * @private
   * @param {Buffer} messageBuffer
   * @returns {boolean}
   */
  _parseAndEmitMessage(messageBuffer) {
    try {
      const message = JSON.parse(messageBuffer.toString())
      this._handleParsedMessage(message)
      return true
    } catch (err) {
      log('ERROR', `Failed to parse message: ${err.message}`)
      this.emit('error', new Error('Invalid JSON message'))
      return false
    }
  }

  /**
   * @private
   * @param {Object} message
   */
  _handleParsedMessage(message) {
    if (isWrappedMessage(message)) {
      const unwrapped = unwrapMessage(message)
      if (unwrapped) {
        this.emit('message', unwrapped)
      } else {
        this.emit('error', new Error('Failed to unwrap protocol message'))
      }
    } else {
      this.emit('message', message)
    }
  }

  /**
   * Robust message processing that handles Chrome's length header bugs
   * Chrome sometimes sends incorrect length headers, especially around 255 bytes
   * @returns {boolean}
   */
  processNextMessageRobust() {
    if (this.inputBuffer.length < 4) {
      return false
    }

    // Skip Chrome's potentially incorrect length header
    const dataAfterHeader = this.inputBuffer.slice(4).toString('utf8')
    this.accumulatedString = dataAfterHeader

    // Find complete JSON objects by parsing braces
    let foundMessage = false
    let startIndex = 0

    while (startIndex < this.accumulatedString.length) {
      const openBrace = this.accumulatedString.indexOf('{', startIndex)
      if (openBrace === -1) {
        break
      }

      // Parse JSON manually to find the end
      let braceCount = 0
      let inString = false
      let escapeNext = false
      let endIndex = -1

      for (let i = openBrace; i < this.accumulatedString.length; i++) {
        const char = this.accumulatedString[i]

        if (escapeNext) {
          escapeNext = false
          continue
        }

        if (char === '\\') {
          escapeNext = true
          continue
        }

        if (char === '"' && !escapeNext) {
          inString = !inString
          continue
        }

        if (!inString) {
          if (char === '{') {
            braceCount++
          } else if (char === '}') {
            braceCount--
            if (braceCount === 0) {
              endIndex = i + 1
              break
            }
          }
        }
      }

      if (endIndex === -1) {
        // Incomplete JSON, wait for more data
        return false
      }

      const jsonStr = this.accumulatedString.substring(openBrace, endIndex)

      try {
        const message = JSON.parse(jsonStr)

        if (isWrappedMessage(message)) {
          const unwrapped = unwrapMessage(message)
          if (unwrapped) {
            this.emit('message', unwrapped)
          } else {
            this.emit('error', new Error('Failed to unwrap protocol message'))
          }
        } else {
          this.emit('message', message)
        }

        // Remove processed message from buffer
        const bytesToRemove =
          4 +
          Buffer.from(this.accumulatedString.substring(0, endIndex), 'utf8')
            .length
        this.inputBuffer = this.inputBuffer.slice(bytesToRemove)

        foundMessage = true
        break
      } catch (err) {
        log('ERROR', `Failed to parse JSON: ${err.message}`)
        startIndex = openBrace + 1
      }
    }

    // Clear buffer if it gets too large without valid messages
    if (!foundMessage && this.inputBuffer.length > 10000) {
      log('ERROR', 'Buffer too large without valid message, clearing')
      this.inputBuffer = Buffer.alloc(0)
      this.accumulatedString = ''
    }

    return foundMessage
  }

  /**
   * @param {Object} message
   */
  send(message) {
    try {
      log('DEBUG', `Sending message: ${JSON.stringify(message)}`)

      // Wrap the message with protocol
      const wrapped = wrapMessage(message)
      const jsonStr = JSON.stringify(wrapped)
      const jsonBuffer = Buffer.from(jsonStr)

      // Create 4-byte length header
      const header = Buffer.allocUnsafe(4)
      header.writeUInt32LE(jsonBuffer.length, 0)

      // Write header and message
      process.stdout.write(header)
      process.stdout.write(jsonBuffer)

      log('DEBUG', 'Message sent successfully')
    } catch (err) {
      log('ERROR', `Failed to send message: ${err.message}`)
      this.emit('error', err)
    }
  }

  stop() {
    process.stdin.pause()
    process.stdin.removeAllListeners()
    this.inputBuffer = Buffer.alloc(0)
    log('INFO', 'Native messaging handler stopped')
  }

  // eslint-disable-next-line no-unused-vars
  addListener(_eventName, _listener) {
    return undefined
  }

  eventNames() {
    return undefined
  }

  getMaxListeners() {
    return 0
  }

  // eslint-disable-next-line no-unused-vars
  listenerCount(_eventName, _listener) {
    return 0
  }

  // eslint-disable-next-line no-unused-vars
  listeners(_eventName) {
    return undefined
  }

  // eslint-disable-next-line no-unused-vars
  off(_eventName, _listener) {
    return undefined
  }

  // eslint-disable-next-line no-unused-vars
  once(_eventName, _listener) {
    return undefined
  }

  // eslint-disable-next-line no-unused-vars
  prependListener(_eventName, _listener) {
    return undefined
  }

  // eslint-disable-next-line no-unused-vars
  prependOnceListener(_eventName, _listener) {
    return undefined
  }

  // eslint-disable-next-line no-unused-vars
  rawListeners(_eventName) {
    return undefined
  }

  // eslint-disable-next-line no-unused-vars
  removeAllListeners(_eventName) {
    return undefined
  }

  // eslint-disable-next-line no-unused-vars
  setMaxListeners(_n) {
    return undefined
  }
}

module.exports = { NativeMessagingHandler }
/**
 * Protocol wrapper for native messaging
 */

/**
 * @typedef {Object} WrappedMessage
 * @property {number} length - Original message length in bytes
 * @property {Object} message - The actual message
 */

/**
 * Wrap a message with protocol metadata
 * @param {Object} message - The message to wrap
 * @returns {WrappedMessage}
 */
const wrapMessage = (message) => {
  const originalJson = JSON.stringify(message)
  const originalLength = Buffer.from(originalJson).length

  return {
    length: originalLength,
    message: message
  }
}

/**
 * Unwrap a message from protocol
 * @param {WrappedMessage} wrapped - The wrapped message
 * @returns {Object|null} The original message or null if invalid
 */
const unwrapMessage = (wrapped) => {
  if (
    !wrapped ||
    typeof wrapped !== 'object' ||
    !wrapped.message ||
    typeof wrapped.length !== 'number'
  ) {
    return null
  }

  const messageJson = JSON.stringify(wrapped.message)
  const actualLength = Buffer.from(messageJson).length

  if (actualLength !== wrapped.length) {
    return null
  }

  return wrapped.message
}

/**
 * Check if a message is wrapped
 * @param {*} message - The message to check
 * @returns {boolean}
 */
const isWrappedMessage = (message) =>
  !!message &&
  typeof message === 'object' &&
  'length' in message &&
  'message' in message

module.exports = {
  wrapMessage,
  unwrapMessage,
  isWrappedMessage
}
function isBuffer (value) {
  return Buffer.isBuffer(value) || value instanceof Uint8Array
}

function isEncoding (encoding) {
  return Buffer.isEncoding(encoding)
}

function alloc (size, fill, encoding) {
  return Buffer.alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  return Buffer.allocUnsafe(size)
}

function allocUnsafeSlow (size) {
  return Buffer.allocUnsafeSlow(size)
}

function byteLength (string, encoding) {
  return Buffer.byteLength(string, encoding)
}

function compare (a, b) {
  return Buffer.compare(a, b)
}

function concat (buffers, totalLength) {
  return Buffer.concat(buffers, totalLength)
}

function copy (source, target, targetStart, start, end) {
  return toBuffer(source).copy(target, targetStart, start, end)
}

function equals (a, b) {
  return toBuffer(a).equals(b)
}

function fill (buffer, value, offset, end, encoding) {
  return toBuffer(buffer).fill(value, offset, end, encoding)
}

function from (value, encodingOrOffset, length) {
  return Buffer.from(value, encodingOrOffset, length)
}

function includes (buffer, value, byteOffset, encoding) {
  return toBuffer(buffer).includes(value, byteOffset, encoding)
}

function indexOf (buffer, value, byfeOffset, encoding) {
  return toBuffer(buffer).indexOf(value, byfeOffset, encoding)
}

function lastIndexOf (buffer, value, byteOffset, encoding) {
  return toBuffer(buffer).lastIndexOf(value, byteOffset, encoding)
}

function swap16 (buffer) {
  return toBuffer(buffer).swap16()
}

function swap32 (buffer) {
  return toBuffer(buffer).swap32()
}

function swap64 (buffer) {
  return toBuffer(buffer).swap64()
}

function toBuffer (buffer) {
  if (Buffer.isBuffer(buffer)) return buffer
  return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength)
}

function toString (buffer, encoding, start, end) {
  return toBuffer(buffer).toString(encoding, start, end)
}

function write (buffer, string, offset, length, encoding) {
  return toBuffer(buffer).write(string, offset, length, encoding)
}

function writeDoubleLE (buffer, value, offset) {
  return toBuffer(buffer).writeDoubleLE(value, offset)
}

function writeFloatLE (buffer, value, offset) {
  return toBuffer(buffer).writeFloatLE(value, offset)
}

function writeUInt32LE (buffer, value, offset) {
  return toBuffer(buffer).writeUInt32LE(value, offset)
}

function writeInt32LE (buffer, value, offset) {
  return toBuffer(buffer).writeInt32LE(value, offset)
}

function readDoubleLE (buffer, offset) {
  return toBuffer(buffer).readDoubleLE(offset)
}

function readFloatLE (buffer, offset) {
  return toBuffer(buffer).readFloatLE(offset)
}

function readUInt32LE (buffer, offset) {
  return toBuffer(buffer).readUInt32LE(offset)
}

function readInt32LE (buffer, offset) {
  return toBuffer(buffer).readInt32LE(offset)
}

function writeDoubleBE (buffer, value, offset) {
  return toBuffer(buffer).writeDoubleBE(value, offset)
}

function writeFloatBE (buffer, value, offset) {
  return toBuffer(buffer).writeFloatBE(value, offset)
}

function writeUInt32BE (buffer, value, offset) {
  return toBuffer(buffer).writeUInt32BE(value, offset)
}

function writeInt32BE (buffer, value, offset) {
  return toBuffer(buffer).writeInt32BE(value, offset)
}

function readDoubleBE (buffer, offset) {
  return toBuffer(buffer).readDoubleBE(offset)
}

function readFloatBE (buffer, offset) {
  return toBuffer(buffer).readFloatBE(offset)
}

function readUInt32BE (buffer, offset) {
  return toBuffer(buffer).readUInt32BE(offset)
}

function readInt32BE (buffer, offset) {
  return toBuffer(buffer).readInt32BE(offset)
}

module.exports = {
  isBuffer,
  isEncoding,
  alloc,
  allocUnsafe,
  allocUnsafeSlow,
  byteLength,
  compare,
  concat,
  copy,
  equals,
  fill,
  from,
  includes,
  indexOf,
  lastIndexOf,
  swap16,
  swap32,
  swap64,
  toBuffer,
  toString,
  write,
  writeDoubleLE,
  writeFloatLE,
  writeUInt32LE,
  writeInt32LE,
  readDoubleLE,
  readFloatLE,
  readUInt32LE,
  readInt32LE,
  writeDoubleBE,
  writeFloatBE,
  writeUInt32BE,
  writeInt32BE,
  readDoubleBE,
  readFloatBE,
  readUInt32BE,
  readInt32BE

}
{
  "name": "b4a",
  "version": "1.6.7",
  "description": "Bridging the gap between buffers and typed arrays",
  "main": "index.js",
  "files": [
    "browser.js",
    "index.js",
    "lib"
  ],
  "browser": {
    "./index.js": "./browser.js"
  },
  "scripts": {
    "test": "standard && brittle test/*.mjs"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/holepunchto/b4a.git"
  },
  "author": "Holepunch",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/holepunchto/b4a/issues"
  },
  "homepage": "https://github.com/holepunchto/b4a#readme",
  "devDependencies": {
    "brittle": "^3.5.2",
    "nanobench": "^3.0.0",
    "standard": "^17.1.0"
  }
}
const resolve = require('bare-module-resolve')
const { Version } = require('bare-semver')
const errors = require('./lib/errors')

module.exports = exports = function resolve(
  specifier,
  parentURL,
  opts,
  readPackage
) {
  if (typeof opts === 'function') {
    readPackage = opts
    opts = {}
  } else if (typeof readPackage !== 'function') {
    readPackage = defaultReadPackage
  }

  return {
    *[Symbol.iterator]() {
      const generator = exports.addon(specifier, parentURL, opts)

      let next = generator.next()

      while (next.done !== true) {
        const value = next.value

        if (value.package) {
          next = generator.next(readPackage(value.package))
        } else {
          next = generator.next(yield value.resolution)
        }
      }

      return next.value
    },

    async *[Symbol.asyncIterator]() {
      const generator = exports.addon(specifier, parentURL, opts)

      let next = generator.next()

      while (next.done !== true) {
        const value = next.value

        if (value.package) {
          next = generator.next(await readPackage(value.package))
        } else {
          next = generator.next(yield value.resolution)
        }
      }

      return next.value
    }
  }
}

function defaultReadPackage() {
  return null
}

const { UNRESOLVED, YIELDED, RESOLVED } = resolve.constants

exports.constants = {
  UNRESOLVED,
  YIELDED,
  RESOLVED
}

exports.addon = function* (specifier, parentURL, opts = {}) {
  const { resolutions = null } = opts

  if (exports.startsWithWindowsDriveLetter(specifier)) {
    specifier = '/' + specifier
  }

  let status

  if (resolutions) {
    status = yield* resolve.preresolved(specifier, resolutions, parentURL, opts)

    if (status) return status
  }

  status = yield* exports.url(specifier, parentURL, opts)

  if (status) return status

  let version = null

  const i = specifier.lastIndexOf('@')

  if (i > 0) {
    version = specifier.substring(i + 1)

    try {
      Version.parse(version)

      specifier = specifier.substring(0, i)
    } catch {
      version = null
    }
  }

  if (
    specifier === '.' ||
    specifier === '..' ||
    specifier[0] === '/' ||
    specifier[0] === '\\' ||
    specifier.startsWith('./') ||
    specifier.startsWith('.\\') ||
    specifier.startsWith('../') ||
    specifier.startsWith('..\\')
  ) {
    return yield* exports.directory(specifier, version, parentURL, opts)
  }

  return yield* exports.package(specifier, version, parentURL, opts)
}

exports.url = function* (url, parentURL, opts = {}) {
  let resolution
  try {
    resolution = new URL(url)
  } catch {
    return UNRESOLVED
  }

  const resolved = yield { resolution }

  return resolved ? RESOLVED : YIELDED
}

exports.package = function* (
  packageSpecifier,
  packageVersion,
  parentURL,
  opts = {}
) {
  if (packageSpecifier === '') {
    throw errors.INVALID_ADDON_SPECIFIER(
      `Addon specifier '${packageSpecifier}' is not a valid package name`
    )
  }

  let packageName

  if (packageSpecifier[0] !== '@') {
    packageName = packageSpecifier.split('/', 1).join()
  } else {
    if (!packageSpecifier.includes('/')) {
      throw errors.INVALID_ADDON_SPECIFIER(
        `Addon specifier '${packageSpecifier}' is not a valid package name`
      )
    }

    packageName = packageSpecifier.split('/', 2).join('/')
  }

  if (
    packageName[0] === '.' ||
    packageName.includes('\\') ||
    packageName.includes('%')
  ) {
    throw errors.INVALID_ADDON_SPECIFIER(
      `Addon specifier '${packageSpecifier}' is not a valid package name`
    )
  }

  const packageSubpath = '.' + packageSpecifier.substring(packageName.length)

  const status = yield* exports.packageSelf(
    packageName,
    packageSubpath,
    packageVersion,
    parentURL,
    opts
  )

  if (status) return status

  parentURL = new URL(parentURL.href)

  do {
    const packageURL = new URL('node_modules/' + packageName + '/', parentURL)

    parentURL.pathname = parentURL.pathname.substring(
      0,
      parentURL.pathname.lastIndexOf('/')
    )

    const info = yield { package: new URL('package.json', packageURL) }

    if (info) {
      return yield* exports.directory(
        packageSubpath,
        packageVersion,
        packageURL,
        opts
      )
    }
  } while (parentURL.pathname !== '' && parentURL.pathname !== '/')

  return UNRESOLVED
}

exports.packageSelf = function* (
  packageName,
  packageSubpath,
  packageVersion,
  parentURL,
  opts = {}
) {
  for (const packageURL of resolve.lookupPackageScope(parentURL, opts)) {
    const info = yield { package: packageURL }

    if (info) {
      if (info.name === packageName) {
        return yield* exports.directory(
          packageSubpath,
          packageVersion,
          packageURL,
          opts
        )
      }

      break
    }
  }

  return UNRESOLVED
}

exports.lookupPrebuildsScope = function* lookupPrebuildsScope(url, opts = {}) {
  const { resolutions = null } = opts

  if (resolutions) {
    for (const { resolution } of resolve.preresolved(
      '#prebuilds',
      resolutions,
      url,
      opts
    )) {
      if (resolution) return yield resolution
    }
  }

  const scopeURL = new URL(url.href)

  do {
    yield new URL('prebuilds/', scopeURL)

    scopeURL.pathname = scopeURL.pathname.substring(
      0,
      scopeURL.pathname.lastIndexOf('/')
    )

    if (
      scopeURL.pathname.length === 3 &&
      exports.isWindowsDriveLetter(scopeURL.pathname.substring(1))
    ) {
      break
    }
  } while (scopeURL.pathname !== '' && scopeURL.pathname !== '/')
}

exports.file = function* (filename, parentURL, opts = {}) {
  if (parentURL.protocol === 'file:' && /%2f|%5c/i.test(filename)) {
    throw errors.INVALID_ADDON_SPECIFIER(
      `Addon specifier '${filename}' is invalid`
    )
  }

  const { extensions = [] } = opts

  let status = UNRESOLVED

  for (const ext of extensions) {
    if (yield { resolution: new URL(filename + ext, parentURL) }) {
      return RESOLVED
    }

    status = YIELDED
  }

  return status
}

exports.directory = function* (dirname, version, parentURL, opts = {}) {
  const {
    resolutions = null,
    host = null, // Shorthand for single host resolution
    hosts = host !== null ? [host] : [],
    builtins = [],
    matchedConditions = []
  } = opts

  let directoryURL

  if (
    dirname[dirname.length - 1] === '/' ||
    dirname[dirname.length - 1] === '\\'
  ) {
    directoryURL = new URL(dirname, parentURL)
  } else {
    directoryURL = new URL(dirname + '/', parentURL)
  }

  // Internal preresolution path, do not depend on this! It will be removed without
  // warning.
  if (resolutions) {
    const status = yield* resolve.preresolved(
      'bare:addon',
      resolutions,
      directoryURL,
      opts
    )

    if (status) return status
  }

  const unversioned = version === null

  let name = null

  const info = yield { package: new URL('package.json', directoryURL) }

  if (info) {
    if (typeof info.name === 'string' && info.name !== '') {
      if (info.name.includes('__')) {
        throw errors.INVALID_PACKAGE_NAME(
          `Package name '${info.name}' is invalid`
        )
      }

      name = info.name.replace(/\//g, '__').replace(/^@/, '')
    } else {
      return UNRESOLVED
    }

    if (typeof info.version === 'string' && info.version !== '') {
      if (version !== null && info.version !== version) return UNRESOLVED

      version = info.version
    }
  } else {
    return UNRESOLVED
  }

  let status

  status = yield* resolve.builtinTarget(name, version, builtins, opts)

  if (status) return status

  for (const prebuildsURL of exports.lookupPrebuildsScope(directoryURL, opts)) {
    status = UNRESOLVED

    for (const host of hosts) {
      const conditions = host.split('-')

      matchedConditions.push(...conditions)

      if (version !== null) {
        status |= yield* exports.file(
          host + '/' + name + '@' + version,
          prebuildsURL,
          opts
        )
      }

      if (unversioned) {
        status |= yield* exports.file(host + '/' + name, prebuildsURL, opts)
      }

      for (const _ of conditions) matchedConditions.pop()
    }

    if (status === RESOLVED) return status
  }

  return yield* exports.linked(name, version, opts)
}

exports.linked = function* (name, version = null, opts = {}) {
  const {
    linked = true,
    host = null, // Shorthand for single host resolution
    hosts = host !== null ? [host] : [],
    matchedConditions = []
  } = opts

  if (linked === false || hosts.length === 0) return UNRESOLVED

  let status = UNRESOLVED

  for (const host of hosts) {
    const [platform = null] = host.split('-', 1)

    if (platform === null) continue

    matchedConditions.push(platform)

    status |= yield* platformArtefact(name, version, platform, opts)

    matchedConditions.pop()
  }

  return status
}

function* platformArtefact(name, version = null, platform, opts = {}) {
  const { linkedProtocol = 'linked:' } = opts

  if (platform === 'darwin' || platform === 'ios') {
    if (version !== null) {
      if (
        yield {
          resolution: new URL(
            `${linkedProtocol}${name}.${version}.framework/${name}.${version}`
          )
        }
      ) {
        return RESOLVED
      }

      if (platform === 'darwin') {
        if (
          yield {
            resolution: new URL(`${linkedProtocol}lib${name}.${version}.dylib`)
          }
        ) {
          return RESOLVED
        }
      }
    }

    if (
      yield {
        resolution: new URL(`${linkedProtocol}${name}.framework/${name}`)
      }
    ) {
      return RESOLVED
    }

    if (platform === 'darwin') {
      if (
        yield {
          resolution: new URL(`${linkedProtocol}lib${name}.dylib`)
        }
      ) {
        return RESOLVED
      }
    }

    return YIELDED
  }

  if (platform === 'linux' || platform === 'android') {
    if (version !== null) {
      if (
        yield {
          resolution: new URL(`${linkedProtocol}lib${name}.${version}.so`)
        }
      ) {
        return RESOLVED
      }
    }

    if (
      yield {
        resolution: new URL(`${linkedProtocol}lib${name}.so`)
      }
    ) {
      return RESOLVED
    }

    return YIELDED
  }

  if (platform === 'win32') {
    if (version !== null) {
      if (
        yield {
          resolution: new URL(`${linkedProtocol}${name}-${version}.dll`)
        }
      ) {
        return RESOLVED
      }
    }

    if (
      yield {
        resolution: new URL(`${linkedProtocol}${name}.dll`)
      }
    ) {
      return RESOLVED
    }
  }

  return UNRESOLVED
}

exports.isWindowsDriveLetter = resolve.isWindowsDriveLetter

exports.startsWithWindowsDriveLetter = resolve.startsWithWindowsDriveLetter
module.exports = class AddonResolveError extends Error {
  constructor(msg, code, fn = AddonResolveError) {
    super(`${code}: ${msg}`)
    this.code = code

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, fn)
    }
  }

  get name() {
    return 'AddonResolveError'
  }

  static INVALID_ADDON_SPECIFIER(msg) {
    return new AddonResolveError(
      msg,
      'INVALID_ADDON_SPECIFIER',
      AddonResolveError.INVALID_ADDON_SPECIFIER
    )
  }

  static INVALID_PACKAGE_NAME(msg) {
    return new AddonResolveError(
      msg,
      'INVALID_PACKAGE_NAME',
      AddonResolveError.INVALID_PACKAGE_NAME
    )
  }
}
{
  "name": "bare-addon-resolve",
  "version": "1.9.4",
  "description": "Low-level addon resolution algorithm for Bare",
  "exports": {
    "./package": "./package.json",
    ".": {
      "types": "./index.d.ts",
      "default": "./index.js"
    },
    "./errors": {
      "types": "./lib/errors.d.ts",
      "default": "./lib/errors.js"
    }
  },
  "files": [
    "index.js",
    "index.d.ts",
    "lib"
  ],
  "scripts": {
    "test": "prettier . --check && bare test.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/holepunchto/bare-addon-resolve.git"
  },
  "author": "Holepunch",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/holepunchto/bare-addon-resolve/issues"
  },
  "homepage": "https://github.com/holepunchto/bare-addon-resolve#readme",
  "dependencies": {
    "bare-module-resolve": "^1.10.0",
    "bare-semver": "^1.0.0"
  },
  "devDependencies": {
    "bare-url": "^2.1.3",
    "brittle": "^3.2.1",
    "prettier": "^3.3.3",
    "prettier-config-standard": "^7.0.0"
  },
  "peerDependencies": {
    "bare-url": "*"
  },
  "peerDependenciesMeta": {
    "bare-url": {
      "optional": true
    }
  }
}
const errors = require('./lib/errors')

class EventListener {
  constructor() {
    this.list = []
    this.count = 0
  }

  append(ctx, name, fn, once) {
    this.count++
    ctx.emit('newListener', name, fn) // Emit BEFORE adding
    this.list.push([fn, once])
  }

  prepend(ctx, name, fn, once) {
    this.count++
    ctx.emit('newListener', name, fn) // Emit BEFORE adding
    this.list.unshift([fn, once])
  }

  remove(ctx, name, fn) {
    for (let i = 0, n = this.list.length; i < n; i++) {
      const l = this.list[i]

      if (l[0] === fn) {
        this.list.splice(i, 1)

        if (this.count === 1) delete ctx._events[name]

        ctx.emit('removeListener', name, fn) // Emit AFTER removing

        this.count--
        return
      }
    }
  }

  removeAll(ctx, name) {
    const list = [...this.list]
    this.list = []

    if (this.count === list.length) delete ctx._events[name]

    for (let i = list.length - 1; i >= 0; i--) {
      ctx.emit('removeListener', name, list[i][0]) // Emit AFTER removing
    }

    this.count -= list.length
  }

  emit(ctx, name, ...args) {
    const list = [...this.list]

    for (let i = 0, n = list.length; i < n; i++) {
      const l = list[i]

      if (l[1] === true) this.remove(ctx, name, l[0])

      l[0].call(ctx, ...args)
    }

    return list.length > 0
  }
}

function appendListener(ctx, name, fn, once) {
  const e = ctx._events[name] || (ctx._events[name] = new EventListener())
  e.append(ctx, name, fn, once)
  return ctx
}

function prependListener(ctx, name, fn, once) {
  const e = ctx._events[name] || (ctx._events[name] = new EventListener())
  e.prepend(ctx, name, fn, once)
  return ctx
}

function removeListener(ctx, name, fn) {
  const e = ctx._events[name]
  if (e !== undefined) e.remove(ctx, name, fn)
  return ctx
}

function throwUnhandledError(...args) {
  let err

  if (args.length > 0) err = args[0]

  if (err instanceof Error === false) err = errors.UNHANDLED_ERROR(err)

  if (Error.captureStackTrace) {
    Error.captureStackTrace(err, exports.prototype.emit)
  }

  queueMicrotask(() => {
    throw err
  })
}

module.exports = exports = class EventEmitter {
  constructor() {
    this._events = Object.create(null)
  }

  addListener(name, fn) {
    return appendListener(this, name, fn, false)
  }

  addOnceListener(name, fn) {
    return appendListener(this, name, fn, true)
  }

  prependListener(name, fn) {
    return prependListener(this, name, fn, false)
  }

  prependOnceListener(name, fn) {
    return prependListener(this, name, fn, true)
  }

  removeListener(name, fn) {
    return removeListener(this, name, fn)
  }

  on(name, fn) {
    return appendListener(this, name, fn, false)
  }

  once(name, fn) {
    return appendListener(this, name, fn, true)
  }

  off(name, fn) {
    return removeListener(this, name, fn)
  }

  emit(name, ...args) {
    if (name === 'error' && this._events.error === undefined) {
      throwUnhandledError(...args)
    }

    const e = this._events[name]
    return e === undefined ? false : e.emit(this, name, ...args)
  }

  listeners(name) {
    const e = this._events[name]
    return e === undefined ? [] : [...e.list]
  }

  listenerCount(name) {
    const e = this._events[name]
    return e === undefined ? 0 : e.list.length
  }

  getMaxListeners() {
    return EventEmitter.defaultMaxListeners
  }

  setMaxListeners(n) {}

  removeAllListeners(name) {
    if (arguments.length === 0) {
      for (const key of Reflect.ownKeys(this._events)) {
        if (key === 'removeListener') continue
        this.removeAllListeners(key)
      }
      this.removeAllListeners('removeListener')
    } else {
      const e = this._events[name]
      if (e !== undefined) e.removeAll(this, name)
    }
    return this
  }
}

exports.EventEmitter = exports

exports.errors = errors

exports.defaultMaxListeners = 10

exports.on = function on(emitter, name, opts = {}) {
  const { signal } = opts

  if (signal && signal.aborted) {
    throw errors.OPERATION_ABORTED(signal.reason)
  }

  let error = null
  let done = false

  const events = []
  const promises = []

  emitter.on(name, onevent)

  if (name !== 'error') emitter.on('error', onerror)

  if (signal) signal.addEventListener('abort', onabort)

  return {
    next() {
      if (events.length) {
        return Promise.resolve({ value: events.shift(), done: false })
      }

      if (error) {
        const err = error

        error = null

        return Promise.reject(err)
      }

      if (done) return onclose()

      return new Promise((resolve, reject) =>
        promises.push({ resolve, reject })
      )
    },

    return() {
      return onclose()
    },

    throw(err) {
      return onerror(err)
    },

    [Symbol.asyncIterator]() {
      return this
    }
  }

  function onevent(...args) {
    if (promises.length) {
      promises.shift().resolve({ value: args, done: false })
    } else {
      events.push(args)
    }
  }

  function onerror(err) {
    if (promises.length) {
      promises.shift().reject(err)
    } else {
      error = err
    }

    return Promise.resolve({ done: true })
  }

  function onabort() {
    onerror(errors.OPERATION_ABORTED(signal.reason))
  }

  function onclose() {
    emitter.off(name, onevent)

    if (name !== 'error') emitter.off('error', onerror)

    if (signal) signal.removeEventListener('abort', onabort)

    done = true

    if (promises.length) promises.shift().resolve({ done: true })

    return Promise.resolve({ done: true })
  }
}

exports.once = function once(emitter, name, opts = {}) {
  const { signal } = opts

  if (signal && signal.aborted) {
    throw errors.OPERATION_ABORTED(signal.reason)
  }

  return new Promise((resolve, reject) => {
    if (name !== 'error') emitter.on('error', onerror)

    if (signal) signal.addEventListener('abort', onabort)

    emitter.once(name, (...args) => {
      if (name !== 'error') emitter.off('error', onerror)

      if (signal) signal.removeEventListener('abort', onabort)

      resolve(args)
    })

    function onerror(err) {
      emitter.off('error', onerror)

      reject(err)
    }

    function onabort() {
      signal.removeEventListener('abort', onabort)

      onerror(errors.OPERATION_ABORTED(signal.reason))
    }
  })
}

exports.forward = function forward(from, to, names, opts = {}) {
  if (typeof names === 'string') names = [names]

  const { emit = to.emit.bind(to) } = opts

  const listeners = names.map(
    (name) =>
      function onevent(...args) {
        emit(name, ...args)
      }
  )

  to.on('newListener', (name) => {
    const i = names.indexOf(name)

    if (i !== -1 && to.listenerCount(name) === 0) {
      from.on(name, listeners[i])
    }
  }).on('removeListener', (name) => {
    const i = names.indexOf(name)

    if (i !== -1 && to.listenerCount(name) === 0) {
      from.off(name, listeners[i])
    }
  })
}

exports.listenerCount = function listenerCount(emitter, name) {
  return emitter.listenerCount(name)
}

exports.getMaxListeners = function getMaxListeners(emitter) {
  return emitter.getMaxListeners()
}

exports.setMaxListeners = function setMaxListeners(n, ...emitters) {
  if (emitters.length === 0) exports.defaultMaxListeners = n
  else {
    for (const emitter of emitters) {
      emitter.setMaxListeners(n)
    }
  }
}
module.exports = class EventEmitterError extends Error {
  constructor(msg, code, fn = EventEmitterError, opts) {
    super(`${code}: ${msg}`, opts)
    this.code = code

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, fn)
    }
  }

  get name() {
    return 'EventEmitterError'
  }

  static OPERATION_ABORTED(cause, msg = 'Operation aborted') {
    return new EventEmitterError(
      msg,
      'OPERATION_ABORTED',
      EventEmitterError.OPERATION_ABORTED,
      { cause }
    )
  }

  static UNHANDLED_ERROR(cause, msg = 'Unhandled error') {
    return new EventEmitterError(
      msg,
      'UNHANDLED_ERROR',
      EventEmitterError.UNHANDLED_ERROR,
      { cause }
    )
  }
}
{
  "name": "bare-events",
  "version": "2.6.0",
  "description": "Event emitters for JavaScript",
  "exports": {
    ".": {
      "types": "./index.d.ts",
      "default": "./index.js"
    },
    "./package": "./package.json",
    "./errors": "./lib/errors.js"
  },
  "files": [
    "index.js",
    "index.d.ts",
    "lib"
  ],
  "scripts": {
    "test": "npm run lint && npm run test:bare && npm run test:node",
    "test:bare": "bare test.js",
    "test:node": "node test.js",
    "lint": "prettier . --check"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/holepunchto/bare-events.git"
  },
  "author": "Holepunch",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/holepunchto/bare-events/issues"
  },
  "homepage": "https://github.com/holepunchto/bare-events#readme",
  "devDependencies": {
    "brittle": "^3.3.2",
    "prettier": "^3.4.2",
    "prettier-config-standard": "^7.0.0"
  }
}
module.exports = require.addon()
const FIFO = require('fast-fifo')
const EventEmitter = require('bare-events')
const path = require('bare-path')
const { fileURLToPath } = require('bare-url')
const { Readable, Writable } = require('bare-stream')
const binding = require('./binding')
const constants = require('./lib/constants')
const FileError = require('./lib/errors')

const isWindows = Bare.platform === 'win32'

exports.constants = constants

class FileRequest {
  static _free = []

  static borrow() {
    if (this._free.length > 0) return this._free.pop()
    return new FileRequest()
  }

  static return(req) {
    if (this._free.length < 32) this._free.push(req.reset())
    else req.destroy()
  }

  constructor() {
    this._reset()
    this._handle = binding.requestInit(this, this._onresult)
  }

  get handle() {
    return this._handle
  }

  retain(value) {
    this._retain = value // Tie the lifetime of `value` to the lifetime of `this`
  }

  reset() {
    if (this._handle === null) return this

    binding.requestReset(this._handle)

    this._reset()

    return this
  }

  destroy() {
    if (this._handle === null) return this

    binding.requestDestroy(this._handle)

    this._reset()
    this._handle = null

    return this
  }

  then(resolve, reject) {
    return this._promise.then(resolve, reject)
  }

  return() {
    if (this._handle === null) return this

    FileRequest.return(this)

    return this
  }

  [Symbol.dispose]() {
    this.return()
  }

  _reset() {
    const { promise, resolve, reject } = Promise.withResolvers()

    this._promise = promise
    this._resolve = resolve
    this._reject = reject
    this._retain = null
  }

  _onresult(err, status) {
    if (err) this._reject(err)
    else this._resolve(status)
  }
}

function ok(result, cb) {
  if (typeof result === 'function') {
    cb = result
    result = undefined
  }

  if (cb) cb(null, result)
  else return result
}

function fail(err, cb) {
  if (cb) cb(err)
  else throw err
}

function done(err, result, cb) {
  if (typeof result === 'function') {
    cb = result
    result = undefined
  }

  if (err) fail(err, cb)
  else return ok(result, cb)
}

async function open(filepath, flags = 'r', mode = 0o666, cb) {
  if (typeof flags === 'function') {
    cb = flags
    flags = 'r'
    mode = 0o666
  } else if (typeof mode === 'function') {
    cb = mode
    mode = 0o666
  }

  if (typeof flags === 'string') flags = toFlags(flags)
  if (typeof mode === 'string') mode = toMode(mode)

  filepath = toNamespacedPath(filepath)

  using req = FileRequest.borrow()

  let fd
  let err = null
  try {
    binding.open(req.handle, filepath, flags, mode)

    fd = await req
  } catch (e) {
    err = new FileError(e.message, {
      operation: 'open',
      code: e.code,
      path: filepath
    })
  }

  return done(err, fd, cb)
}

function openSync(filepath, flags = 'r', mode = 0o666) {
  if (typeof flags === 'string') flags = toFlags(flags)
  if (typeof mode === 'string') mode = toMode(mode)

  filepath = toNamespacedPath(filepath)

  using req = FileRequest.borrow()

  try {
    return binding.openSync(req.handle, filepath, flags, mode)
  } catch (e) {
    throw new FileError(e.message, {
      operation: 'open',
      code: e.code,
      path: filepath
    })
  }
}

async function close(fd, cb) {
  using req = FileRequest.borrow()

  let err = null
  try {
    binding.close(req.handle, fd)

    await req
  } catch (e) {
    err = new FileError(e.message, { operation: 'close', code: e.code, fd })
  }

  return done(err, cb)
}

function closeSync(fd) {
  using req = FileRequest.borrow()

  try {
    binding.closeSync(req.handle, fd)
  } catch (e) {
    throw new FileError(e.message, { operation: 'close', code: e.code, fd })
  }
}

async function access(filepath, mode = constants.F_OK, cb) {
  if (typeof mode === 'function') {
    cb = mode
    mode = constants.F_OK
  }

  filepath = toNamespacedPath(filepath)

  using req = FileRequest.borrow()

  let err = null
  try {
    binding.access(req.handle, filepath, mode)

    await req
  } catch (e) {
    err = new FileError(e.message, {
      operation: 'access',
      code: e.code,
      path: filepath
    })
  }

  return done(err, cb)
}

function accessSync(filepath, mode = constants.F_OK) {
  filepath = toNamespacedPath(filepath)

  using req = FileRequest.borrow()

  try {
    binding.accessSync(req.handle, filepath, mode)
  } catch (e) {
    throw new FileError(e.message, {
      operation: 'access',
      code: e.code,
      path: filepath
    })
  }
}

async function exists(filepath, cb) {
  let ok = true
  try {
    await access(filepath)
  } catch {
    ok = false
  }

  return done(null, ok, cb)
}

function existsSync(filepath) {
  try {
    accessSync(filepath)
  } catch {
    return false
  }

  return true
}

async function read(fd, buffer, offset = 0, len = buffer.byteLength - offset, pos = -1, cb) {
  if (typeof offset === 'function') {
    cb = offset
    offset = 0
    len = buffer.byteLength
    pos = -1
  } else if (typeof len === 'function') {
    cb = len
    len = buffer.byteLength - offset
    pos = -1
  } else if (typeof pos === 'function') {
    cb = pos
    pos = -1
  }

  if (typeof pos !== 'number') pos = -1

  using req = FileRequest.borrow()

  let bytes
  let err = null
  try {
    binding.read(req.handle, fd, buffer, offset, len, pos)

    bytes = await req
  } catch (e) {
    err = new FileError(e.message, { operation: 'read', code: e.code, fd })
  }

  return done(err, bytes, cb)
}

function readSync(fd, buffer, offset = 0, len = buffer.byteLength - offset, pos = -1) {
  using req = FileRequest.borrow()

  try {
    return binding.readSync(req.handle, fd, buffer, offset, len, pos)
  } catch (e) {
    throw new FileError(e.message, { operation: 'read', code: e.code, fd })
  }
}

async function readv(fd, buffers, pos = -1, cb) {
  if (typeof pos === 'function') {
    cb = pos
    pos = -1
  }

  if (typeof pos !== 'number') pos = -1

  using req = FileRequest.borrow()

  let bytes
  let err = null
  try {
    binding.readv(req.handle, fd, buffers, pos)

    bytes = await req
  } catch (e) {
    err = new FileError(e.message, { operation: 'readv', code: e.code, fd })
  }

  return done(err, bytes, cb)
}

function readvSync(fd, buffers, pos = -1) {
  if (typeof pos !== 'number') pos = -1

  using req = FileRequest.borrow()

  try {
    return binding.readvSync(req.handle, fd, buffers, pos)
  } catch (e) {
    throw new FileError(e.message, { operation: 'readv', code: e.code, fd })
  }
}

async function write(fd, data, offset = 0, len, pos = -1, cb) {
  if (typeof data === 'string') {
    let encoding = len
    cb = pos
    pos = offset

    if (typeof pos === 'function') {
      cb = pos
      pos = -1
      encoding = 'utf8'
    } else if (typeof encoding === 'function') {
      cb = encoding
      encoding = 'utf8'
    }

    if (typeof pos === 'string') {
      encoding = pos
      pos = -1
    }

    data = Buffer.from(data, encoding)
    offset = 0
    len = data.byteLength
  } else if (typeof offset === 'function') {
    cb = offset
    offset = 0
    len = data.byteLength
    pos = -1
  } else if (typeof len === 'function') {
    cb = len
    len = data.byteLength - offset
    pos = -1
  } else if (typeof pos === 'function') {
    cb = pos
    pos = -1
  }

  if (typeof len !== 'number') len = data.byteLength - offset
  if (typeof pos !== 'number') pos = -1

  using req = FileRequest.borrow()

  let bytes
  let err = null
  try {
    binding.write(req.handle, fd, data, offset, len, pos)

    bytes = await req
  } catch (e) {
    err = new FileError(e.message, { operation: 'write', code: e.code, fd })
  }

  return done(err, bytes, cb)
}

function writeSync(fd, data, offset = 0, len, pos = -1) {
  if (typeof data === 'string') {
    let encoding = len
    pos = offset

    if (typeof pos === 'string') {
      encoding = pos
      pos = -1
    }

    data = Buffer.from(data, encoding)
    offset = 0
    len = data.byteLength
  }

  if (typeof len !== 'number') len = data.byteLength - offset
  if (typeof pos !== 'number') pos = -1

  using req = FileRequest.borrow()

  try {
    return binding.writeSync(req.handle, fd, data, offset, len, pos)
  } catch (e) {
    throw new FileError(e.message, { operation: 'write', code: e.code, fd })
  }
}

async function writev(fd, buffers, pos = -1, cb) {
  if (typeof pos === 'function') {
    cb = pos
    pos = -1
  }

  if (typeof pos !== 'number') pos = -1

  using req = FileRequest.borrow()

  let bytes
  let err = null
  try {
    binding.writev(req.handle, fd, buffers, pos)

    bytes = await req
  } catch (e) {
    err = new FileError(e.message, { operation: 'writev', code: e.code, fd })
  }

  return done(err, bytes, cb)
}

function writevSync(fd, buffers, pos = -1) {
  if (typeof pos !== 'number') pos = -1

  using req = FileRequest.borrow()

  try {
    return binding.writevSync(req.handle, fd, buffers, pos)
  } catch (e) {
    throw new FileError(e.message, { operation: 'writev', code: e.code, fd })
  }
}

async function stat(filepath, cb) {
  filepath = toNamespacedPath(filepath)

  using req = FileRequest.borrow()

  let st
  let err = null
  try {
    binding.stat(req.handle, filepath)

    await req

    st = new Stats(...binding.requestResultStat(req.handle))
  } catch (e) {
    err = new FileError(e.message, {
      operation: 'stat',
      code: e.code,
      path: filepath
    })
  }

  return done(err, st, cb)
}

function statSync(filepath) {
  filepath = toNamespacedPath(filepath)

  using req = FileRequest.borrow()

  try {
    binding.statSync(req.handle, filepath)

    return new Stats(...binding.requestResultStat(req.handle))
  } catch (e) {
    throw new FileError(e.message, {
      operation: 'stat',
      code: e.code,
      path: filepath
    })
  }
}

async function lstat(filepath, cb) {
  filepath = toNamespacedPath(filepath)

  using req = FileRequest.borrow()

  let st
  let err = null
  try {
    binding.lstat(req.handle, filepath)

    await req

    st = new Stats(...binding.requestResultStat(req.handle))
  } catch (e) {
    err = new FileError(e.message, {
      operation: 'lstat',
      code: e.code,
      path: filepath
    })
  }

  return done(err, st, cb)
}

function lstatSync(filepath) {
  filepath = toNamespacedPath(filepath)

  using req = FileRequest.borrow()

  try {
    binding.lstatSync(req.handle, filepath)

    return new Stats(...binding.requestResultStat(req.handle))
  } catch (e) {
    throw new FileError(e.message, {
      operation: 'lstat',
      code: e.code,
      path: filepath
    })
  }
}

async function fstat(fd, cb) {
  using req = FileRequest.borrow()

  let st
  let err = null
  try {
    binding.fstat(req.handle, fd)

    await req

    st = new Stats(...binding.requestResultStat(req.handle))
  } catch (e) {
    err = new FileError(e.message, { operation: 'fstat', code: e.code, fd })
  }

  return done(err, st, cb)
}

function fstatSync(fd) {
  using req = FileRequest.borrow()

  try {
    binding.fstatSync(req.handle, fd)

    return new Stats(...binding.requestResultStat(req.handle))
  } catch (e) {
    throw new FileError(e.message, { operation: 'fstat', code: e.code, fd })
  }
}

async function ftruncate(fd, len = 0, cb) {
  if (typeof len === 'function') {
    cb = len
    len = 0
  }

  if (typeof len !== 'number') len = 0

  using req = FileRequest.borrow()

  let err = null
  try {
    binding.ftruncate(req.handle, fd, len)

    await req
  } catch (e) {
    err = new FileError(e.message, { operation: 'ftruncate', code: e.code, fd })
  }

  return done(err, cb)
}

function ftruncateSync(fd, len = 0) {
  if (typeof len !== 'number') len = 0

  using req = FileRequest.borrow()

  try {
    binding.ftruncateSync(req.handle, fd, len)
  } catch (e) {
    throw new FileError(e.message, { operation: 'ftruncate', code: e.code, fd })
  }
}

async function chmod(filepath, mode, cb) {
  if (typeof mode === 'string') mode = toMode(mode)

  filepath = toNamespacedPath(filepath)

  using req = FileRequest.borrow()

  let err = null
  try {
    binding.chmod(req.handle, filepath, mode)

    await req
  } catch (e) {
    err = new FileError(e.message, {
      operation: 'chmod',
      code: e.code,
      path: filepath
    })
  }

  return done(err, cb)
}

function chmodSync(filepath, mode) {
  if (typeof mode === 'string') mode = toMode(mode)

  filepath = toNamespacedPath(filepath)

  using req = FileRequest.borrow()

  try {
    binding.chmodSync(req.handle, filepath, mode)
  } catch (e) {
    throw new FileError(e.message, {
      operation: 'chmod',
      code: e.code,
      path: filepath
    })
  }
}

async function fchmod(fd, mode, cb) {
  if (typeof mode === 'string') mode = toMode(mode)

  using req = FileRequest.borrow()

  let err = null
  try {
    binding.fchmod(req.handle, fd, mode)

    await req
  } catch (e) {
    err = new FileError(e.message, { operation: 'fchmod', code: e.code, fd })
  }

  return done(err, cb)
}

function fchmodSync(fd, mode) {
  if (typeof mode === 'string') mode = toMode(mode)

  using req = FileRequest.borrow()

  try {
    binding.fchmodSync(req.handle, fd, mode)
  } catch (e) {
    throw new FileError(e.message, { operation: 'fchmod', code: e.code, fd })
  }
}

async function utimes(filepath, atime, mtime, cb) {
  if (typeof atime !== 'number') atime = atime.getTime() / 1000
  if (typeof mtime !== 'number') mtime = mtime.getTime() / 1000

  filepath = toNamespacedPath(filepath)

  using req = FileRequest.borrow()

  let err = null
  try {
    binding.utimes(req.handle, filepath, atime, mtime)

    await req
  } catch (e) {
    err = new FileError(e.message, {
      operation: 'utimes',
      code: e.code,
      path: filepath
    })
  }

  return done(err, cb)
}

function utimesSync(filepath, atime, mtime) {
  if (typeof atime !== 'number') atime = atime.getTime() / 1000
  if (typeof mtime !== 'number') mtime = mtime.getTime() / 1000

  filepath = toNamespacedPath(filepath)

  using req = FileRequest.borrow()

  try {
    binding.utimesSync(req.handle, filepath, atime, mtime)
  } catch (e) {
    throw new FileError(e.message, {
      operation: 'utimes',
      code: e.code,
      path: filepath
    })
  }
}

async function mkdir(filepath, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts
    opts = { mode: 0o777 }
  }

  if (typeof opts === 'number') opts = { mode: opts }
  else if (!opts) opts = {}

  const mode = typeof opts.mode === 'number' ? opts.mode : 0o777

  filepath = toNamespacedPath(filepath)

  if (opts.recursive) {
    let err = null
    try {
      try {
        await mkdir(filepath, { mode })
      } catch (err) {
        if (err.code !== 'ENOENT') {
          if (!(await stat(filepath)).isDirectory()) throw err
        } else {
          while (filepath.endsWith(path.sep)) filepath = filepath.slice(0, -1)
          const i = filepath.lastIndexOf(path.sep)
          if (i <= 0) throw err

          await mkdir(filepath.slice(0, i), { mode, recursive: true })

          try {
            await mkdir(filepath, { mode })
          } catch (err) {
            if (!(await stat(filepath)).isDirectory()) throw err
          }
        }
      }
    } catch (e) {
      err = e
    }

    return done(err, cb)
  }

  using req = FileRequest.borrow()

  let err = null
  try {
    binding.mkdir(req.handle, filepath, mode)

    await req
  } catch (e) {
    err = new FileError(e.message, {
      operation: 'mkdir',
      code: e.code,
      path: filepath
    })
  }

  return done(err, cb)
}

function mkdirSync(filepath, opts) {
  if (typeof opts === 'number') opts = { mode: opts }
  else if (!opts) opts = {}

  const mode = typeof opts.mode === 'number' ? opts.mode : 0o777

  filepath = toNamespacedPath(filepath)

  if (opts.recursive) {
    try {
      mkdirSync(filepath, { mode })
    } catch (err) {
      if (err.code !== 'ENOENT') {
        if (!statSync(filepath).isDirectory()) throw err
      } else {
        while (filepath.endsWith(path.sep)) filepath = filepath.slice(0, -1)
        const i = filepath.lastIndexOf(path.sep)
        if (i <= 0) throw err

        mkdirSync(filepath.slice(0, i), { mode, recursive: true })

        try {
          mkdirSync(filepath, { mode })
        } catch (err) {
          if (!statSync(filepath).isDirectory()) throw err
        }
      }
    }

    return
  }

  using req = FileRequest.borrow()

  try {
    binding.mkdirSync(req.handle, filepath, mode)
  } catch (e) {
    throw new FileError(e.message, {
      operation: 'mkdir',
      code: e.code,
      path: filepath
    })
  }
}

async function rmdir(filepath, cb) {
  filepath = toNamespacedPath(filepath)

  using req = FileRequest.borrow()

  let err = null
  try {
    binding.rmdir(req.handle, filepath)

    await req
  } catch (e) {
    err = new FileError(e.message, {
      operation: 'rmdir',
      code: e.code,
      path: filepath
    })
  }

  return done(err, cb)
}

function rmdirSync(filepath) {
  filepath = toNamespacedPath(filepath)

  using req = FileRequest.borrow()

  try {
    binding.rmdirSync(req.handle, filepath)
  } catch (e) {
    throw new FileError(e.message, {
      operation: 'rmdir',
      code: e.code,
      path: filepath
    })
  }
}

async function rm(filepath, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts
    opts = {}
  }

  if (!opts) opts = {}

  filepath = toNamespacedPath(filepath)

  let err = null
  try {
    const st = await lstat(filepath)

    if (st.isDirectory()) {
      if (opts.recursive) {
        try {
          await rmdir(filepath)
        } catch (err) {
          if (err.code !== 'ENOTEMPTY') throw err

          const files = await readdir(filepath)

          for (const file of files) {
            await rm(filepath + path.sep + file, opts)
          }

          await rmdir(filepath)
        }
      } else {
        throw new FileError('is a directory', {
          operation: 'rm',
          code: 'EISDIR',
          path: filepath
        })
      }
    } else {
      await unlink(filepath)
    }
  } catch (e) {
    if (e.code !== 'ENOENT' || !opts.force) err = e
  }

  return done(err, cb)
}

function rmSync(filepath, opts) {
  if (!opts) opts = {}

  filepath = toNamespacedPath(filepath)

  try {
    const st = lstatSync(filepath)

    if (st.isDirectory()) {
      if (opts.recursive) {
        try {
          rmdirSync(filepath)
        } catch (err) {
          if (err.code !== 'ENOTEMPTY') throw err

          const files = readdirSync(filepath)

          for (const file of files) {
            rmSync(filepath + path.sep + file, opts)
          }

          rmdirSync(filepath)
        }
      } else {
        throw new FileError('is a directory', {
          operation: 'rm',
          code: 'EISDIR',
          path: filepath
        })
      }
    } else {
      unlinkSync(filepath)
    }
  } catch (err) {
    if (err.code !== 'ENOENT' || !opts.force) throw err
  }
}

async function unlink(filepath, cb) {
  filepath = toNamespacedPath(filepath)

  using req = FileRequest.borrow()

  let err = null
  try {
    binding.unlink(req.handle, filepath)

    await req
  } catch (e) {
    err = new FileError(e.message, {
      operation: 'unlink',
      code: e.code,
      path: filepath
    })
  }

  return done(err, cb)
}

function unlinkSync(filepath) {
  filepath = toNamespacedPath(filepath)

  using req = FileRequest.borrow()

  try {
    binding.unlinkSync(req.handle, filepath)
  } catch (e) {
    throw new FileError(e.message, {
      operation: 'unlink',
      code: e.code,
      path: filepath
    })
  }
}

async function rename(src, dst, cb) {
  src = toNamespacedPath(src)
  dst = toNamespacedPath(dst)

  using req = FileRequest.borrow()

  let err = null
  try {
    binding.rename(req.handle, src, dst)

    await req
  } catch (e) {
    err = new FileError(e.message, {
      operation: 'rename',
      code: e.code,
      path: src,
      destination: dst
    })
  }

  return done(err, cb)
}

function renameSync(src, dst) {
  src = toNamespacedPath(src)
  dst = toNamespacedPath(dst)

  using req = FileRequest.borrow()

  try {
    binding.renameSync(req.handle, src, dst)
  } catch (e) {
    throw new FileError(e.message, {
      operation: 'rename',
      code: e.code,
      path: src,
      destination: dst
    })
  }
}

async function copyFile(src, dst, mode = 0, cb) {
  if (typeof mode === 'function') {
    cb = mode
    mode = 0
  }

  src = toNamespacedPath(src)
  dst = toNamespacedPath(dst)

  using req = FileRequest.borrow()

  let err = null
  try {
    binding.copyfile(req.handle, src, dst, mode)

    await req
  } catch (e) {
    err = new FileError(e.message, {
      operation: 'copyfile',
      code: e.code,
      path: src,
      destination: dst
    })
  }

  return done(err, cb)
}

function copyFileSync(src, dst, mode = 0) {
  src = toNamespacedPath(src)
  dst = toNamespacedPath(dst)

  using req = FileRequest.borrow()

  try {
    binding.copyfileSync(req.handle, src, dst, mode)
  } catch (e) {
    throw new FileError(e.message, {
      operation: 'copyfile',
      code: e.code,
      path: src,
      destination: dst
    })
  }
}

async function cp(src, dst, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts
    opts = {}
  }

  if (!opts) opts = {}

  src = toNamespacedPath(src)
  dst = toNamespacedPath(dst)

  let err = null
  try {
    const st = await lstat(src)

    if (st.isDirectory()) {
      if (opts.recursive !== true) {
        throw new FileError('is a directory', {
          operation: 'cp',
          code: 'EISDIR',
          path: src
        })
      }

      try {
        await lstat(dst)
      } catch (e) {
        if (e.code === 'ENOENT') {
          await mkdir(dst, { mode: st.mode, recursive: true })
        } else {
          throw e
        }
      }

      const dir = await opendir(src)
      for await (const { name } of dir) {
        await cp(path.join(src, name), path.join(dst, name), opts)
      }
    } else if (st.isFile()) {
      await copyFile(src, dst)
      await chmod(dst, st.mode)
    }
  } catch (e) {
    err = e
  }

  return done(err, cb)
}

async function realpath(filepath, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts
    opts = {}
  }

  if (typeof opts === 'string') opts = { encoding: opts }
  else if (!opts) opts = {}

  const { encoding = 'utf8' } = opts

  filepath = toNamespacedPath(filepath)

  using req = FileRequest.borrow()

  let res
  let err = null
  try {
    binding.realpath(req.handle, filepath)

    await req

    res = Buffer.from(binding.requestResultString(req.handle))

    if (encoding !== 'buffer') res = res.toString(encoding)
  } catch (e) {
    err = new FileError(e.message, {
      operation: 'realpath',
      code: e.code,
      path: filepath
    })
  }

  return done(err, res, cb)
}

function realpathSync(filepath, opts) {
  if (typeof opts === 'string') opts = { encoding: opts }
  else if (!opts) opts = {}

  const { encoding = 'utf8' } = opts

  filepath = toNamespacedPath(filepath)

  using req = FileRequest.borrow()

  try {
    binding.realpathSync(req.handle, filepath)

    let res = Buffer.from(binding.requestResultString(req.handle))

    if (encoding !== 'buffer') res = res.toString(encoding)

    return res
  } catch (e) {
    throw new FileError(e.message, {
      operation: 'realpath',
      code: e.code,
      path: filepath
    })
  }
}

async function readlink(filepath, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts
    opts = {}
  }

  if (typeof opts === 'string') opts = { encoding: opts }
  else if (!opts) opts = {}

  const { encoding = 'utf8' } = opts

  filepath = toNamespacedPath(filepath)

  using req = FileRequest.borrow()

  let res
  let err = null
  try {
    binding.readlink(req.handle, filepath)

    await req

    res = Buffer.from(binding.requestResultString(req.handle))

    if (encoding !== 'buffer') res = res.toString(encoding)
  } catch (e) {
    err = new FileError(e.message, {
      operation: 'readlink',
      code: e.code,
      path: filepath
    })
  }

  return done(err, res, cb)
}

function readlinkSync(filepath, opts) {
  if (typeof opts === 'string') opts = { encoding: opts }
  else if (!opts) opts = {}

  const { encoding = 'utf8' } = opts

  filepath = toNamespacedPath(filepath)

  using req = FileRequest.borrow()

  try {
    binding.readlinkSync(req.handle, filepath)

    let res = Buffer.from(binding.requestResultString(req.handle))

    if (encoding !== 'buffer') res = res.toString(encoding)

    return res
  } catch (e) {
    throw new FileError(e.message, {
      operation: 'readlink',
      code: e.code,
      path: filepath
    })
  }
}

function normalizeSymlinkTarget(target, type, filepath) {
  if (isWindows) {
    if (type === 'junction') target = path.resolve(filepath, '..', target)

    if (path.isAbsolute(target)) return path.toNamespacedPath(target)

    return target.replace(/\//g, path.sep)
  }

  return target
}

async function symlink(target, filepath, type, cb) {
  if (typeof type === 'function') {
    cb = type
    type = null
  }

  filepath = toNamespacedPath(filepath)

  if (typeof type === 'string') {
    switch (type) {
      case 'file':
      default:
        type = 0
        break
      case 'dir':
        type = constants.UV_FS_SYMLINK_DIR
        break
      case 'junction':
        type = constants.UV_FS_SYMLINK_JUNCTION
        break
    }
  } else if (typeof type !== 'number') {
    if (isWindows) {
      target = path.resolve(filepath, '..', target)

      try {
        type = (await stat(target)).isDirectory()
          ? constants.UV_FS_SYMLINK_DIR
          : constants.UV_FS_SYMLINK_JUNCTION
      } catch {
        type = 0
      }
    } else {
      type = 0
    }
  }

  target = normalizeSymlinkTarget(target)

  using req = FileRequest.borrow()

  let err = null
  try {
    binding.symlink(req.handle, target, filepath, type)

    await req
  } catch (e) {
    err = new FileError(e.message, {
      operation: 'symlink',
      code: e.code,
      path: target,
      destination: filepath
    })
  }

  return done(err, cb)
}

function symlinkSync(target, filepath, type) {
  filepath = toNamespacedPath(filepath)

  if (typeof type === 'string') {
    switch (type) {
      case 'file':
      default:
        type = 0
        break
      case 'dir':
        type = constants.UV_FS_SYMLINK_DIR
        break
      case 'junction':
        type = constants.UV_FS_SYMLINK_JUNCTION
        break
    }
  } else if (typeof type !== 'number') {
    if (isWindows) {
      target = path.resolve(filepath, '..', target)

      try {
        type = statSync(target).isDirectory()
          ? constants.UV_FS_SYMLINK_DIR
          : constants.UV_FS_SYMLINK_JUNCTION
      } catch {
        type = 0
      }
    } else {
      type = 0
    }
  }

  target = normalizeSymlinkTarget(target)

  using req = FileRequest.borrow()

  try {
    binding.symlinkSync(req.handle, target, filepath, type)
  } catch (e) {
    throw new FileError(e.message, {
      operation: 'symlink',
      code: e.code,
      path: target,
      destination: filepath
    })
  }
}

async function opendir(filepath, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts
    opts = {}
  }

  if (typeof opts === 'string') opts = { encoding: opts }
  else if (!opts) opts = {}

  filepath = toNamespacedPath(filepath)

  using req = FileRequest.borrow()

  let dir
  let err = null
  try {
    binding.opendir(req.handle, filepath)

    await req

    dir = new Dir(filepath, binding.requestResultDir(req.handle), opts)
  } catch (e) {
    err = new FileError(e.message, {
      operation: 'opendir',
      code: e.code,
      path: filepath
    })
  }

  return done(err, dir, cb)
}

function opendirSync(filepath, opts) {
  if (typeof opts === 'string') opts = { encoding: opts }
  else if (!opts) opts = {}

  filepath = toNamespacedPath(filepath)

  using req = FileRequest.borrow()

  try {
    binding.opendirSync(req.handle, filepath)

    return new Dir(filepath, binding.requestResultDir(req.handle), opts)
  } catch (e) {
    throw new FileError(e.message, {
      operation: 'opendir',
      code: e.code,
      path: filepath
    })
  }
}

async function readdir(filepath, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts
    opts = {}
  }

  if (typeof opts === 'string') opts = { encoding: opts }
  else if (!opts) opts = {}

  const { withFileTypes = false } = opts

  filepath = toNamespacedPath(filepath)

  let result = []
  let err = null
  try {
    const dir = await opendir(filepath)

    for await (const entry of dir) {
      result.push(withFileTypes ? entry : entry.name)
    }
  } catch (e) {
    result = []
    err = e
  }

  return done(err, result, cb)
}

function readdirSync(filepath, opts) {
  if (typeof opts === 'string') opts = { encoding: opts }
  else if (!opts) opts = {}

  const { withFileTypes = false } = opts

  filepath = toNamespacedPath(filepath)

  const dir = opendirSync(filepath, opts)
  const result = []

  for (const entry of dir) {
    result.push(withFileTypes ? entry : entry.name)
  }

  return result
}

async function readFile(filepath, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts
    opts = {}
  }

  if (typeof opts === 'string') opts = { encoding: opts }
  else if (!opts) opts = {}

  const { encoding = 'buffer' } = opts

  let fd = -1
  let buffer = null
  let err = null
  try {
    fd = await open(filepath, opts.flag || 'r')

    const st = await fstat(fd)

    let len = 0

    if (st.size === 0) {
      const buffers = []

      while (true) {
        buffer = Buffer.allocUnsafe(8192)
        const r = await read(fd, buffer)
        len += r
        if (r === 0) break
        buffers.push(buffer.subarray(0, r))
      }

      buffer = Buffer.concat(buffers)
    } else {
      buffer = Buffer.allocUnsafe(st.size)

      while (true) {
        const r = await read(fd, len ? buffer.subarray(len) : buffer)
        len += r
        if (r === 0 || len === buffer.byteLength) break
      }

      if (len !== buffer.byteLength) buffer = buffer.subarray(0, len)
    }

    if (encoding !== 'buffer') buffer = buffer.toString(encoding)
  } catch (e) {
    err = e
  } finally {
    if (fd !== -1) await close(fd)
  }

  return done(err, buffer, cb)
}

function readFileSync(filepath, opts) {
  if (typeof opts === 'string') opts = { encoding: opts }
  else if (!opts) opts = {}

  const { encoding = 'buffer' } = opts

  let fd = -1
  try {
    fd = openSync(filepath, opts.flag || 'r')

    const st = fstatSync(fd)

    let buffer
    let len = 0

    if (st.size === 0) {
      const buffers = []

      while (true) {
        buffer = Buffer.allocUnsafe(8192)
        const r = readSync(fd, buffer)
        len += r
        if (r === 0) break
        buffers.push(buffer.subarray(0, r))
      }

      buffer = Buffer.concat(buffers)
    } else {
      buffer = Buffer.allocUnsafe(st.size)

      while (true) {
        const r = readSync(fd, len ? buffer.subarray(len) : buffer)
        len += r
        if (r === 0 || len === buffer.byteLength) break
      }

      if (len !== buffer.byteLength) buffer = buffer.subarray(0, len)
    }

    if (encoding !== 'buffer') buffer = buffer.toString(encoding)

    return buffer
  } finally {
    if (fd !== -1) closeSync(fd)
  }
}

async function writeFile(filepath, data, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts
    opts = {}
  }

  if (typeof opts === 'string') opts = { encoding: opts }
  else if (!opts) opts = {}

  if (typeof data === 'string') data = Buffer.from(data, opts.encoding)

  let fd = -1
  let len = 0
  let err = null
  try {
    fd = await open(filepath, opts.flag || 'w', opts.mode || 0o666)

    while (true) {
      len += await write(fd, len ? data.subarray(len) : data)
      if (len === data.byteLength) break
    }
  } catch (e) {
    err = e
  } finally {
    if (fd !== -1) await close(fd)
  }

  return done(err, len, cb)
}

function writeFileSync(filepath, data, opts) {
  if (typeof opts === 'string') opts = { encoding: opts }
  else if (!opts) opts = {}

  if (typeof data === 'string') data = Buffer.from(data, opts.encoding)

  let fd = -1
  try {
    fd = openSync(filepath, opts.flag || 'w', opts.mode || 0o666)

    let len = 0

    while (true) {
      len += writeSync(fd, len ? data.subarray(len) : data)
      if (len === data.byteLength) break
    }
  } finally {
    if (fd !== -1) closeSync(fd)
  }
}

function appendFile(filepath, data, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts
    opts = {}
  }

  if (typeof opts === 'string') opts = { encoding: opts }
  else if (!opts) opts = {}

  if (!opts.flag) opts = { ...opts, flag: 'a' }

  return writeFile(filepath, data, opts, cb)
}

function appendFileSync(filepath, data, opts) {
  if (typeof opts === 'string') opts = { encoding: opts }
  else if (!opts) opts = {}

  if (!opts.flag) opts = { ...opts, flag: 'a' }

  return writeFileSync(filepath, data, opts)
}

function watch(filepath, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts
    opts = {}
  }

  if (typeof opts === 'string') opts = { encoding: opts }
  else if (!opts) opts = {}

  filepath = toNamespacedPath(filepath)

  return new Watcher(filepath, opts, cb)
}

class Stats {
  constructor(
    dev,
    mode,
    nlink,
    uid,
    gid,
    rdev,
    blksize,
    ino,
    size,
    blocks,
    atimeMs,
    mtimeMs,
    ctimeMs,
    birthtimeMs
  ) {
    this.dev = dev
    this.mode = mode
    this.nlink = nlink
    this.uid = uid
    this.gid = gid
    this.rdev = rdev
    this.blksize = blksize
    this.ino = ino
    this.size = size
    this.blocks = blocks
    this.atimeMs = atimeMs
    this.mtimeMs = mtimeMs
    this.ctimeMs = ctimeMs
    this.birthtimeMs = birthtimeMs
    this.atime = new Date(atimeMs)
    this.mtime = new Date(mtimeMs)
    this.ctime = new Date(ctimeMs)
    this.birthtime = new Date(birthtimeMs)
  }

  isDirectory() {
    return (this.mode & constants.S_IFMT) === constants.S_IFDIR
  }

  isFile() {
    return (this.mode & constants.S_IFMT) === constants.S_IFREG
  }

  isBlockDevice() {
    return (this.mode & constants.S_IFMT) === constants.S_IFBLK
  }

  isCharacterDevice() {
    return (this.mode & constants.S_IFCHR) === constants.S_IFCHR
  }

  isFIFO() {
    return (this.mode & constants.S_IFMT) === constants.S_IFIFO
  }

  isSymbolicLink() {
    return (this.mode & constants.S_IFMT) === constants.S_IFLNK
  }

  isSocket() {
    return (this.mode & constants.S_IFMT) === constants.S_IFSOCK
  }
}

class Dir {
  constructor(path, handle, opts = {}) {
    const { encoding = 'utf8', bufferSize = 32 } = opts

    this.path = path

    this._encoding = encoding
    this._capacity = bufferSize
    this._buffer = new FIFO()
    this._ended = false
    this._handle = handle
  }

  async read(cb) {
    if (this._buffer.length) return ok(this._buffer.shift(), cb)
    if (this._ended) return ok(null, cb)

    using req = FileRequest.borrow()

    let entries
    let err = null
    try {
      req.retain(binding.readdir(req.handle, this._handle, this._capacity))

      await req

      entries = binding.requestResultDirents(req.handle)
    } catch (e) {
      err = new FileError(e.message, {
        operation: 'readdir',
        code: e.code,
        path: this.path
      })
    }

    if (err) return fail(err, cb)

    if (entries.length === 0) {
      this._ended = true

      return ok(null, cb)
    }

    for (const entry of entries) {
      let name = Buffer.from(entry.name)

      if (this._encoding !== 'buffer') name = name.toString(this._encoding)

      this._buffer.push(new Dirent(this.path, name, entry.type))
    }

    return ok(this._buffer.shift(), cb)
  }

  readSync() {
    if (this._buffer.length) return this._buffer.shift()
    if (this._ended) return null

    using req = FileRequest.borrow()

    let entries
    try {
      req.retain(binding.readdirSync(req.handle, this._handle, this._capacity))

      entries = binding.requestResultDirents(req.handle)
    } catch (e) {
      throw new FileError(e.message, {
        operation: 'readdir',
        code: e.code,
        path: this.path
      })
    }

    if (entries.length === 0) {
      this._ended = true

      return null
    }

    for (const entry of entries) {
      let name = Buffer.from(entry.name)

      if (this._encoding !== 'buffer') name = name.toString(this._encoding)

      this._buffer.push(new Dirent(this.path, name, entry.type))
    }

    return this._buffer.shift()
  }

  async close(cb) {
    using req = FileRequest.borrow()

    let err = null
    try {
      binding.closedir(req.handle, this._handle)

      await req
    } catch (e) {
      err = new FileError(e.message, {
        operation: 'closedir',
        code: e.code,
        path: this.path
      })
    }

    this._handle = null

    return done(err, cb)
  }

  closeSync() {
    using req = FileRequest.borrow()

    try {
      binding.closedirSync(req.handle, this._handle)
    } catch (e) {
      throw new FileError(e.message, {
        operation: 'closedir',
        code: e.code,
        path: this.path
      })
    }

    this._handle = null
  }

  [Symbol.dispose]() {
    this.closeSync()
  }

  async [Symbol.asyncDispose]() {
    await this.close()
  }

  *[Symbol.iterator]() {
    while (true) {
      const entry = this.readSync()
      if (entry === null) break
      yield entry
    }

    this.closeSync()
  }

  async *[Symbol.asyncIterator]() {
    while (true) {
      const entry = await this.read()
      if (entry === null) break
      yield entry
    }

    await this.close()
  }
}

class Dirent {
  constructor(path, name, type) {
    this.path = path
    this.name = name
    this.type = type
  }

  isFile() {
    return this.type === constants.UV_DIRENT_FILE
  }

  isDirectory() {
    return this.type === constants.UV_DIRENT_DIR
  }

  isSymbolicLink() {
    return this.type === constants.UV_DIRENT_LINK
  }

  isFIFO() {
    return this.type === constants.UV_DIRENT_FIFO
  }

  isSocket() {
    return this.type === constants.UV_DIRENT_SOCKET
  }

  isCharacterDevice() {
    return this.type === constants.UV_DIRENT_CHAR
  }

  isBlockDevice() {
    return this.type === constants.UV_DIRENT_BLOCK
  }
}

class FileReadStream extends Readable {
  constructor(path, opts = {}) {
    const { eagerOpen = true } = opts

    super({ eagerOpen, ...opts })

    this.path = path
    this.fd = typeof opts.fd === 'number' ? opts.fd : -1
    this.flags = opts.flags || 'r'
    this.mode = opts.mode || 0o666

    this._offset = opts.start || 0
    this._missing = 0

    if (opts.length) {
      this._missing = opts.length
    } else if (typeof opts.end === 'number') {
      this._missing = opts.end - this._offset + 1
    } else {
      this._missing = -1
    }
  }

  async _open(cb) {
    let err

    if (this.fd === -1) {
      err = null
      try {
        this.fd = await open(this.path, this.flags, this.mode)
      } catch (e) {
        err = e
      }

      if (err) return cb(err)
    }

    let st
    err = null
    try {
      st = await fstat(this.fd)
    } catch (e) {
      err = e
    }

    if (err) return cb(err)

    if (this._missing === -1) this._missing = st.size

    if (st.size < this._offset) {
      this._offset = st.size
      this._missing = 0
    } else if (st.size < this._offset + this._missing) {
      this._missing = st.size - this._offset
    }

    cb(null)
  }

  async _read(size) {
    if (this._missing <= 0) return this.push(null)

    const data = Buffer.allocUnsafe(Math.min(this._missing, size))

    let len
    let err = null
    try {
      len = await read(this.fd, data, 0, data.byteLength, this._offset)
    } catch (e) {
      err = e
    }

    if (err) return this.destroy(err)

    if (len === 0) return this.push(null)

    if (this._missing < len) len = this._missing

    this._missing -= len
    this._offset += len

    this.push(data.subarray(0, len))
  }

  async _destroy(err, cb) {
    if (this.fd === -1) return cb(err)

    err = null
    try {
      await close(this.fd)
    } catch (e) {
      err = e
    }

    cb(err)
  }
}

class FileWriteStream extends Writable {
  constructor(path, opts = {}) {
    const { eagerOpen = true } = opts

    super({ eagerOpen, ...opts })

    this.path = path
    this.fd = typeof opts.fd === 'number' ? opts.fd : -1
    this.flags = opts.flags || 'w'
    this.mode = opts.mode || 0o666
  }

  async _open(cb) {
    if (this.fd !== -1) return cb(null)

    let err = null
    try {
      this.fd = await open(this.path, this.flags, this.mode)
    } catch (e) {
      err = e
    }

    cb(err)
  }

  async _writev(batch, cb) {
    let err = null
    try {
      await writev(
        this.fd,
        batch.map(({ chunk }) => chunk)
      )
    } catch (e) {
      err = e
    }

    cb(err)
  }

  async _destroy(err, cb) {
    if (this.fd === -1) return cb(err)

    err = null
    try {
      await close(this.fd)
    } catch (e) {
      err = e
    }

    cb(err)
  }
}

class Watcher extends EventEmitter {
  constructor(path, opts, onchange) {
    if (typeof opts === 'function') {
      onchange = opts
      opts = {}
    }

    if (!opts) opts = {}

    const { persistent = true, recursive = false, encoding = 'utf8' } = opts

    super()

    this._closed = false
    this._encoding = encoding
    this._handle = binding.watcherInit(path, recursive, this, this._onevent, this._onclose)

    if (!persistent) this.unref()

    if (onchange) this.on('change', onchange)
  }

  close() {
    if (this._closed) return
    this._closed = true

    binding.watcherClose(this._handle)
  }

  ref() {
    if (this._handle) binding.watcherRef(this._handle)
    return this
  }

  unref() {
    if (this._handle) binding.watcherUnref(this._handle)
    return this
  }

  [Symbol.asyncIterator]() {
    const buffer = []
    let done = false
    let error = null
    let next = null

    this.on('change', (eventType, filename) => {
      if (next) {
        next.resolve({ done: false, value: { eventType, filename } })
        next = null
      } else {
        buffer.push({ eventType, filename })
      }
    })
      .on('error', (err) => {
        done = true
        error = err

        if (next) {
          next.reject(error)
          next = null
        }
      })
      .on('close', () => {
        done = true

        if (next) {
          next.resolve({ done })
          next = null
        }
      })

    return {
      next: () =>
        new Promise((resolve, reject) => {
          if (error) return reject(error)

          if (buffer.length) return resolve({ done: false, value: buffer.shift() })

          if (done) return resolve({ done })

          next = { resolve, reject }
        })
    }
  }

  _onevent(err, events, filename) {
    if (err) {
      this.close()
      this.emit('error', err)
    } else {
      const path =
        this._encoding === 'buffer'
          ? Buffer.from(filename)
          : Buffer.from(filename).toString(this._encoding)

      if (events & binding.UV_RENAME) {
        this.emit('change', 'rename', path)
      }

      if (events & binding.UV_CHANGE) {
        this.emit('change', 'change', path)
      }
    }
  }

  _onclose() {
    this._handle = null

    this.emit('close')
  }
}

exports.access = access
exports.appendFile = appendFile
exports.chmod = chmod
// exports.chown = chown TODO
exports.close = close
exports.copyFile = copyFile
exports.cp = cp
exports.exists = exists
exports.fchmod = fchmod
// exports.fchown = fchown TODO
// exports.fdatasync = fdatasync TODO
exports.fstat = fstat
// exports.fsync = fsync TODO
exports.ftruncate = ftruncate
// exports.futimes = futimes TODO
// exports.lchmod = lchmod TODO
// exports.lchown = lchown TODO
// exports.lutimes = lutimes TODO
// exports.link = link TODO
exports.lstat = lstat
exports.mkdir = mkdir
// exports.mkdtemp = mkdtemp TODO
exports.open = open
exports.opendir = opendir
exports.read = read
exports.readFile = readFile
exports.readdir = readdir
exports.readlink = readlink
exports.readv = readv
exports.realpath = realpath
exports.rename = rename
exports.rm = rm
exports.rmdir = rmdir
exports.stat = stat
// exports.statfs = statfs TODO
exports.symlink = symlink
// exports.truncate = truncate TODO
exports.unlink = unlink
exports.utimes = utimes
exports.watch = watch
exports.write = write
exports.writeFile = writeFile
exports.writev = writev

exports.accessSync = accessSync
exports.appendFileSync = appendFileSync
exports.chmodSync = chmodSync
// exports.chownSync = chownSync TODO
exports.closeSync = closeSync
exports.copyFileSync = copyFileSync
exports.existsSync = existsSync
exports.fchmodSync = fchmodSync
// exports.fchownSync = fchownSync TODO
// exports.fdatasyncSync = fdatasyncSync TODO
exports.fstatSync = fstatSync
// exports.fsyncSync = fsyncSync TODO
exports.ftruncateSync = ftruncateSync
// exports.futimesSync = futimesSync TODO
// exports.lchmodSync = lchmodSync TODO
// exports.lchownSync = lchownSync TODO
// exports.lutimesSync = lutimesSync TODO
// exports.linkSync = linkSync TODO
exports.lstatSync = lstatSync
exports.mkdirSync = mkdirSync
// exports.mkdtempSync = mkdtempSync TODO
exports.openSync = openSync
exports.opendirSync = opendirSync
exports.readFileSync = readFileSync
exports.readSync = readSync
exports.readdirSync = readdirSync
exports.readlinkSync = readlinkSync
exports.readvSync = readvSync
exports.realpathSync = realpathSync
exports.renameSync = renameSync
exports.rmSync = rmSync
exports.rmdirSync = rmdirSync
exports.statSync = statSync
// exports.statfsSync = statfsSync TODO
exports.symlinkSync = symlinkSync
// exports.truncateSync = truncateSync TODO
exports.unlinkSync = unlinkSync
exports.utimesSync = utimesSync
exports.writeFileSync = writeFileSync
exports.writeSync = writeSync
exports.writevSync = writevSync

exports.promises = require('./promises')

exports.Stats = Stats
exports.Dir = Dir
exports.Dirent = Dirent
exports.Watcher = Watcher

exports.ReadStream = FileReadStream

exports.createReadStream = function createReadStream(path, opts) {
  return new FileReadStream(path, opts)
}

exports.WriteStream = FileWriteStream

exports.createWriteStream = function createWriteStream(path, opts) {
  return new FileWriteStream(path, opts)
}

function toNamespacedPath(filepath) {
  if (typeof filepath !== 'string') {
    if (URL.isURL(filepath)) filepath = fileURLToPath(filepath)
    else filepath = filepath.toString()
  }

  return path.toNamespacedPath(filepath)
}

function toFlags(flags) {
  switch (flags) {
    case 'r':
      return constants.O_RDONLY
    case 'rs': // Fall through.
    case 'sr':
      return constants.O_RDONLY | constants.O_SYNC
    case 'r+':
      return constants.O_RDWR
    case 'rs+': // Fall through.
    case 'sr+':
      return constants.O_RDWR | constants.O_SYNC

    case 'w':
      return constants.O_TRUNC | constants.O_CREAT | constants.O_WRONLY
    case 'wx': // Fall through.
    case 'xw':
      return constants.O_TRUNC | constants.O_CREAT | constants.O_WRONLY | constants.O_EXCL

    case 'w+':
      return constants.O_TRUNC | constants.O_CREAT | constants.O_RDWR
    case 'wx+': // Fall through.
    case 'xw+':
      return constants.O_TRUNC | constants.O_CREAT | constants.O_RDWR | constants.O_EXCL

    case 'a':
      return constants.O_APPEND | constants.O_CREAT | constants.O_WRONLY
    case 'ax': // Fall through.
    case 'xa':
      return constants.O_APPEND | constants.O_CREAT | constants.O_WRONLY | constants.O_EXCL
    case 'as': // Fall through.
    case 'sa':
      return constants.O_APPEND | constants.O_CREAT | constants.O_WRONLY | constants.O_SYNC

    case 'a+':
      return constants.O_APPEND | constants.O_CREAT | constants.O_RDWR
    case 'ax+': // Fall through.
    case 'xa+':
      return constants.O_APPEND | constants.O_CREAT | constants.O_RDWR | constants.O_EXCL
    case 'as+': // Fall through.
    case 'sa+':
      return constants.O_APPEND | constants.O_CREAT | constants.O_RDWR | constants.O_SYNC
    default:
      return 0
  }
}

function toMode(mode) {
  return parseInt(mode, 8)
}
const binding = require('../binding')

module.exports = {
  O_RDWR: binding.O_RDWR,
  O_RDONLY: binding.O_RDONLY,
  O_WRONLY: binding.O_WRONLY,
  O_CREAT: binding.O_CREAT,
  O_TRUNC: binding.O_TRUNC,
  O_APPEND: binding.O_APPEND,

  F_OK: binding.F_OK || 0,
  R_OK: binding.R_OK || 0,
  W_OK: binding.W_OK || 0,
  X_OK: binding.X_OK || 0,

  S_IFMT: binding.S_IFMT,
  S_IFREG: binding.S_IFREG,
  S_IFDIR: binding.S_IFDIR,
  S_IFCHR: binding.S_IFCHR,
  S_IFLNK: binding.S_IFLNK,
  S_IFBLK: binding.S_IFBLK || 0,
  S_IFIFO: binding.S_IFIFO || 0,
  S_IFSOCK: binding.S_IFSOCK || 0,

  S_IRUSR: binding.S_IRUSR || 0,
  S_IWUSR: binding.S_IWUSR || 0,
  S_IXUSR: binding.S_IXUSR || 0,
  S_IRGRP: binding.S_IRGRP || 0,
  S_IWGRP: binding.S_IWGRP || 0,
  S_IXGRP: binding.S_IXGRP || 0,
  S_IROTH: binding.S_IROTH || 0,
  S_IWOTH: binding.S_IWOTH || 0,
  S_IXOTH: binding.S_IXOTH || 0,

  UV_DIRENT_UNKNOWN: binding.UV_DIRENT_UNKNOWN,
  UV_DIRENT_FILE: binding.UV_DIRENT_FILE,
  UV_DIRENT_DIR: binding.UV_DIRENT_DIR,
  UV_DIRENT_LINK: binding.UV_DIRENT_LINK,
  UV_DIRENT_FIFO: binding.UV_DIRENT_FIFO,
  UV_DIRENT_SOCKET: binding.UV_DIRENT_SOCKET,
  UV_DIRENT_CHAR: binding.UV_DIRENT_CHAR,
  UV_DIRENT_BLOCK: binding.UV_DIRENT_BLOCK,

  COPYFILE_EXCL: binding.UV_FS_COPYFILE_EXCL,
  COPYFILE_FICLONE: binding.UV_FS_COPYFILE_FICLONE,
  COPYFILE_FICLONE_FORCE: binding.UV_FS_COPYFILE_FICLONE_FORCE,
  UV_FS_SYMLINK_DIR: binding.UV_FS_SYMLINK_DIR,
  UV_FS_SYMLINK_JUNCTION: binding.UV_FS_SYMLINK_JUNCTION
}
const os = require('bare-os')

module.exports = class FileError extends Error {
  constructor(msg, opts = {}) {
    const { code, operation = null, path = null, destination = null, fd = -1 } = opts

    if (operation !== null) msg += describe(operation, opts)

    super(`${code}: ${msg}`)

    this.code = code

    if (operation !== null) this.operation = operation
    if (path !== null) this.path = path
    if (destination !== null) this.destination = destination
    if (fd !== -1) this.fd = fd
  }

  get name() {
    return 'FileError'
  }

  // For Node.js compatibility
  get errno() {
    return os.constants.errnos[this.code]
  }

  // For Node.js compatibility
  get syscall() {
    return this.operation
  }

  // For Node.js compatibility
  get dest() {
    return this.destination
  }
}

function describe(operation, opts) {
  const { path = null, destination = null, fd = -1 } = opts

  let result = `, ${operation}`

  if (path !== null) {
    result += ` ${JSON.stringify(path)}`

    if (destination !== null) {
      result += ` -> ${JSON.stringify(destination)}`
    }
  } else if (fd !== -1) {
    result += ` ${fd}`
  }

  return result
}
{
  "name": "bare-fs",
  "version": "4.5.0",
  "description": "Native file system operations for Javascript",
  "exports": {
    "./package": "./package.json",
    ".": {
      "types": "./index.d.ts",
      "default": "./index.js"
    },
    "./promises": {
      "types": "./promises.d.ts",
      "default": "./promises.js"
    },
    "./constants": {
      "types": "./lib/constants.d.ts",
      "default": "./lib/constants.js"
    }
  },
  "files": [
    "index.js",
    "index.d.ts",
    "promises.js",
    "promises.d.ts",
    "binding.c",
    "binding.js",
    "CMakeLists.txt",
    "lib",
    "prebuilds"
  ],
  "addon": true,
  "scripts": {
    "test": "prettier . --check && bare test.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/holepunchto/bare-fs.git"
  },
  "author": "Holepunch",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/holepunchto/bare-fs/issues"
  },
  "homepage": "https://github.com/holepunchto/bare-fs#readme",
  "engines": {
    "bare": ">=1.16.0"
  },
  "dependencies": {
    "bare-events": "^2.5.4",
    "bare-path": "^3.0.0",
    "bare-stream": "^2.6.4",
    "bare-url": "^2.2.2",
    "fast-fifo": "^1.3.2"
  },
  "devDependencies": {
    "bare-buffer": "^3.0.2",
    "bare-crypto": "^1.11.2",
    "brittle": "^3.1.1",
    "cmake-bare": "^1.1.7",
    "prettier": "^3.4.1",
    "prettier-config-holepunch": "^2.0.0"
  },
  "peerDependencies": {
    "bare-buffer": "*"
  },
  "peerDependenciesMeta": {
    "bare-buffer": {
      "optional": true
    }
  }
}
ELF          >            @       x          @ 8 
 @         @       @       @       0      0                                           41      41                   @1      @A      @A      S      S                                                                                   h      i                                                        Rtd                                            Ptd                                        Qtd                                                         p      p      p                                    GNU _4                                                                      ,                       F   "                                                                                                                                                                                                   8                     J                     ^                                                                                                                                                                                                                                       !                     ,                     @                     L                     Y                     l                                                                                                                                                                                                                                                                                 &                     5                     A                     M                     X                     d                     p                     }                                                                                                                                                                                             	                                          !                     0                     A                     J                     Q                     Z                     d                     t                                                                                                                                                                        U      B             m     B      c                                                                                                   ui	                    M               M   &rMa __gmon_start__ _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize bare_get_module_name_v0 bare_register_module_v0 js_create_function js_set_named_property js_create_uint32 js_get_callback_info js_create_arraybuffer js_create_reference js_add_deferred_teardown_callback js_get_arraybuffer_info uv_fs_req_cleanup js_delete_reference js_finish_deferred_teardown_callback js_create_array_with_length js_create_int64 js_set_element strlen strncpy js_create_object memcpy js_get_value_string_utf8 js_get_value_int32 js_get_env_loop uv_fs_open js_get_value_uint32 uv_fs_close uv_fs_access js_get_value_int64 js_get_array_length malloc js_get_array_elements js_get_typedarray_info uv_fs_read free uv_fs_write uv_fs_ftruncate uv_fs_chmod uv_fs_fchmod js_get_value_double uv_fs_utime uv_fs_rename uv_fs_copyfile uv_fs_mkdir uv_fs_rmdir uv_fs_stat uv_fs_lstat uv_fs_fstat uv_fs_unlink uv_fs_realpath uv_fs_readlink uv_fs_symlink uv_fs_opendir uv_fs_readdir uv_fs_closedir js_get_value_bool uv_fs_event_init uv_fs_event_start uv_err_name uv_strerror js_throw_error uv_fs_event_stop uv_close uv_ref uv_unref uv_cancel js_create_int32 js_open_handle_scope js_get_reference_value js_get_null js_create_string_utf8 js_create_error js_call_function js_close_handle_scope uv_buf_init libc.so.6 GLIBC_2.2.5 GLIBC_2.14 bare-fs@4.bare                      A                   A                                                                                                                                                                                                                       	                    
                                                    (                    0                    8                    @                    H                    P                    X                    `                    h                    p                    x                                                                                                                                                                                                                  !                    "                    #                    $                    %                    &                    '                     (                    )                    *                    +                     ,           (         -           0         .           8         /           @         0           H         1           P         2           X         3           `         4           h         5           p         6           x         7                    8                    9                    :                    ;                    <                    =                    >                    ?                    @                    A                    B                    C                    D                    E                    F                    G                     H                    I                    J                    K                     L               .A     @@accessSync rmdir rmdirSync F_OK S_IFLNK read symlink W_OK S_IRGRP readdir S_IRUSR UV_FS_SYMLINK_DIR watcherRef mkdirSync readlinkSync requestInit close rename readdirSync UV_DIRENT_FILE write ftruncateSync utimes copyfileSync realpath readv unlink closedirSync S_IFCHR UV_DIRENT_LINK ftruncate chmod opendirSync S_IFMT writev utimesSync S_IFSOCK UV_RENAME name requestReset closeSync O_TRUNC UV_CHANGE requestDestroy openSync chmodSync stat X_OK S_IFREG UV_DIRENT_BLOCK bare-fs@4.5.0 watcherClose R_OK S_IFIFO S_IXGRP closedir O_APPEND access mkdir lstatSync O_RDONLY requestResultDir statSync O_CREAT UV_FS_COPYFILE_EXCL requestResultStat readlink fstatSync watcherInit O_WRONLY UV_DIRENT_FIFO fchmod lstat unlinkSync symlinkSync S_IFDIR requestResultDirents readSync copyfile S_IFBLK S_IXOTH S_IWUSR UV_DIRENT_CHAR UV_FS_COPYFILE_FICLONE UV_FS_SYMLINK_JUNCTION open S_IXUSR writeSync fstat watcherUnref S_IWGRP S_IROTH S_IWOTH fchmodSync UV_DIRENT_SOCKET type renameSync UV_DIRENT_DIR UV_FS_COPYFILE_FICLONE_FORCE requestResultString realpathSync O_RDWR UV_DIRENT_UNKNOWN opendir   ;  r   &    $&    :    D;  $  ;  T  $<  t  ?    D@    @    B  4  B  d  B  |  tC    C    DD    TD    dD    tD  ,  E  |  E    F    tG    H    $H  4  H  d  H  |  I    I    tJ    J    TK  4  dK  L  DL    TL    M    $M    M  	  M  ,	  tN  \	  N  t	  $O  	  4O  	  O  	  O  	  tP  $
  P  <
  $Q  l
  4Q  
  Q  
  Q  
  R    R    tS  L  S  d  dT    tT    U    U    V    V  ,  DW  L  W  l  X    $Y    4Y    tZ  <  D[  l  T[    D\    T\    ]    ^  ,  ^  D  _  |  _    _    `    `    a  4  a  L  b  |  b    c    c    d  4  d  L  f    f    g    g    g  D  h  \  h    h    i    i    j  <  j  T  k    k    l    l    m  D  m  \  n    n    o    o    p  L  p  d  q    q    $s    Ts           zR x        X"             4   4   P"  c   BBA D0T ABB          l   6      AD@A,      7      BBA D@| ABB      x7  L    AD0EA$      7     AD@A       $     ;      BAD@vAB   ,  x;  m    AD@fAL   L  ;  D   ABB B(B0A8D+8A0B(B BBA      ,     <      BAG AB            h=                  `=      AD@A     =      AJ ,     =      BAG AB          L  X>      AJ    d  P>  
              |  H>             L     @>  h   ABB B(B0A8DO8A0B(B BBA           `?  
                X?             L     P?  h   ABB B(B0A8DO8A0B(B BBA         d  p@      AD`A     @      AJ ,     @      BAG AB            xA      AJ      pA      ADPA     A      AJ ,     A      BAG AB          L  B      AJ 4   d  B      BBA GA ABB            C      AJ 4     C      BBA GA ABB            C      AJ ,     C      BAG AB          4  @D      AJ ,   L  8D      BAG AB          |  D      AJ ,     D      BAG AB            E      AJ ,     E      BAG AB            xE      AJ    $  pE      AD@A   D  E      AJ ,   \  E      BAG AB            HF      AJ ,     @F      BAG AB            F      AJ ,     F      BAG AB            G      AJ 4   4  G      BBA GA ABB          l  G      AJ ,     G      BAG AB             H      AJ      H      ADpA     H                  H      AD@A   $  @I      AJ 4   <  8I  h   ABA G!X ABA         t  pJ  d    AD0]A     J  L    AD0EA     J  L    AD0EA4      K  k    BBA WBBE ABB  <   	  XK     ABB A(G!(A BBA         L	  8L             <   d	  0L  ;   ABA D`N ABAE` ABA,   	  0M      ABA DP ABA   	  M             <   	  M      ABB A(G (A BBA          ,
  xN             4   D
  pN     ABA G ABA         |
  O                
  O             4   
  O     ABA G ABA         
  0Q                
  (Q             ,      Q      ABA Dp ABA   D  Q             <   \  Q      ABB A(G (A BBA            xR             ,     pR      ABA D` ABA      S             <     S     ABB A(G!(A BBA          <  S             D   T  S      ABB B(A0GA0A(B BBA            T             D     T     ABB B(A0GA0A(B BBA            hU             <     `U      ABB A(G (A BBA          T  V             <   l  V      ABB A(G (A BBA            V             <     V      ABB A(G (A BBA            @W             <     8W      ABB A(G (A BBA          \  W             ,   t  W      ABA DP ABA     pX             <     hX      ABB A(G (A BBA            Y             <      Y      ABB A(G (A BBA          T  Y             <   l  Y      ABB A(G (A BBA            8Z             D     0Z     ABB B(A0GA0A(B BBA            [             <   $   [      ABB A(G (A BBA          d  [             4   |  [     ABA D ABA           \             ,     x\      ABA DP ABA     ]             D     ]  _   ABB B(A0DJ0A(B BBA         \  (^  #           4   t  @^      BBA D@ ABB                        H=u  Hzu  H9tHNe  Ht	        H=Qu  H5Ju  H)HH?HHHtHe  HtfD      =mw   u+UH=d   HtH=t  N  dEw  ]     wH     AWAVSHIHL=HS  LL$LHE1<N  HL$HLL9N  L=H  LL$HLHE1N  HL$HLLM  L=H   LL$HLHE1M  HL$HLLM  L=JH5  LL$HLHE1M  HL$HLLM  L=H  LL$HLHE1PM  HL$HLLMM  L=H  LL$HLHE1M  HL$HLLM  L=H  LL$HLHE1L  HL$HLLL  L=OH)  LL$HLHE1L  HL$HLLL  L=VH  LL$HLHE1dL  HL$HLLaL  L=H  LL$HLHE1)L  HL$HLL&L  L=H  LL$HLHE1K  HL$HLLK  L=H  LL$HLHE1K  HL$HLLK  L=HB  LL$HLHE1xK  HL$HLLuK  L=H  LL$HLHE1=K  HL$HLL:K  L=KH  LL$HLHE1K  HL$HLLJ  L=H  LL$HLHE1J  HL$HLLJ  L=H  LL$HLHE1J  HL$HLLJ  L=H  LL$HLHE1QJ  HL$HLLNJ  L=H  LL$HLHE1J  HL$HLLJ  L=HH  LL$HLHE1I  HL$HLLI  L=H:  LL$HLHE1I  HL$HLLI  L=H  LL$HLHE1eI  HL$HLLbI  L=%H  LL$HLHE1*I  HL$HLL'I  L=Hi  LL$HLHE1H  HL$HLLH  L=H  LL$HLHE1H  HL$HLLH  L=H  LL$HLHE1yH  HL$HLLvH  L=H8  LL$HLHE1>H  HL$HLL;H  L=H  LL$HLHE1H  HL$HLL H  L=H  LL$HLHE1G  HL$HLLG  L=Hw  LL$HLHE1G  HL$HLLG  L=xH  LL$HLHE1RG  HL$HLLOG  L=H  LL$HLHE1G  HL$HLLG  L=Hv  LL$HLHE1F  HL$HLLF  L=HK  LL$HLHE1F  HL$HLLF  L=H  LL$HLHE1fF  HL$HLLcF  L=0H  LL$HLHE1+F  HL$HLL(F  L=H  LL$HLHE1E  HL$HLLE  L=H  LL$HLHE1E  HL$HLLE  L=H$   LL$HLHE1zE  HL$HLLwE  L=H  LL$HLHE1?E  HL$HLL<E  L=HN   LL$HLHE1E  HL$HLLE  L=H#   LL$HLHE1D  HL$HLLD  L=H   LL$HLHE1D  HL$HLLD  L=H]   LL$HLHE1SD  HL$HLLPD  L=uH   LL$HLHE1D  HL$HLLD  L=H   LL$HLHE1C  HL$HLLC  L=lH   LL$HLHE1C  HL$HLLC  L=H   LL$HLHE1gC  HL$HLLdC  L=LHv!  LL$HLHE1,C  HL$HLL)C  L=tHK!  LL$HLHE1B  HL$HLLB  L=3H!  LL$HLHE1B  HL$HLLB  L=H!  LL$HLHE1{B  HL$HLLxB  L=0H*"  LL$HLHE1@B  HL$HLL=B  L=\H!  LL$HLHE1B  HL$HLLB  L=HT"  LL$HLHE1A  HL$HLLA  L=sH)"  LL$HLHE1A  HL$HLLA  L=H^#  LL$HLHE1TA  HL$HLLQA  L=H#  LL$HLHE1A  HL$HLLA  L=H#  LL$HLHE1@  HL$HLL@  HT$H   @  HL$HHL@  HT$H1@  HL$HHL@  HT$H   @  HL$H-HLc@  HT$H@   a@  HL$HHL:@  HT$H   8@  HL$HHL@  HT$H   @  HL$H"HL?  HT$H1?  HL$HHL?  HT$H   ?  HL$HHL?  HT$H   ?  HL$HHLp?  HT$H   n?  HL$H+HLG?  HT$H   E?  HL$HHL?  HT$H   ?  HL$HHL>  HT$H @  >  HL$HHL>  HT$H    >  HL$HHL>  HT$H   >  HL$HHLz>  HT$H `  x>  HL$HHLQ>  HT$H   O>  HL$HIHL(>  HT$H   &>  HL$H{HL=  HT$H   =  HL$HKHL=  HT$H   =  HL$HHL=  HT$H@   =  HL$HHL=  HT$H    =  HL$HHL[=  HT$H   Y=  HL$HHL2=  HT$H   0=  HL$H2HL	=  HT$H   =  HL$HHL<  HT$H   <  HL$H{HL<  HT$H   <  HL$HHL<  HT$H1<  HL$HHLh<  HT$H   f<  HL$HHL?<  HT$H   =<  HL$HHL<  HT$H   <  HL$H%HL;  HT$H   ;  HL$HHL;  HT$H   ;  HL$HrHL;  HT$H   ;  HL$HHLr;  HT$H   p;  HL$H:HLI;  HT$H   G;  HL$HHL ;  HT$H   ;  HL$HSHL:  HT$H   :  HL$HHL:  HT$H   :  HL$H"HL:  HT$H   :  HL$HHL|:  HT$H   z:  HL$HHLS:  HT$H   Q:  HL$HHL*:  LH[A^A_f.      SH0HHD$   HT$HL$ E1E1
:  HT$HL$  H:  HL$H  f    Ht$ H  H   9  Ht$(  HL$H   9  HT$H  H5f  H9  HD$H0[ AWAVSH HHD$   HT$HL$E1E1V9  Ht$HT$H19  H\$L  L  Hw9  H  Lx9  H  Li9  Lq9  1H [A^A_D  SH HHD$   HT$HL$E1E18  Ht$HT$H18  H|$8  1H [@ SH0HHD$(   HT$(HL$ E1E1z8  Ht$ HT$H18  HT$   H8  HD$HppHT$H8  Ht$HL$H18  HD$HpxHT$H8  Ht$HL$H   8  HD$H   HT$Ht8  Ht$HL$H   m8  HD$H   HT$HD8  Ht$HL$H   =8  HD$H   HT$H8  Ht$HL$H   8  HD$H   HT$H7  Ht$HL$H   7  HD$H   HT$H7  Ht$HL$H   7  HD$H   HT$H7  Ht$HL$H   }7  HD$H   HT$HT7  Ht$HL$H   M7  HD$H   HT$H$7  Ht$HL$H	   7  HD$H*   H*   ^NYNXH,HT$H6  Ht$HL$H
   6  HD$WH*   WH*   ^YXH,HT$Hv6  Ht$HL$H   o6  HD$WH*   WH*   ^YXH,HT$H6  Ht$HL$H   6  HD$WH*   WH*  ^@Y@XH,HT$H5  Ht$HL$H   5  HD$H0[AVSH(IHD$    HT$ HL$E1E14  Ht$HL15  H$Hx`y5  HHT$HL$LH4  H|$H$Hp`H\5  HD$H([A^f.     D  SH0HHD$(   HT$(HL$ E1E1Z4  Ht$ HT$H14  HT$HL$   H?4  HD$H@`HL$HHD$H0[ UAWAVAUATSHHIHD$@   HT$@HL$8E1E13  Ht$8HT$L14  HD$LhXHT$LL44  M   HD$H@`HD$E1f.     HD$H(LHM4  Ht$H$LD	4  LHH| 4  ILHHT$(HL$0P3  H|$(Ht L4  H4$HL$0LH2  tLHT$ 2  H4$HL$ LH2  AM9PHD$HH[A\A]A^A_]f.     fAVSHH  HHD$   HT$HL$ E1E12  Ht$ HT$H12  Ht$(Lt$@  HLE1T3  Ht$0HT$HR3  Ht$8HHB3  Ht$HE3  H|$Ht$L$D$L|  L43  HD$  1HH  [A^f.     1)  f     SH0HHD$   HT$HL$ E1E11  Ht$ HT$H11  Ht$(HT$H2  Ht$H2  H|$Ht$T$H  2  HD$  1H0[f     P1  1Y@ AVSHH  HHD$   HT$HL$ E1E11  Ht$ HT$H1A1  Ht$(Lt$@  HLE11  Ht$0HT$H1  Ht$H1  H|$Ht$L$L0  L1  HD$  1HH  [A^f.     D  P1  1Y@      fD  1  f     UAWAVAUATSHXIHD$(   E1HT$(HL$0E1E10  Ht$0HT$L1J0  Ht$8HT$L(1  Ht$HHT$ LF1  Ht$L0  H\$@HT$LH41  l$HH41  IH<    $1  ILHHHE1E11  |$ tE1Lf.     @ I4LCH$    L1HE10  HDl$HL9rH|$Ht$T$LL$ Hd  H$LE0  L0  L0  HD$  1HX[A\A]A^A_]        &  fD  1  f     UAWAVAUATSHXIHD$(   E1HT$(HL$0E1E1.  Ht$0HT$L1.  Ht$8HT$L/  Ht$HHT$ L/  Ht$LY/  H\$@HT$LH/  l$HH/  IH<    /  ILHHHE1E1/  |$ tE1Lf.     @ I4LCH$    L1HE1`/  HDl$HL9rH|$Ht$T$LL$ H  H$LEU/  L=/  L5/  HD$  1HX[A\A]A^A_]     SHPHHD$(   HT$(HL$0E1E1*-  Ht$0HT$H1V-  Ht$8HT$H4.  Ht$@HT$ HR.  Ht$H-  H|$Ht$T$HL$ L  .  HD$  1HP[fP1  1Y@ AVSHH  HHD$   HT$HL$ E1E1u,  Ht$ HT$H1,  Ht$(Lt$@  HLE14-  Ht$0HT$H2-  Ht$H5-  H|$Ht$L$L   L-  HD$  1HH  [A^f.     D  P1  1Y@ SH@HHD$   HT$HL$ E1E1+  Ht$ HT$H1+  Ht$(HT$H,  Ht$0HHt,  Ht$Hw,  H|$Ht$T$$L/  J-  HD$  1H@[fD  P1(  1Y@ AVSHX  HHD$(   HT$(HL$0E1E1*  Ht$0HT$H1!+  Ht$8Lt$P  HLE1+  Ht$@HT$ H,  Ht$HHT$H,  Ht$H+  H|$Ht$D$ L$Hv  L,  HD$  1HX  [A^D  P18  1Y@ AWAVSH`   HHD$   HT$HL$ E1E1*  Ht$ HT$H1?*  Ht$(L$P    HLE1*  Ht$0L|$@  HLE1*  Ht$H*  H|$Ht$L  LL+  HD$  1H`   [A^A_f.     @ P1x  1Y@ AWAVSH`   HHD$   HT$HL$ E1E13)  Ht$ HT$H1_)  Ht$(L$P    HLE1)  Ht$0L|$@  HLE1)  Ht$8HT$H)  Ht$H)  H|$Ht$DD$L  LL*  HD$  1H`   [A^A_    P1  1Y@ AVSHH  HHD$   HT$HL$ E1E1E(  Ht$ HT$H1q(  Ht$(Lt$@  HLE1)  Ht$0HT$H)  Ht$H)  H|$Ht$L$L   L(*  HD$  1HH  [A^f.     D  P1  1Y@ AVSH8  HHD$   HT$HL$ E1E1u'  Ht$ HT$H1'  Ht$(Lt$0  HLE14(  Ht$HG(  H|$Ht$HV  L~)  HD$  1H8  [A^D  P1H  1Y@ AVSH8  HHD$   HT$HL$ E1E1&  Ht$ HT$H1&  Ht$(Lt$0  HLE1'  Ht$H'  H|$Ht$H  L(  HD$  1H8  [A^D  P1  1Y@ AVSH8  HHD$   HT$HL$ E1E1&  Ht$ HT$H1A&  Ht$(Lt$0  HLE1&  Ht$H&  H|$Ht$H  L>(  HD$  1H8  [A^D  P1  1Y@ SH0HHD$   HT$HL$ E1E1j%  Ht$ HT$H1%  Ht$(HT$Ht&  Ht$HG&  H|$Ht$T$H  '  HD$  1H0[f     P1  1Y@ AVSH8  HHD$   HT$HL$ E1E1$  Ht$ HT$H1$  Ht$(Lt$0  HLE1%  Ht$H%  H|$Ht$HV  L'  HD$  1H8  [A^D  P1H  1Y@ AVSH8  HHD$   HT$HL$ E1E1$  Ht$ HT$H1A$  Ht$(Lt$0  HLE1$  Ht$H$  H|$Ht$H  Ln&  HD$  1H8  [A^D  P1  1Y@ AVSH8  HHD$   HT$HL$ E1E1e#  Ht$ HT$H1#  Ht$(Lt$0  HLE1$$  Ht$H7$  H|$Ht$H  L%  HD$  1H8  [A^D  P1  1Y@ AWAVSH`   HHD$   HT$HL$ E1E1"  Ht$ HT$H1"  Ht$(L$P    HLE1o#  Ht$0L|$@  HLE1R#  Ht$8HT$HP#  Ht$HS#  H|$Ht$DD$L  LL$  HD$  1H`   [A^A_    P1  1Y@ AVSH8  HHD$   HT$HL$ E1E1!  Ht$ HT$H1!  Ht$(Lt$0  HLE1"  Ht$H"  H|$Ht$HV  LN$  HD$  1H8  [A^D  P1H  1Y@ SH`HHD$8   HT$8HL$@E1E1!  Ht$@HT$H1F!  Ht$HHT$H12!  Ht$PHT$H"  t$HHT$(HL$0H   Ht$ H!  HD$(HL$H	HD$HL$HHBH|$ Ht$H  s#  HD$  HD$0H`[f.     f1I  f     SH0HHD$   HT$HL$ E1E1*   Ht$ HH1X   Ht$(HT$H1D   Ht$H!  H|$H4$HD$HH  "  H$  1H0[    P1  1Y@ UAVSHp  HHD$(   HT$(HL$0E1E1  Ht$0HT$`  HE1Z   Ht$8HT$Hh"  HT$HL$    HQ  Ht$HD   H|$Ht$E"     H|$L$H5	  HT$`/"  HL$H   f     Ht$@H   H     Ht$H   HL$H     Ht$P   HL$H     HT$H   H5  H  HD$ #!  I!  HLH!  1Hp  [A^]     SH HHD$   HT$HL$E1E1  Ht$HT$H1F  H|$l!  H|$   H5y  d!  1H [f.     fSH HHD$   HT$HL$E1E1  Ht$HT$H1  H|$!  1H [@ SH HHD$   HT$HL$E1E1Z  Ht$HT$H1  H|$   1H [@ AWAVSH     tH   xAL  L  HF  H  LG  H  L8  L[A^A_;  [A^A_D  UAWAVSHX  HHD$(   E1HT$(HL$0E1E1  Ht$0HT$H1  Ht$8Lt$P  HLE1L  Ht$@HT$HJ  Ht$HHT$H8  Ht$ H;  H|$ Ht$L$DD$Lq   MDL#  HD$t	  <hXxHT$H  HD$!  I  HLH  1HX  [A^A_]D  f.     @ UAVSH@H      H  t=L  H  H  H  H  H  LH@[A^]  Ht$8H  H  HT$0H  H  HT$(H  mXxHH  Q!  HL$ HHH    HL$HHH  Ht$ HT$HH  HT$HH  Ht$0HT$(I   HE1  Ht$8H  H@[A^]D  UAVSH0HHD$   E1HT$HL$ E1E1"  Ht$ HT$H1N  Ht$(HT$H,  Ht$H  H|$Ht$T$HZ   ID  HD$t	  &hXy  I  HLH  H0[A^]f.     @ f.     UAWAVSHH  HHD$   E1HT$HL$ E1E1=  Ht$ HT$H1i  Ht$(Lt$@  HLE1  Ht$0HT$H  Ht$H  H|$Ht$L$LX   MDL  HD$t	  &hXy  I  HLH  HH  [A^A_]@ f.     UAVSH   HHD$H   HT$HHL$`E1E1B  Ht$`HT$H1n  Ht$hHT$HL  Ht$pH$    HL$@LD$8H1E1  Ht$xHT$H  H$   HT$H  D$HL$8H9vT$H9w)L$D$    H$   HT$0H  Ht$(H  |$H|$@t$  HD$PHT$XH|$(Ht$T$LL$0H   1@HEH$HL$PA     HD$@t	  <hXxHT$ H  HD$ !<  IB  HLHD  1H   [A^]fD  ;f.     +f.     UAVSH   HHD$H   HT$HHL$`E1E1  Ht$`HT$H1  Ht$hHT$H  Ht$pH$    HL$@LD$8H1E1  Ht$xHT$HV  H$   HT$HA  D$HL$8H9vT$H9w)L$D$    H$   HT$0H3  Ht$(H  |$H|$@t$  HD$PHT$XH|$(Ht$T$LL$0H   1@HEH$HL$PA   C  HD$@t	  <hXxHT$ H
  HD$ !|  I  HLH  1H   [A^]fD  {f.     kf.     UAVSHPHHD$(   E1HT$(HL$0E1E1  Ht$0HT$H1  Ht$8HT$H  Ht$@HT$ H  Ht$H  H|$Ht$T$HL$ LS   MD8  HD$t	  &hXyx  I~  HLH  HP[A^]    {f.     UAWAVSHH  HHD$   E1HT$HL$ E1E1  Ht$ HT$H1  Ht$(Lt$@  HLE1  Ht$0HT$H  Ht$H  H|$Ht$L$LX   MDLJ  HD$t	  &hXyz  I  HLH  HH  [A^A_]@ {f.     UAVSH@HHD$   E1HT$HL$ E1E1  Ht$ HT$H1  Ht$(HT$H  Ht$0HH  Ht$H  H|$Ht$T$$LW   MDl  HD$t	  &hXy  I  HLH  H@[A^]f.     f.     UAWAVSHX  HHD$(   E1HT$(HL$0E1E1  Ht$0HT$H1	  Ht$8Lt$P  HLE1  Ht$@HT$ H  Ht$HHT$H  Ht$H  H|$Ht$D$ L$H^   IDLp  HD$t	  &hXyp  Iv  HLHx  HX  [A^A_]f.     kf.     UAWAVATSH`   HHD$   E1HT$HL$ E1E1  Ht$ HT$H1  Ht$(L$P    HLE1w  Ht$0L|$@  HLE1Z  Ht$Hm  H|$Ht$L\   MDLLk  HD$t	  &hXy[  Ia  HLHc  H`   [A\A^A_] [f.     UAWAVATSH`   HHD$   E1HT$HL$ E1E1  Ht$ HT$H1  Ht$(L$P    HLE1g  Ht$0L|$@  HLE1J  Ht$8HT$HH  Ht$HK  H|$Ht$DD$Le   MDLLT  HD$t	  &hXy4  I:  HLH<  H`   [A\A^A_]f.     f+f.     UAWAVSHH  HHD$   E1HT$HL$ E1E1}  Ht$ HT$H1  Ht$(Lt$@  HLE1<  Ht$0HT$H:  Ht$H=  H|$Ht$L$LX   MDLZ  HD$t	  &hXy*  I0  HLH2  HH  [A^A_]@ +f.     UAWAVSH8  HHD$   E1HT$HL$ E1E1}  Ht$ HT$H1  Ht$(Lt$0  HLE1<  Ht$HO  H|$Ht$H^   IDL  HD$t	  &hXy@  IF  HLHH  H8  [A^A_]f.     ;f.     UAWAVSH8  HHD$   E1HT$HL$ E1E1  Ht$ HT$H1  Ht$(Lt$0  HLE1L  Ht$H_  H|$Ht$H^   IDL  HD$t	  &hXyP  IV  HLHX  H8  [A^A_]f.     Kf.     UAWAVSH8  HHD$   E1HT$HL$ E1E1  Ht$ HT$H1  Ht$(Lt$0  HLE1\  Ht$Ho  H|$Ht$H^   IDL  HD$t	  &hXy`  If  HLHh  H8  [A^A_]f.     [f.     UAVSH0HHD$   E1HT$HL$ E1E1
  Ht$ HT$H1
  Ht$(HT$H  Ht$H  H|$Ht$T$HZ   ID  HD$t	  &hXy  I  HLH  H0[A^]f.     @ {f.     UAWAVSH8  HHD$   E1HT$HL$ E1E1	  Ht$ HT$H1	  Ht$(Lt$0  HLE1
  Ht$H
  H|$Ht$H^   IDL  HD$t	  &hXy  I  HLH  H8  [A^A_]f.     f.     UAWAVSH8  HHD$   E1HT$HL$ E1E1  Ht$ HT$H1		  Ht$(Lt$0  HLE1	  Ht$H	  H|$Ht$H^   IDL0  HD$t	  &hXy  I  HLH  H8  [A^A_]f.     f.     UAWAVSH8  HHD$   E1HT$HL$ E1E1  Ht$ HT$H1  Ht$(Lt$0  HLE1  Ht$H  H|$Ht$H^   IDLP
  HD$t	  &hXy
  I
  HLH
  H8  [A^A_]f.     f.     UAWAVATSH`   HHD$   E1HT$HL$ E1E1  Ht$ HT$H1'  Ht$(L$P    HLE1  Ht$0L|$@  HLE1  Ht$8HT$H  Ht$H  H|$Ht$DD$Le   MDLL4	  HD$t	  &hXy	  I	  HLH	  H`   [A\A^A_]f.     f{f.     UAWAVSH8  HHD$   E1HT$HL$ E1E1  Ht$ HT$H1  Ht$(Lt$0  HLE1  Ht$H  H|$Ht$H^   IDLP  HD$t	  &hXy  I  HLH  H8  [A^A_]f.     f.     UAVSH`HHD$8   E1HT$8HL$@E1E1  Ht$@HT$H1  Ht$HHT$H1  Ht$PHT$H  t$HHT$(HL$0H  Ht$ H  HD$(HL$H	HD$HL$HHBH|$ Ht$H`   ID5  HD$t	  &hXye  Ik  HLHm  HD$0H`[A^]f.     D  [f.     UAVSH0HHD$   E1HT$HL$ E1E1  Ht$ HH1  Ht$(HT$H1  Ht$H  H|$H4$HD$HHW   ID\  H$t	  &hXy}  I  HLH  H0[A^]f.     f{f.     UAWAVATSHP    9  AAIHH   Ht$HH  H   HT$@H  H   HT$8H  ExOHt$H}  HT$HD=  L%  HHL$ HT$HHm  H|$LH-  qD  HL$HHH,  Dt  HL$0HHH  Ht$HT$0HL$H  HT$H1  Ht$ H  Ht$@HT$8LD$   HE1  Ht$HH  HP[A\A^A_]       tH   HH  f.      AWAVSH HL   L       t2H   L  H   L  H   L     Ht$L  H   HT$L  H   HT$L  H   L7  H   L(  H   L  Ht$HT$L1E1E1  Ht$L  L   H [A^A_HHa  HtH HH       5j&  %l&  @ %j&  h    %b&  h   %Z&  h   %R&  h   %J&  h   %B&  h   %:&  h   %2&  h   p%*&  h   `%"&  h	   P%&  h
   @%&  h   0%
&  h    %&  h   %%  h    %%  h   %%  h   %%  h   %%  h   %%  h   %%  h   %%  h   %%  h   %%  h   p%%  h   `%%  h   P%%  h   @%%  h   0%%  h    %%  h   %z%  h    %r%  h   %j%  h    %b%  h!   %Z%  h"   %R%  h#   %J%  h$   %B%  h%   %:%  h&   %2%  h'   p%*%  h(   `%"%  h)   P%%  h*   @%%  h+   0%
%  h,    %%  h-   %$  h.    %$  h/   %$  h0   %$  h1   %$  h2   %$  h3   %$  h4   %$  h5   %$  h6   %$  h7   p%$  h8   `%$  h9   P%$  h:   @%$  h;   0%$  h<    %$  h=   %z$  h>    %r$  h?   %j$  h@   %b$  hA   %Z$  hB   %R$  hC   %J$  hD   %B$  hE   %:$  hF   %2$  hG   p%*$  hH   `                                    &                                  	              o                                                                                                  
      
       5      o    
                                                                    0             L      o    	      o    
      o                                                                                         v                                                                  &      6      F      V      f      v                                                                  &      6      F      V      f      v                                                                  &      6      F      V      f      v                                                                  &      6      F      V      f      v                                                      Ubuntu clang version 14.0.0-1ubuntu1.1 GCC: (Ubuntu 12.3.0-1ubuntu1~22.04.2) 12.3.0  Linker: Ubuntu LLD 14.0.0                                                                      @A              .     pA              A     A              W     (             c                         A                                 p	                                          V                  0W                  W      L           X                [             <    0\      m       W    \      D      v    ]                 ^                 ^                 `_                 p_                 0`                 @`      
           P`                 ``      h          a      
           a             '    a      h      6    `c             H     d             _    d             m    d                 d                 e                 e                 `f                 pf                 @g                 Pg                 0h                 @h                  i             1    i             ?    i             R    i             _    `j             q    pj                 k                  k                 k                 k                 `l                 pl                 m                  m                 m             $    m             4    n             I    n             Y    `o             n    po             ~    Pp                 `p                 p                  q      h          pr      d           r      L           0s      L           s      k       ,    u             =    s            K    0w             ]    `v             l    0x                 @w                 @x                y                  z                {                 |                 {                 }                 |                 ~             .    }             >                 Q    ~            a                 t                                                                                                                                                                                            -                 ?                 N                 a                 q                                      p                                                                                                 	                                 .                 C                 U          _      o          #           @                  u      ;          y                 {                                                  .	                 	   0              (	   L              	                  <                                        :	                      V	                      }	  "                   	     B             	    B      c      	                     	                     	                     	                     
                     !
                     5
                     W
                     o
                     
                     
                     
                     
                     
                     
                     
                                                                                    5                     H                     X                     c                     w                                                                                                                                                                                                                                                            #                     0                     D                     P                     ]                     l                     x                                                                                                                                                                                                                                                                                 .                     @                     L                     X                     g                     x                                                                                                                                                                                                                  	                                          0                      .note.gnu.build-id .dynsym .gnu.version .gnu.version_r .gnu.hash .dynstr .rela.dyn .rela.plt .rodata .eh_frame_hdr .eh_frame .text .init .fini .plt .fini_array .init_array .dynamic .got .data .tm_clone_table .got.plt .bss .comment .symtab .shstrtab .strtab  crtstuff.c __TMC_LIST__ deregister_tm_clones register_tm_clones __do_global_dtors_aux completed.0 __do_global_dtors_aux_fini_array_entry frame_dummy __frame_dummy_init_array_entry binding.c bare_fs_request_init bare_fs_request_destroy bare_fs_request_reset bare_fs_request_result_stat bare_fs_request_result_string bare_fs_request_result_dir bare_fs_request_result_dirents bare_fs_open bare_fs_open_sync bare_fs_close bare_fs_close_sync bare_fs_access bare_fs_access_sync bare_fs_read bare_fs_read_sync bare_fs_readv bare_fs_write bare_fs_write_sync bare_fs_writev bare_fs_ftruncate bare_fs_ftruncate_sync bare_fs_chmod bare_fs_chmod_sync bare_fs_fchmod bare_fs_fchmod_sync bare_fs_utimes bare_fs_utimes_sync bare_fs_rename bare_fs_rename_sync bare_fs_copyfile bare_fs_copyfile_sync bare_fs_mkdir bare_fs_mkdir_sync bare_fs_rmdir bare_fs_rmdir_sync bare_fs_stat bare_fs_stat_sync bare_fs_lstat bare_fs_lstat_sync bare_fs_fstat bare_fs_fstat_sync bare_fs_unlink bare_fs_unlink_sync bare_fs_realpath bare_fs_realpath_sync bare_fs_readlink bare_fs_readlink_sync bare_fs_symlink bare_fs_symlink_sync bare_fs_opendir bare_fs_opendir_sync bare_fs_readdir bare_fs_readdir_sync bare_fs_closedir bare_fs_closedir_sync bare_fs_watcher_init bare_fs_watcher_close bare_fs_watcher_ref bare_fs_watcher_unref bare_fs__on_request_teardown bare_fs__on_open bare_fs__open bare_fs__on_close bare_fs__close bare_fs__on_access bare_fs__access bare_fs__read bare_fs__on_readv bare_fs__write bare_fs__on_writev bare_fs__on_ftruncate bare_fs__ftruncate bare_fs__on_chmod bare_fs__chmod bare_fs__on_fchmod bare_fs__fchmod bare_fs__on_utimes bare_fs__utimes bare_fs__on_rename bare_fs__rename bare_fs__on_copyfile bare_fs__copyfile bare_fs__on_mkdir bare_fs__mkdir bare_fs__on_rmdir bare_fs__rmdir bare_fs__on_stat bare_fs__stat bare_fs__on_lstat bare_fs__lstat bare_fs__on_fstat bare_fs__fstat bare_fs__on_unlink bare_fs__unlink bare_fs__on_realpath bare_fs__realpath bare_fs__on_readlink bare_fs__readlink bare_fs__on_symlink bare_fs__symlink bare_fs__on_opendir bare_fs__opendir bare_fs__on_readdir bare_fs__readdir bare_fs__on_closedir bare_fs__closedir bare_fs__on_watcher_event bare_fs__on_watcher_teardown bare_fs__on_watcher_close bare_fs__on_request_result bare_fs__on_read bare_fs__on_write crtstuff.c __FRAME_END__ __gmon_start__ _init _GLOBAL_OFFSET_TABLE_ _fini __TMC_END__ _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __dso_handle __cxa_finalize bare_get_module_name_v0 bare_register_module_v0 js_create_function js_set_named_property js_create_uint32 js_get_callback_info js_create_arraybuffer js_create_reference js_add_deferred_teardown_callback js_get_arraybuffer_info uv_fs_req_cleanup js_delete_reference js_finish_deferred_teardown_callback js_create_array_with_length js_create_int64 js_set_element strlen strncpy js_create_object memcpy js_get_value_string_utf8 js_get_value_int32 js_get_env_loop uv_fs_open js_get_value_uint32 uv_fs_close uv_fs_access js_get_value_int64 js_get_array_length malloc js_get_array_elements js_get_typedarray_info uv_fs_read free uv_fs_write uv_fs_ftruncate uv_fs_chmod uv_fs_fchmod js_get_value_double uv_fs_utime uv_fs_rename uv_fs_copyfile uv_fs_mkdir uv_fs_rmdir uv_fs_stat uv_fs_lstat uv_fs_fstat uv_fs_unlink uv_fs_realpath uv_fs_readlink uv_fs_symlink uv_fs_opendir uv_fs_readdir uv_fs_closedir js_get_value_bool uv_fs_event_init uv_fs_event_start uv_err_name uv_strerror js_throw_error uv_fs_event_stop uv_close uv_ref uv_unref uv_cancel js_create_int32 js_open_handle_scope js_get_reference_value js_get_null js_create_string_utf8 js_create_error js_call_function js_close_handle_scope uv_buf_init _DYNAMIC                                                                               p      p                                                             h                             o       	      	                                  )   o       
      
      0                            8   o       
      
      $                             B             
      
      5                             J                                                       T      B                                             ^      2                   J                             f                                                      t                                                      ~             @A      @1      N                                          0      0                                                 L      L                                                 `      `                                                                                                                                                                                                                                                                                                                                                                                                     `                                          (      (                                          0               (      o                                                                                                         0                                                         2      E                             const EventEmitter = require('bare-events')
const fs = require('.')

class FileHandle extends EventEmitter {
  constructor(fd) {
    this.fd = fd
  }

  async close() {
    await fs.close(fd)

    this.fd = -1
    this.emit('close')
  }

  async read(buffer, ...args) {
    return {
      bytesRead: await fs.read(this.fd, buffer, ...args),
      buffer
    }
  }

  async readv(buffers, ...args) {
    return {
      bytesRead: await fs.readv(this.fd, buffers, ...args),
      buffers
    }
  }

  async write(buffer, ...args) {
    return {
      bytesWritten: await fs.write(this.fd, buffer, ...args),
      buffer
    }
  }

  async writev(buffers, ...args) {
    return {
      bytesWritten: await fs.writev(this.fd, buffers, ...args),
      buffers
    }
  }

  async stat() {
    return fs.fstat(this.fd)
  }

  async chmod(mode) {
    await fs.fchmod(this.fd, mode)
  }

  createReadStream(opts) {
    return fs.createReadStream(null, { ...opts, fd: this.fd })
  }

  createWriteStream(opts) {
    return fs.createWriteStream(null, { ...opts, fd: this.fd })
  }

  async [Symbol.asyncDispose]() {
    await this.close()
  }
}

exports.open = async function open(filepath, flags, mode) {
  return new FileHandle(await fs.open(filepath, flags, mode))
}

exports.access = fs.access
exports.appendFile = fs.appendFile
exports.chmod = fs.chmod
exports.constants = fs.constants
exports.copyFile = fs.copyFile
exports.cp = fs.cp
exports.lstat = fs.lstat
exports.mkdir = fs.mkdir
exports.opendir = fs.opendir
exports.readFile = fs.readFile
exports.readdir = fs.readdir
exports.readlink = fs.readlink
exports.realpath = fs.realpath
exports.rename = fs.rename
exports.rm = fs.rm
exports.rmdir = fs.rmdir
exports.stat = fs.stat
exports.symlink = fs.symlink
exports.unlink = fs.unlink
exports.utimes = fs.utimes
exports.watch = fs.watch
exports.writeFile = fs.writeFile
const { satisfies } = require('bare-semver')
const errors = require('./lib/errors')

module.exports = exports = function resolve(
  specifier,
  parentURL,
  opts,
  readPackage
) {
  if (typeof opts === 'function') {
    readPackage = opts
    opts = {}
  } else if (typeof readPackage !== 'function') {
    readPackage = defaultReadPackage
  }

  return {
    *[Symbol.iterator]() {
      const generator = exports.module(specifier, parentURL, opts)

      let next = generator.next()

      while (next.done !== true) {
        const value = next.value

        if (value.package) {
          next = generator.next(readPackage(value.package))
        } else {
          next = generator.next(yield value.resolution)
        }
      }

      return next.value
    },

    async *[Symbol.asyncIterator]() {
      const generator = exports.module(specifier, parentURL, opts)

      let next = generator.next()

      while (next.done !== true) {
        const value = next.value

        if (value.package) {
          next = generator.next(await readPackage(value.package))
        } else {
          next = generator.next(yield value.resolution)
        }
      }

      return next.value
    }
  }
}

function defaultReadPackage() {
  return null
}

// No resolution candidate was yielded
const UNRESOLVED = 0x0
// At least 1 resolution candidate was yielded
const YIELDED = 0x1
// At least 1 resolution candidate was yielded and resolved
const RESOLVED = YIELDED | 0x2

exports.constants = {
  UNRESOLVED,
  YIELDED,
  RESOLVED
}

exports.module = function* (specifier, parentURL, opts = {}) {
  const { resolutions = null, imports = null } = opts

  if (exports.startsWithWindowsDriveLetter(specifier)) {
    specifier = '/' + specifier
  }

  let status

  if (resolutions) {
    status = yield* exports.preresolved(specifier, resolutions, parentURL, opts)

    if (status) return status
  }

  status = yield* exports.url(specifier, parentURL, opts)

  if (status) return status

  status = yield* exports.packageImports(specifier, parentURL, opts)

  if (status) return status

  if (
    specifier === '.' ||
    specifier === '..' ||
    specifier[0] === '/' ||
    specifier[0] === '\\' ||
    specifier.startsWith('./') ||
    specifier.startsWith('.\\') ||
    specifier.startsWith('../') ||
    specifier.startsWith('..\\')
  ) {
    if (imports) {
      status = yield* exports.packageImportsExports(
        specifier,
        imports,
        parentURL,
        true,
        opts
      )

      if (status) return status
    }

    status = yield* exports.deferred(specifier, opts)

    if (status) return status

    status = yield* exports.file(specifier, parentURL, false, opts)

    if (status === RESOLVED) return status

    return yield* exports.directory(specifier, parentURL, opts)
  }

  return yield* exports.package(specifier, parentURL, opts)
}

exports.url = function* (url, parentURL, opts = {}) {
  const { imports = null, deferredProtocol = 'deferred:' } = opts

  let resolution
  try {
    resolution = new URL(url)
  } catch {
    return UNRESOLVED
  }

  if (imports) {
    const status = yield* exports.packageImportsExports(
      resolution.href,
      imports,
      parentURL,
      true,
      opts
    )

    if (status) return status
  }

  if (resolution.protocol === deferredProtocol) {
    const specifier = resolution.pathname

    return yield* exports.module(specifier, parentURL, opts)
  }

  if (resolution.protocol === 'node:') {
    const specifier = resolution.pathname

    if (
      specifier === '.' ||
      specifier === '..' ||
      specifier[0] === '/' ||
      specifier.startsWith('./') ||
      specifier.startsWith('../')
    ) {
      throw errors.INVALID_MODULE_SPECIFIER(
        `Module specifier '${url}' is not a valid package name`
      )
    }

    return yield* exports.package(specifier, parentURL, opts)
  }

  const resolved = yield { resolution }

  return resolved ? RESOLVED : YIELDED
}

exports.preresolved = function* (specifier, resolutions, parentURL, opts = {}) {
  const imports = resolutions[parentURL.href]

  if (typeof imports === 'object' && imports !== null) {
    return yield* exports.packageImportsExports(
      specifier,
      imports,
      parentURL,
      true,
      opts
    )
  }

  return UNRESOLVED
}

exports.deferred = function* (specifier, opts = {}) {
  const { deferredProtocol = 'deferred:', defer = [] } = opts

  if (defer.includes(specifier)) {
    const resolved = yield { resolution: new URL(deferredProtocol + specifier) }

    return resolved ? RESOLVED : YIELDED
  }

  return UNRESOLVED
}

exports.package = function* (packageSpecifier, parentURL, opts = {}) {
  const { builtins = [] } = opts

  if (packageSpecifier === '') {
    throw errors.INVALID_MODULE_SPECIFIER(
      `Module specifier '${packageSpecifier}' is not a valid package name`
    )
  }

  let packageName

  if (packageSpecifier[0] !== '@') {
    packageName = packageSpecifier.split('/', 1).join()
  } else {
    if (!packageSpecifier.includes('/')) {
      throw errors.INVALID_MODULE_SPECIFIER(
        `Module specifier '${packageSpecifier}' is not a valid package name`
      )
    }

    packageName = packageSpecifier.split('/', 2).join('/')
  }

  if (
    packageName[0] === '.' ||
    packageName.includes('\\') ||
    packageName.includes('%')
  ) {
    throw errors.INVALID_MODULE_SPECIFIER(
      `Module specifier '${packageSpecifier}' is not a valid package name`
    )
  }

  let status

  status = yield* exports.builtinTarget(packageSpecifier, null, builtins, opts)

  if (status) return status

  status = yield* exports.deferred(packageSpecifier, opts)

  if (status) return status

  let packageSubpath = '.' + packageSpecifier.substring(packageName.length)

  status = yield* exports.packageSelf(
    packageName,
    packageSubpath,
    parentURL,
    opts
  )

  if (status) return status

  parentURL = new URL(parentURL.href)

  do {
    const packageURL = new URL('node_modules/' + packageName + '/', parentURL)

    parentURL.pathname = parentURL.pathname.substring(
      0,
      parentURL.pathname.lastIndexOf('/')
    )

    const info = yield { package: new URL('package.json', packageURL) }

    if (info) {
      if (info.engines) exports.validateEngines(packageURL, info.engines, opts)

      if (info.exports) {
        return yield* exports.packageExports(
          packageURL,
          packageSubpath,
          info.exports,
          opts
        )
      }

      if (packageSubpath === '.') {
        if (typeof info.main === 'string' && info.main !== '') {
          packageSubpath = info.main
        } else {
          return yield* exports.file('index', packageURL, true, opts)
        }
      }

      status = yield* exports.file(packageSubpath, packageURL, false, opts)

      if (status === RESOLVED) return status

      return yield* exports.directory(packageSubpath, packageURL, opts)
    }
  } while (parentURL.pathname !== '' && parentURL.pathname !== '/')

  return UNRESOLVED
}

exports.packageSelf = function* (
  packageName,
  packageSubpath,
  parentURL,
  opts = {}
) {
  for (const packageURL of exports.lookupPackageScope(parentURL, opts)) {
    const info = yield { package: packageURL }

    if (info) {
      if (info.name !== packageName) return false

      if (info.exports) {
        return yield* exports.packageExports(
          packageURL,
          packageSubpath,
          info.exports,
          opts
        )
      }

      if (packageSubpath === '.') {
        if (typeof info.main === 'string' && info.main !== '') {
          packageSubpath = info.main
        } else {
          return yield* exports.file('index', packageURL, true, opts)
        }
      }

      const status = yield* exports.file(
        packageSubpath,
        packageURL,
        false,
        opts
      )

      if (status === RESOLVED) return status

      return yield* exports.directory(packageSubpath, packageURL, opts)
    }
  }

  return UNRESOLVED
}

exports.packageExports = function* (
  packageURL,
  subpath,
  packageExports,
  opts = {}
) {
  if (subpath === '.') {
    let mainExport

    if (typeof packageExports === 'string' || Array.isArray(packageExports)) {
      mainExport = packageExports
    } else if (typeof packageExports === 'object' && packageExports !== null) {
      const keys = Object.keys(packageExports)

      if (keys.some((key) => key.startsWith('.'))) {
        if ('.' in packageExports) mainExport = packageExports['.']
      } else {
        mainExport = packageExports
      }
    }

    if (mainExport) {
      const status = yield* exports.packageTarget(
        packageURL,
        mainExport,
        null,
        false,
        opts
      )

      if (status) return status
    }
  } else if (typeof packageExports === 'object' && packageExports !== null) {
    const keys = Object.keys(packageExports)

    if (keys.every((key) => key.startsWith('.'))) {
      const status = yield* exports.packageImportsExports(
        subpath,
        packageExports,
        packageURL,
        false,
        opts
      )

      if (status) return status
    }
  }

  packageURL = new URL('package.json', packageURL)

  throw errors.PACKAGE_PATH_NOT_EXPORTED(
    `Package subpath '${subpath}' is not defined by "exports" in '${packageURL}'`
  )
}

exports.packageImports = function* (specifier, parentURL, opts = {}) {
  const { imports = null } = opts

  if (specifier === '#' || specifier.startsWith('#/')) {
    throw errors.INVALID_MODULE_SPECIFIER(
      `Module specifier '${specifier}' is not a valid internal imports specifier`
    )
  }

  for (const packageURL of exports.lookupPackageScope(parentURL, opts)) {
    const info = yield { package: packageURL }

    if (info) {
      if (info.imports) {
        const status = yield* exports.packageImportsExports(
          specifier,
          info.imports,
          packageURL,
          true,
          opts
        )

        if (status) return status
      }

      if (specifier.startsWith('#')) {
        throw errors.PACKAGE_IMPORT_NOT_DEFINED(
          `Package import specifier '${specifier}' is not defined by "imports" in '${packageURL}'`
        )
      }

      break
    }
  }

  if (imports) {
    const status = yield* exports.packageImportsExports(
      specifier,
      imports,
      parentURL,
      true,
      opts
    )

    if (status) return status
  }

  return UNRESOLVED
}

exports.packageImportsExports = function* (
  matchKey,
  matchObject,
  packageURL,
  isImports,
  opts = {}
) {
  if (matchKey in matchObject && !matchKey.includes('*')) {
    const target = matchObject[matchKey]

    return yield* exports.packageTarget(
      packageURL,
      target,
      null,
      isImports,
      opts
    )
  }

  const expansionKeys = Object.keys(matchObject)
    .filter((key) => key.includes('*'))
    .sort(exports.patternKeyCompare)

  for (const expansionKey of expansionKeys) {
    const patternIndex = expansionKey.indexOf('*')
    const patternBase = expansionKey.substring(0, patternIndex)

    if (matchKey.startsWith(patternBase) && matchKey !== patternBase) {
      const patternTrailer = expansionKey.substring(patternIndex + 1)

      if (
        patternTrailer === '' ||
        (matchKey.endsWith(patternTrailer) &&
          matchKey.length >= expansionKey.length)
      ) {
        const target = matchObject[expansionKey]

        const patternMatch = matchKey.substring(
          patternBase.length,
          matchKey.length - patternTrailer.length
        )

        return yield* exports.packageTarget(
          packageURL,
          target,
          patternMatch,
          isImports,
          opts
        )
      }
    }
  }

  return UNRESOLVED
}

exports.validateEngines = function validateEngines(
  packageURL,
  packageEngines,
  opts = {}
) {
  const { engines = {} } = opts

  for (const [engine, range] of Object.entries(packageEngines)) {
    if (engine in engines) {
      const version = engines[engine]

      if (!satisfies(version, range)) {
        packageURL = new URL('package.json', packageURL)

        throw errors.UNSUPPORTED_ENGINE(
          `Package not compatible with engine '${engine}' ${version}, requires range '${range}' defined by "engines" in '${packageURL}'`
        )
      }
    }
  }
}

exports.patternKeyCompare = function patternKeyCompare(keyA, keyB) {
  const patternIndexA = keyA.indexOf('*')
  const patternIndexB = keyB.indexOf('*')
  const baseLengthA = patternIndexA === -1 ? keyA.length : patternIndexA + 1
  const baseLengthB = patternIndexB === -1 ? keyB.length : patternIndexB + 1
  if (baseLengthA > baseLengthB) return -1
  if (baseLengthB > baseLengthA) return 1
  if (patternIndexA === -1) return 1
  if (patternIndexB === -1) return -1
  if (keyA.length > keyB.length) return -1
  if (keyB.length > keyA.length) return 1
  return 0
}

exports.packageTarget = function* (
  packageURL,
  target,
  patternMatch,
  isImports,
  opts = {}
) {
  const { conditions = [], matchedConditions = [] } = opts

  if (typeof target === 'string') {
    if (!target.startsWith('./') && !isImports) {
      packageURL = new URL('package.json', packageURL)

      throw errors.INVALID_PACKAGE_TARGET(
        `Invalid target '${target}' defined by "exports" in '${packageURL}'`
      )
    }

    if (patternMatch !== null) {
      target = target.replaceAll('*', patternMatch)
    }

    const status = yield* exports.url(target, packageURL, opts)

    if (status) return status

    if (
      target === '.' ||
      target === '..' ||
      target[0] === '/' ||
      target.startsWith('./') ||
      target.startsWith('../')
    ) {
      const resolved = yield { resolution: new URL(target, packageURL) }

      return resolved ? RESOLVED : YIELDED
    }

    return yield* exports.package(target, packageURL, opts)
  }

  if (Array.isArray(target)) {
    for (const targetValue of target) {
      const status = yield* exports.packageTarget(
        packageURL,
        targetValue,
        patternMatch,
        isImports,
        opts
      )

      if (status) return status
    }
  } else if (typeof target === 'object' && target !== null) {
    let status = UNRESOLVED

    for (const [condition, targetValue, subset] of exports.conditionMatches(
      target,
      conditions,
      opts
    )) {
      matchedConditions.push(condition)

      status |= yield* exports.packageTarget(
        packageURL,
        targetValue,
        patternMatch,
        isImports,
        { ...opts, conditions: subset }
      )

      matchedConditions.pop()
    }

    if (status) return status
  }

  return UNRESOLVED
}

exports.builtinTarget = function* (
  packageSpecifier,
  packageVersion,
  target,
  opts = {}
) {
  const {
    builtinProtocol = 'builtin:',
    conditions = [],
    matchedConditions = []
  } = opts

  if (typeof target === 'string') {
    const targetParts = target.split('@')

    let targetName
    let targetVersion

    if (target[0] !== '@') {
      targetName = targetParts[0]
      targetVersion = targetParts[1] || null
    } else {
      targetName = targetParts.slice(0, 2).join('@')
      targetVersion = targetParts[2] || null
    }

    if (packageSpecifier === targetName) {
      if (packageVersion === null && targetVersion === null) {
        const resolved = yield {
          resolution: new URL(builtinProtocol + packageSpecifier)
        }

        return resolved ? RESOLVED : YIELDED
      }

      let version = null

      if (packageVersion === null) {
        version = targetVersion
      } else if (targetVersion === null || packageVersion === targetVersion) {
        version = packageVersion
      }

      if (version !== null) {
        const resolved = yield {
          resolution: new URL(
            builtinProtocol + packageSpecifier + '@' + version
          )
        }

        return resolved ? RESOLVED : YIELDED
      }
    }
  } else if (Array.isArray(target)) {
    for (const targetValue of target) {
      const status = yield* exports.builtinTarget(
        packageSpecifier,
        packageVersion,
        targetValue,
        opts
      )

      if (status) return status
    }
  } else if (typeof target === 'object' && target !== null) {
    let status = UNRESOLVED

    for (const [condition, targetValue, subset] of exports.conditionMatches(
      target,
      conditions,
      opts
    )) {
      matchedConditions.push(condition)

      status |= yield* exports.builtinTarget(
        packageSpecifier,
        packageVersion,
        targetValue,
        { ...opts, conditions: subset }
      )

      matchedConditions.pop()
    }

    if (status) return status
  }

  return UNRESOLVED
}

exports.conditionMatches = function* conditionMatches(
  target,
  conditions,
  opts = {}
) {
  if (conditions.every((condition) => typeof condition === 'string')) {
    const keys = Object.keys(target)

    for (const condition of keys) {
      if (condition === 'default' || conditions.includes(condition)) {
        yield [condition, target[condition], conditions]

        return true
      }
    }

    return false
  }

  let yielded = false

  for (const subset of conditions) {
    if (yield* conditionMatches(target, subset, opts)) {
      yielded = true
    }
  }

  return yielded
}

exports.lookupPackageScope = function* lookupPackageScope(url, opts = {}) {
  const { resolutions = null } = opts

  if (resolutions) {
    for (const { resolution } of exports.preresolved(
      '#package',
      resolutions,
      url,
      opts
    )) {
      if (resolution) return yield resolution
    }

    // Internal preresolution path, do not depend on this! It will be removed without
    // warning.
    for (const { resolution } of exports.preresolved(
      'bare:package',
      resolutions,
      url,
      opts
    )) {
      if (resolution) return yield resolution
    }
  }

  const scopeURL = new URL(url.href)

  do {
    if (scopeURL.pathname.endsWith('/node_modules')) break

    yield new URL('package.json', scopeURL)

    scopeURL.pathname = scopeURL.pathname.substring(
      0,
      scopeURL.pathname.lastIndexOf('/')
    )

    if (
      scopeURL.pathname.length === 3 &&
      exports.isWindowsDriveLetter(scopeURL.pathname.substring(1))
    ) {
      break
    }
  } while (scopeURL.pathname !== '' && scopeURL.pathname !== '/')
}

exports.file = function* (filename, parentURL, isIndex, opts = {}) {
  if (
    filename === '.' ||
    filename === '..' ||
    filename[filename.length - 1] === '/' ||
    filename[filename.length - 1] === '\\'
  ) {
    return UNRESOLVED
  }

  if (parentURL.protocol === 'file:' && /%2f|%5c/i.test(filename)) {
    throw errors.INVALID_MODULE_SPECIFIER(
      `Module specifier '${filename}' is invalid`
    )
  }

  const { extensions = [] } = opts

  let status = UNRESOLVED

  if (!isIndex) {
    if (yield { resolution: new URL(filename, parentURL) }) {
      return RESOLVED
    }

    status = YIELDED
  }

  for (const ext of extensions) {
    if (yield { resolution: new URL(filename + ext, parentURL) }) {
      return RESOLVED
    }

    status = YIELDED
  }

  return status
}

exports.directory = function* (dirname, parentURL, opts = {}) {
  let directoryURL

  if (
    dirname[dirname.length - 1] === '/' ||
    dirname[dirname.length - 1] === '\\'
  ) {
    directoryURL = new URL(dirname, parentURL)
  } else {
    directoryURL = new URL(dirname + '/', parentURL)
  }

  const info = yield { package: new URL('package.json', directoryURL) }

  if (info) {
    if (info.exports) {
      return yield* exports.packageExports(
        directoryURL,
        '.',
        info.exports,
        opts
      )
    }

    if (typeof info.main === 'string' && info.main !== '') {
      const status = yield* exports.file(info.main, directoryURL, false, opts)

      if (status === RESOLVED) return status

      return yield* exports.directory(info.main, directoryURL, opts)
    }
  }

  return yield* exports.file('index', directoryURL, true, opts)
}

// https://infra.spec.whatwg.org/#ascii-upper-alpha
function isASCIIUpperAlpha(c) {
  return c >= 0x41 && c <= 0x5a
}

// https://infra.spec.whatwg.org/#ascii-lower-alpha
function isASCIILowerAlpha(c) {
  return c >= 0x61 && c <= 0x7a
}

// https://infra.spec.whatwg.org/#ascii-alpha
function isASCIIAlpha(c) {
  return isASCIIUpperAlpha(c) || isASCIILowerAlpha(c)
}

// https://url.spec.whatwg.org/#windows-drive-letter
exports.isWindowsDriveLetter = function isWindowsDriveLetter(input) {
  return (
    input.length >= 2 &&
    isASCIIAlpha(input.charCodeAt(0)) &&
    (input.charCodeAt(1) === 0x3a || input.charCodeAt(1) === 0x7c)
  )
}

// https://url.spec.whatwg.org/#start-with-a-windows-drive-letter
exports.startsWithWindowsDriveLetter = function startsWithWindowsDriveLetter(
  input
) {
  return (
    input.length >= 2 &&
    exports.isWindowsDriveLetter(input) &&
    (input.length === 2 ||
      input.charCodeAt(2) === 0x2f ||
      input.charCodeAt(2) === 0x5c ||
      input.charCodeAt(2) === 0x3f ||
      input.charCodeAt(2) === 0x23)
  )
}
module.exports = class ModuleResolveError extends Error {
  constructor(msg, code, fn = ModuleResolveError) {
    super(`${code}: ${msg}`)
    this.code = code

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, fn)
    }
  }

  get name() {
    return 'ModuleResolveError'
  }

  static INVALID_MODULE_SPECIFIER(msg) {
    return new ModuleResolveError(
      msg,
      'INVALID_MODULE_SPECIFIER',
      ModuleResolveError.INVALID_MODULE_SPECIFIER
    )
  }

  static INVALID_PACKAGE_TARGET(msg) {
    return new ModuleResolveError(
      msg,
      'INVALID_PACKAGE_TARGET',
      ModuleResolveError.INVALID_PACKAGE_TARGET
    )
  }

  static PACKAGE_PATH_NOT_EXPORTED(msg) {
    return new ModuleResolveError(
      msg,
      'PACKAGE_PATH_NOT_EXPORTED',
      ModuleResolveError.PACKAGE_PATH_NOT_EXPORTED
    )
  }

  static PACKAGE_IMPORT_NOT_DEFINED(msg) {
    return new ModuleResolveError(
      msg,
      'PACKAGE_IMPORT_NOT_DEFINED',
      ModuleResolveError.PACKAGE_IMPORT_NOT_DEFINED
    )
  }

  static UNSUPPORTED_ENGINE(msg) {
    return new ModuleResolveError(
      msg,
      'UNSUPPORTED_ENGINE',
      ModuleResolveError.UNSUPPORTED_ENGINE
    )
  }
}
{
  "name": "bare-module-resolve",
  "version": "1.11.1",
  "description": "Low-level module resolution algorithm for Bare",
  "exports": {
    "./package": "./package.json",
    ".": {
      "types": "./index.d.ts",
      "default": "./index.js"
    },
    "./errors": {
      "types": "./lib/errors.d.ts",
      "default": "./lib/errors.js"
    }
  },
  "files": [
    "index.js",
    "index.d.ts",
    "lib"
  ],
  "scripts": {
    "test": "prettier . --check && bare test.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/holepunchto/bare-module-resolve.git"
  },
  "author": "Holepunch",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/holepunchto/bare-module-resolve/issues"
  },
  "homepage": "https://github.com/holepunchto/bare-module-resolve#readme",
  "dependencies": {
    "bare-semver": "^1.0.0"
  },
  "devDependencies": {
    "bare-url": "^2.1.3",
    "brittle": "^3.2.1",
    "prettier": "^3.3.3",
    "prettier-config-standard": "^7.0.0"
  },
  "peerDependencies": {
    "bare-url": "*"
  },
  "peerDependenciesMeta": {
    "bare-url": {
      "optional": true
    }
  }
}
module.exports = require.addon()
const binding = require('./binding')
const errors = require('./lib/errors')
const constants = require('./lib/constants')

exports.constants = constants

exports.EOL = binding.platform === 'win32' ? '\r\n' : '\n'

exports.platform = function platform() {
  return binding.platform
}

exports.arch = function arch() {
  return binding.arch
}

exports.type = binding.type
exports.version = binding.version
exports.release = binding.release
exports.machine = binding.machine
exports.execPath = binding.execPath
exports.pid = binding.pid
exports.ppid = binding.ppid
exports.cwd = binding.cwd
exports.chdir = binding.chdir
exports.tmpdir = binding.tmpdir
exports.homedir = binding.homedir
exports.hostname = binding.hostname
exports.userInfo = binding.userInfo

exports.kill = function kill(pid, signal = constants.signals.SIGTERM) {
  if (typeof signal === 'string') {
    if (signal in constants.signals === false) {
      throw errors.UNKNOWN_SIGNAL('Unknown signal: ' + signal)
    }

    signal = constants.signals[signal]
  }

  binding.kill(pid, signal)
}

exports.endianness = function endianness() {
  return binding.isLittleEndian ? 'LE' : 'BE'
}

exports.availableParallelism = binding.availableParallelism

exports.cpuUsage = function cpuUsage(previous) {
  const current = binding.cpuUsage()

  if (previous) {
    return {
      user: current.user - previous.user,
      system: current.system - previous.system
    }
  }

  return current
}

exports.threadCpuUsage = function threadCpuUsage(previous) {
  const current = binding.threadCpuUsage()

  if (previous) {
    return {
      user: current.user - previous.user,
      system: current.system - previous.system
    }
  }

  return current
}

exports.resourceUsage = binding.resourceUsage
exports.memoryUsage = binding.memoryUsage
exports.freemem = binding.freemem
exports.totalmem = binding.totalmem
exports.uptime = binding.uptime
exports.loadavg = binding.loadavg
exports.cpus = binding.cpus

exports.getProcessTitle = binding.getProcessTitle

exports.setProcessTitle = function setProcessTitle(title) {
  if (typeof title !== 'string') title = title.toString()

  if (title.length >= 256) {
    throw errors.TITLE_OVERFLOW('Process title is too long')
  }

  binding.setProcessTitle(title)
}

exports.getEnvKeys = binding.getEnvKeys
exports.getEnv = binding.getEnv
exports.hasEnv = binding.hasEnv
exports.setEnv = binding.setEnv
exports.unsetEnv = binding.unsetEnv
const binding = require('../binding')

module.exports = {
  signals: binding.signals,
  errnos: binding.errnos
}
module.exports = class OSError extends Error {
  constructor(msg, code, fn = OSError) {
    super(`${code}: ${msg}`)
    this.code = code

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, fn)
    }
  }

  get name() {
    return 'OSError'
  }

  static UNKNOWN_SIGNAL(msg) {
    return new OSError(msg, 'UNKNOWN_SIGNAL', OSError.UNKNOWN_SIGNAL)
  }

  static TITLE_OVERFLOW(msg) {
    return new OSError(msg, 'TITLE_OVERFLOW', OSError.TITLE_OVERFLOW)
  }
}
{
  "name": "bare-os",
  "version": "3.6.2",
  "description": "Operating system utilities for Javascript",
  "exports": {
    ".": {
      "types": "./index.d.ts",
      "default": "./index.js"
    },
    "./package": "./package.json",
    "./constants": "./lib/constants.js",
    "./errors": "./lib/errors.js"
  },
  "files": [
    "index.js",
    "index.d.ts",
    "binding.c",
    "binding.js",
    "CMakeLists.txt",
    "lib",
    "prebuilds"
  ],
  "addon": true,
  "scripts": {
    "test": "prettier . --check && bare test.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/holepunchto/bare-os.git"
  },
  "author": "Holepunch",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/holepunchto/bare-os/issues"
  },
  "homepage": "https://github.com/holepunchto/bare-os#readme",
  "engines": {
    "bare": ">=1.14.0"
  },
  "devDependencies": {
    "brittle": "^3.1.1",
    "cmake-bare": "^1.1.6",
    "prettier": "^3.4.2",
    "prettier-config-standard": "^7.0.0"
  }
}
ELF          >            @       @r          @ 8 
 @         @       @       @       0      0                                           D#      D#                   P#      P3      P3      p6      p6                   Y      y      y                               [                        `                   Y      y      y                         Rtd   Y      y      y            @             Ptd                                        Qtd                                                         p      p      p                                    GNU 6w(                                                                      ,                       F   "                                                                                                                                                                                                                                             (                     4                     @                     O                     Z                     g                     u                     |                                                                                                                                                                                                                  %                     2                     F                     ]                     t                                                                                                                                                                                                                  #                     9                     J                     _                     t                                                                                                                                                                                                                                       	                                          +                     <                     C                     O                     U     4             m      4                                                                                       a         ui	   k             C               C   &rMa __gmon_start__ _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize bare_get_module_name_v0 bare_register_module_v0 uv_once js_create_string_utf8 js_set_named_property js_create_function js_get_boolean js_create_object js_create_uint32 js_create_int32 uv_rwlock_init uv_os_uname uv_err_name uv_strerror js_throw_error uv_exepath uv_os_getpid uv_os_getppid uv_cwd js_get_callback_info js_get_value_string_utf8 uv_chdir uv_os_tmpdir uv_os_homedir uv_os_gethostname js_get_value_uint32 uv_kill uv_available_parallelism js_create_int64 uv_getrusage uv_getrusage_thread js_get_heap_statistics uv_resident_set_memory uv_get_free_memory uv_get_total_memory uv_uptime js_create_double js_create_arraybuffer js_create_typedarray uv_loadavg uv_cpu_info js_create_array_with_length js_set_element js_get_named_property uv_free_cpu_info uv_get_process_title uv_set_process_title uv_rwlock_rdlock uv_os_environ uv_rwlock_rdunlock uv_os_free_environ malloc uv_os_getenv js_get_undefined realloc free uv_rwlock_wrlock uv_os_setenv uv_rwlock_wrunlock uv_os_unsetenv uv_os_get_passwd strlen js_get_null uv_os_free_passwd libc.so.6 GLIBC_2.2.5 bare-os@3.bare       y             3      y              4                         `{                    h{                    p{                    x{                                                                                                                                 	                    
                                                                                                                                                                                                                     (                    0                    8                    @                    H                    P                    X                    `                    h                    p                    x                                                  !                    "                    #                    $                    %                    &                    '                    (                    )                    *                    +                    ,                    -                    .                    /                     0                    1                    2                    3                     4           (         5           0         6           8         7           @         8           H         9           P         :           X         ;           `         <           h         =           p         >           x         ?                    @                    A                    B               .ASIGPOLL ENAMETOOLONG fsRead EACCES ENOTSUP EPIPE maxRSS ipcReceived ppid SIGBUS SIGVTALRM SIGWINCH SIGSYS EADDRNOTAVAIL EAI_CANCELED EBUSY ENOTTY shell SIGTTIN ELOOP EXDEV ENODATA nice kill getProcessTitle SIGURG SIGPWR ECHARSET irq SIGKILL EOF voluntaryContextSwitches involuntaryContextSwitches heapTotal platform arch getEnv unsetEnv SIGTTOU ECONNABORTED EISDIR ENOSPC EPROTOTYPE EAI_SERVICE ENETDOWN ESHUTDOWN unsharedStackSize ipcSent memoryUsage setProcessTitle SIGTRAP SIGPROF E2BIG EAI_FAMILY EISCONN username SIGHUP EAI_BADFLAGS EAI_OVERFLOW EBADF ECONNRESET EIO ENXIO majorPageFault release hostname SIGPIPE EADDRINUSE EAI_ADDRFAMILY ENETUNREACH ENOPROTOOPT EPROTONOSUPPORT UNKNOWN sharedMemorySize times bare-os@3.6.2 version totalmem SIGUSR2 SIGXFSZ EAI_BADHINTS EAI_SOCKTYPE userInfo speed gid cpuUsage SIGABRT EAI_AGAIN EAI_NODATA EEXIST EROFS EHOSTDOWN EREMOTEIO freemem SIGUSR1 SIGTSTP EMSGSIZE ENFILE ETIMEDOUT chdir EAGAIN EAI_NONAME EAI_PROTOCOL EFBIG EMFILE ENOMEM ENOTSOCK ENOTCONN EFTYPE EAI_FAIL EALREADY unsharedDataSize fsWrite SIGINT SIGILL SIGTERM machine availableParallelism getEnvKeys isLittleEndian SIGQUIT userCPUTime swappedOut linux uptime SIGSEGV SIGXCPU ECONNREFUSED ENOBUFS user system errnos EAFNOSUPPORT ENOTDIR EUNATCH resourceUsage SIGFPE ECANCELED EOVERFLOW ERANGE ESRCH ETXTBSY ESOCKTNOSUPPORT heapUsed x64 cwd EAI_MEMORY EFAULT EINVAL EPERM EILSEQ external sys execPath tmpdir threadCpuUsage signals SIGALRM EHOSTUNREACH EINTR ENOSYS idle SIGSTOP ENONET uid pid homedir cpus SIGSTKFLT ENOENT ESPIPE signalsCount type setEnv SIGIOT EDESTADDRREQ systemCPUTime minorPageFault rss hasEnv SIGCHLD SIGCONT ENOTEMPTY ENOEXEC model loadavg SIGIO ENODEV EPROTO EMLINK         ;  "   P  8  `  P  p  h  p4    4    4    `5  0  5  h  @6    6    6     7    7  P  08    8    09    9  0  0:  `  `:     ;    ;    >    ?     @  8  P@  X  @  x  @    `C    C     0D  P  E    pF    G    `H  H             zR x                        4                <   L         BBB A(DP(A BBB             2             4      2  k    ABA G[ ABA       4      2  n    ABA G^ ABA       4     (3  n    ABA G^ ABA       4   L  `3  n    ABA G^ ABA       4     3  s    ABA G c ABA            3  '    AD `A      3  '    AD `A 4      4  s    ABA G c ABA       4   4  H4      ABA G q ABA       4   l  4  s    ABA G c ABA       4     4  s    ABA G c ABA       4     05  m    ABA D` ABA       ,     h5      ABA D@z ABA   D  5  '    AD `A $   d  5      AGA       $     p6      AGA       $     7     AGA           9     ADPA     :  (    AD aA      :  (    AD aA    <  :  -    AD fA    \   ;  P    AD0IAL   |  0;     ABB B(B0A8Dt8A0B(B BBA      4     p=  p    ABA G` ABA       ,     =  Z    BAGLAB       4   4  =      BBB A(DP(A BBB<   l  >  W   ABB A(DP(A BBAAP    D     ?     ABB B(A0D`
0A(B BBA       4     x@      ABB A(D@(A BBA4   ,  A  r   ABA De ABA                      H=1X  H*X  H9tHG  Ht	        H=X  H5W  H)HH?HHHtHG  HtfD      =Y   u+UH=G   HtH=W  1  dY  ]     wH     f.     @ AWAVATSH(IHH=XY  H5  1  H5&HL$HH1  HL$HHLz1  H5HL$HHO1  HL$HHLH1  L=MHz  LL$HLHE101  HL$HLL1  L=H  LL$HLHE10  HL$HLL0  L=H  LL$HLHE10  HL$HLL0  L=H  LL$HLHE10  HL$HLL\0  L=HN  LL$HLHE1D0  HL$HLL!0  L=H  LL$HLHE1	0  HL$HLL/  L=H  LL$HLHE1/  HL$HLL/  L=H}  LL$HLHE1/  HL$HLLp/  L=H  LL$HLHE1X/  HL$HLL5/  L=H  LL$HLHE1/  HL$HLL.  L=H\  LL$HLHE1.  HL$HLL.  L=	H  LL$HLHE1.  HL$HLL.  L=.H  LL$HLHE1l.  HL$HLLI.  L=uH+  LL$HLHE11.  HL$HLL.  L=&H   LL$HLHE1-  HL$HLL-  L=QH  LL$HLHE1-  HL$HLL-  L=tH*  LL$HLHE1-  HL$HLL]-  L=H!  LL$HLHE1E-  HL$HLL"-  L=H"  LL$HLHE1
-  HL$HLL,  L=H"  LL$HLHE1,  HL$HLL,  L=,H"  LL$HLHE1,  HL$HLLq,  L=H"  LL$HLHE1Y,  HL$HLL6,  L=H"  LL$HLHE1,  HL$HLL+  L=H%  LL$HLHE1+  HL$HLL+  L=uHB%  LL$HLHE1+  HL$HLL+  L=Hg%  LL$HLHE1m+  HL$HLLJ+  L=|L%&  LL$HLHLE1/+  HL$HLL+  L=RLL$HLHLE1*  HL$HLL*  L=H&  LL$HLHE1*  HL$HLL*  L=H'  LL$HLHE1*  HL$HLL_*  L=dHq(  LL$HLHE1G*  HL$HLL$*  HT$H   2*  HL$HYHL)  Ht$ H*  HL$ HvHL)  HT$H   *  Ht$ HL$HH)  HT$H   )  Ht$ HL$HH)  HT$H   )  Ht$ HL$HHV)  HT$H   )  Ht$ HL$HOH+)  HT$H   Y)  Ht$ HL$HH )  HT$H   .)  Ht$ HL$HH(  HT$H   )  Ht$ HL$HH(  HT$H   (  Ht$ HL$HH(  HT$H   (  Ht$ HL$HMHT(  HT$H	   (  Ht$ HL$HH)(  HT$H
   W(  Ht$ HL$HtH'  HT$H   ,(  Ht$ HL$HiH'  HT$H   (  Ht$ HL$HH'  HT$H   '  Ht$ HL$HH}'  HT$H   '  Ht$ HL$HHR'  HT$H   '  Ht$ HL$HRH''  HT$H   U'  Ht$ HL$HXH&  HT$H   *'  Ht$ HL$HH&  HT$H   &  Ht$ HL$H
H&  HT$H   &  Ht$ HL$HFH{&  HT$H   &  Ht$ HL$HHP&  HT$H   ~&  Ht$ HL$HH%&  HT$H   S&  Ht$ HL$HKH%  HT$H   (&  Ht$ HL$HH%  HT$H   %  Ht$ HL$HBH%  HT$H   %  Ht$ HL$HkHy%  HT$H   %  Ht$ HL$HHN%  HT$H   |%  Ht$ HL$HH#%  HT$H   Q%  Ht$ HL$HRH$  HT$H   &%  Ht$ HL$HYH$  HT$H   $  Ht$ HL$HH$  HT$H   $  Ht$ HL$HLHw$  HT$H   $  Ht$ HL$HHL$  Ht$Ho$  HL$HHL($  HT$Hf$  Ht$HL$HH#  HT$H;$  Ht$HL$HH#  HT$H$  Ht$HL$HH#  HT$H#  Ht$HL$HH|#  HT$H#  Ht$HL$HHQ#  HT$H#  Ht$HL$HH&#  HT$HHd#  Ht$HL$HpH"  HT$HG9#  Ht$HL$HH"  HT$HF#  Ht$HL$HH"  HT$H;"  Ht$HL$HtHz"  HT$HE"  Ht$HL$HHO"  HT$HD"  Ht$HL$HH$"  HT$HCb"  Ht$HL$HH!  HT$HB7"  Ht$HL$HH!  HT$HA"  Ht$HL$HH!  HT$H@!  Ht$HL$H%Hx!  HT$H?!  Ht$HL$HgHM!  HT$H:!  Ht$HL$HH"!  HT$H>`!  Ht$HL$HvH   HT$H=5!  Ht$HL$HH   HT$H
!  Ht$HL$HH   HT$H   Ht$HL$HHv   HT$H   Ht$HL$HHK   HT$H   Ht$HL$H H    HT$H^   Ht$HL$HH  HT$H3   Ht$HL$H#H  HT$H   Ht$HL$HEH  HT$H  Ht$HL$HHt  HT$H  Ht$HL$HpHI  HT$H  Ht$HL$HkH  HT$H\  Ht$HL$HHH  HT$H1  Ht$HL$HH  HT$H  Ht$HL$HIH  HT$H  Ht$HL$H+Hr  HT$H  Ht$HL$HHG  HT$H  Ht$HL$HTH  HT$HZ  Ht$HL$HH  HT$H/  Ht$HL$H,H  HT$H  Ht$HL$H;H  HT$H  Ht$HL$H;Hp  HT$H  Ht$HL$HHE  HT$H  Ht$HL$H"H  HT$HX  Ht$HL$HzH  HT$H-  Ht$HL$HHH  HT$H  Ht$HL$H(H  HT$H  Ht$HL$H!Hn  HT$H  Ht$HL$HHC  HT$H  Ht$HL$HH  HT$HV  Ht$HL$HH  HT$H+  Ht$HL$HH  HT$H   Ht$HL$H'H  HT$H  Ht$HL$HHl  HT$H  Ht$HL$H HA  HT$H  Ht$HL$HH  HT$HT  Ht$HL$HH  HT$H)  Ht$HL$H,H  HT$H  Ht$HL$HnH  HT$H  Ht$HL$HHj  HT$H  Ht$HL$HIH?  HT$H}  Ht$HL$HwH  HT$HR  Ht$HL$HH  HT$H'  Ht$HL$HWH  HT$H  Ht$HL$H/H  HT$H  Ht$HL$HHh  HT$H  Ht$HL$HQH=  HT$H{  Ht$HL$HfH  HT$HP  Ht$HL$H{H  HT$H%  Ht$HL$HH  HT$H  Ht$HL$HH  HT$H  Ht$HL$HHf  HT$H  Ht$HL$H\H;  HT$Hy  Ht$HL$HH  HT$HN  Ht$HL$HH  HT$H#  Ht$HL$HH  HT$H  Ht$HL$HH  HT$H  Ht$HL$HHd  HT$H  Ht$HL$HH9  HT$Hw  Ht$HL$HrH  HT$HL  Ht$HL$HnH  HT$HD!  Ht$HL$HH  HT$H  Ht$HL$HH  HT$H  Ht$HL$HHb  HT$H  Ht$HL$HH7  HT$Hu  Ht$HL$HH  HT$HJ  Ht$HL$HWH  LH([A\A^A_fH=q=  $  @ UAVSH  HH|$  x Ht$HL$HH{  HD$#  I  HLH  1H  [A^]D  UAVSH  HH|$  x#H$  HL$HH  HD$#  I  HLH  1H  [A^]fUAVSH  HH|$8  x#H$  HL$HH  HD$#  I  HLH   1H  [A^]fUAVSH  HH|$  x#H$  HL$HH(  HD$#  I  HLH  1H  [A^]fUAVSH  HH$   H|$H  xH$Ht$HL$H  HD$#3  I9  HLH;  1H  [A^]f.      SHH3  HT$H  HD$H[f     SHH  HT$Ht  HD$H[f     UAVSH  HH$   H|$H  xH$Ht$HL$H  HD$#S  IY  HLH[  1H  [A^]f.      UAVSH  HHD$   HT$HE1E1f  H4$Hl$   HHE1Z  Hb  y!  I  HLH  1H  [A^]f.     D  UAVSH  HH$   H|$H  xH$Ht$HL$H  HD$#C  II  HLHK  1H  [A^]f.      UAVSH  HH$   H|$H  xH$Ht$HL$HC  HD$#  I  HLH  1H  [A^]f.      UAVSH`HH$A   H|$H0  xH$Ht$HL$H  HD$#F  IL  HLHN  1H`[A^] UAVSH HHD$   HT$HL$E1E1g  Ht$HT$H  Ht$HH  |$4$  y!  I  HLH  1H [A^]f     SHHs  HT$Ht  HD$H[f     SH   HH|$[  Ht$H  H*D$H*L$YXH,HH  Ht$H$H7H|  WH*D$ WH*L$(YPXH,HH  Ht$H$HH4  HD$H   [fD  SH   HH|$  Ht$H.  H*D$H*L$YXH,HHT  Ht$H$HwH  WH*D$ WH*L$(YXH,HH  Ht$H$H4Ht  HD$H   [fD  SH   HH|$  Ht$Hn  H*D$H*L$YXH,HH  Ht$H$HnH  WH*D$ WH*L$(YXH,HHL  Ht$H$HH  Ht$0HH$  Ht$H$HH  Ht$8HH  Ht$H$HHd  Ht$@HH  Ht$H$H@H<  Ht$HHH  Ht$H$HH  Ht$PHH  Ht$H$H.H  Ht$XHH\  Ht$H$HH  Ht$`HH4  Ht$H$HH  Ht$hHH  Ht$H$HHt  Ht$pHH  Ht$H$HaHL  Ht$xHH  Ht$H$HH$  H$   HH  Ht$H$H1H  H$   HHf  Ht$H$HH  H$   HH;  Ht$H$HH  H$   HH  Ht$H$HHx  HD$H   [f.     SH@H)D$0)D$ Ht$   Ht$HY  H|$  Ht$HT$H  Ht$HL$HEH
  Ht$(Ht#HH^  Ht$H$HH
  Ht$0Ht#HH0  Ht$H$HH
  Ht$8Ht#HH  Ht$H$HHj
  HD$H@[f.     D  SHH  HT$HH  HD$H[     SHH  HT$HH  HD$H[     SHHH|$  D$HH  H$H[ SH HHT$HL$     HL$LL$   H   E1  H|$  HD$H [UAWAVAUATSHhHH|$0Ht$     Hct$HT$(H  D$H&  A0   E1HD$8f.     HD$0N| Nl JL HL$HJL HL$PJL HL$XJ HL$`B*D D$@HHt$   Ht$(HL$ HD  HLHL|$L  Ht$ HL$HHx  HD$@Lg
  Ht$ HL$HHhN  HLs  Ht$ HL$HH-H'  Ht$ HHL
  HLHl$H	  Ht$HL$HH  HHt$HHX	  Ht$HL$HHp  HHt$PH/	  Ht$HL$HH  HHt$XH	  Ht$HL$HH0m  HHt$`H  Ht$HL$HH&D  HD$8II8L9t$'  I  HLH  11H|$0w	  HD$(Hh[A\A]A^A_] UAVSH  HH|$   S	  x Ht$HL$HH  HD$#  I  HLH  1H  [A^]AVSH  HHD$   HT$HE1E17  H4$Lt$   HLE1+  L  1H  [A^fD  AWAVATSH(IL5-  L  H|$Ht$  L  xxHct$HT$L  t$~ME1Lt$ 1fHD$J4 LHL  Ht$HL$ L  HHct$IH9|H|$E  HD$!  I  LLH  1H([A\A^A_UAWAVSH(IHD$    HT$ HL$E1E1  Ht$H\$L11I  Hl$HHl$H  IHt$LHHI  H=^,  a  H$        HHLH  tu.Ht$L  7H4$H  HHLHV  x@H$HL$LH,  H=+     LX  HP  HD$H([A^A_]H=+    }  H  LHH  L  1f     UAWAVATSH0IHD$(   HT$(HL$E1E1  Ht$H\$L11I  Hl$HHl$Hd  IHt$LHHI[  Ht$IL11MD  H,$HH,$H   HHt$LHHM  L%*  LH  LHM  LS  yh  In  LLHp  L  H  1H0[A\A^A_]UAWAVSHIHD$   HT$HL$E1E1u  Ht$IL11Mn  H,$HH,$HJ  HHt$LHHMA  L=)  Lr  H  L  y  I  LLH  H%  1H[A^A_]     UAVSH`IH|$8K  t(>  HD  LHHF  1(  Ht$L  t$@HT$0L  Ht$HL$0HBLh  t$HHT$(L  Ht$HL$(HaL>  H\$8H  HL$ LHH  Ht$HL$ HL  H\$XH  HL$LHH   Ht$HL$HL   Ht$PHtHL$LH   Ht$L?  Ht$HL$HL   H|$8,  HD$H`[A^]  HH  HtH HH   5%  %%  @ %%  h    %%  h   %%  h   %%  h   %%  h   %%  h   %%  h   %%  h   p%%  h   `%%  h	   P%z%  h
   @%r%  h   0%j%  h    %b%  h   %Z%  h    %R%  h   %J%  h   %B%  h   %:%  h   %2%  h   %*%  h   %"%  h   %%  h   %%  h   p%
%  h   `%%  h   P%$  h   @%$  h   0%$  h    %$  h   %$  h    %$  h   %$  h    %$  h!   %$  h"   %$  h#   %$  h$   %$  h%   %$  h&   %$  h'   p%$  h(   `%$  h)   P%z$  h*   @%r$  h+   0%j$  h,    %b$  h-   %Z$  h.    %R$  h/   %J$  h0   %B$  h1   %:$  h2   %2$  h3   %*$  h4   %"$  h5   %$  h6   %$  h7   p%
$  h8   `%$  h9   P%#  h:   @%#  h;   0%#  h<    %#  h=   %#  h>                           a             w             `                    	              o                                                                                                  	      
             o    	             y                           y                           e             e      o     	      o    	      o                                                                   y                      e      e      e      f      f      &f      6f      Ff      Vf      ff      vf      f      f      f      f      f      f      f      f      g      g      &g      6g      Fg      Vg      fg      vg      g      g      g      g      g      g      g      g      h      h      &h      6h      Fh      Vh      fh      vh      h      h      h      h      h      h      h      h      i      i      &i      6i      Fi      Vi      fi      vi      i      i      i      i      Ubuntu clang version 14.0.0-1ubuntu1.1 GCC: (Ubuntu 12.3.0-1ubuntu1~22.04) 12.3.0  Linker: Ubuntu LLD 14.0.0                                                                        P3              .     3              A     3              W                  c     y                    4                   y                                                        04                                   0P                  @P      k           P      n            Q      n       -    Q      n       =     R      s       O    R      '       [    R      '       h    R      s       t    `S                 S      s           pT      s           T      m           `U                 U      '            V                 V                 W                Z            4    [      (       D    [      (       U    \      -       d    @\      P       t    \                 _      p           _      Z           _                 `      W          0b                Pc                  d      r                8                          *                  i                 G   e              c   e              M                      y              8                      u                                              "                       4                  4                                                                            +                     >                     M                     ^                     o                                                                                                                                                                                                                                                                                 %                     2                     @                     R                     f                     n                                                                                                                                                                                                                  (                     >                     S                     ^                     j                                                                                                                                                                                                                  +                     2                     ?                     P                     X                     ]                     n                     {                                                                                                                               .note.gnu.build-id .dynsym .gnu.version .gnu.version_r .gnu.hash .dynstr .rela.dyn .rela.plt .rodata .eh_frame_hdr .eh_frame .text .init .fini .plt .fini_array .init_array .dynamic .got .data .tm_clone_table .got.plt .bss .comment .symtab .shstrtab .strtab  crtstuff.c __TMC_LIST__ deregister_tm_clones register_tm_clones __do_global_dtors_aux completed.0 __do_global_dtors_aux_fini_array_entry frame_dummy __frame_dummy_init_array_entry binding.c bare_os_exports bare_os_env_lock_guard bare_os__on_env_lock_init bare_os_type bare_os_version bare_os_release bare_os_machine bare_os_exec_path bare_os_pid bare_os_ppid bare_os_cwd bare_os_chdir bare_os_tmpdir bare_os_homedir bare_os_hostname bare_os_kill bare_os_available_parallelism bare_os_cpu_usage bare_os_cpu_usage_thread bare_os_resource_usage bare_os_memory_usage bare_os_freemem bare_os_totalmem bare_os_uptime bare_os_loadavg bare_os_cpus bare_os_get_process_title bare_os_set_process_title bare_os_get_env_keys bare_os_get_env bare_os_set_env bare_os_unset_env bare_os_user_info bare_os_env_lock crtstuff.c __FRAME_END__ __gmon_start__ _init _GLOBAL_OFFSET_TABLE_ _fini __TMC_END__ _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __dso_handle __cxa_finalize bare_get_module_name_v0 bare_register_module_v0 uv_once js_create_string_utf8 js_set_named_property js_create_function js_get_boolean js_create_object js_create_uint32 js_create_int32 uv_rwlock_init uv_os_uname uv_err_name uv_strerror js_throw_error uv_exepath uv_os_getpid uv_os_getppid uv_cwd js_get_callback_info js_get_value_string_utf8 uv_chdir uv_os_tmpdir uv_os_homedir uv_os_gethostname js_get_value_uint32 uv_kill uv_available_parallelism js_create_int64 uv_getrusage uv_getrusage_thread js_get_heap_statistics uv_resident_set_memory uv_get_free_memory uv_get_total_memory uv_uptime js_create_double js_create_arraybuffer js_create_typedarray uv_loadavg uv_cpu_info js_create_array_with_length js_set_element js_get_named_property uv_free_cpu_info uv_get_process_title uv_set_process_title uv_rwlock_rdlock uv_os_environ uv_rwlock_rdunlock uv_os_free_environ malloc uv_os_getenv js_get_undefined realloc free uv_rwlock_wrlock uv_os_setenv uv_rwlock_wrunlock uv_os_unsetenv uv_os_get_passwd strlen js_get_null uv_os_free_passwd _DYNAMIC                                                                                p      p                                                             x                             o        	       	                                  )   o       	      	                                   8   o       	      	      $                             B             	      	                                   J             `      `                                  T      B                                             ^      2                                                f                                                      t                         d                             ~             P3      P#      B2                                          e      U                                                 e      U                                                 e      U                                                 y      Y                                                y      Y                                                y      Y                                              `{      `[                                                        [                                                       [                                                        [                                                      ]      H                                    0               ]      m                                                   ^      X         5                                       `i                                                         bj                                   /* global Bare */

// This export SHOULD NOT be shortened in any way as having the full
// `module.exports = require(...)` statement is crucial for synthesizing
// ESM exports.

if (Bare.platform === 'win32') {
  module.exports = require('./lib/win32')
} else {
  module.exports = require('./lib/posix')
}
module.exports = {
  CHAR_UPPERCASE_A: 0x41,
  CHAR_LOWERCASE_A: 0x61,
  CHAR_UPPERCASE_Z: 0x5a,
  CHAR_LOWERCASE_Z: 0x7a,
  CHAR_DOT: 0x2e,
  CHAR_FORWARD_SLASH: 0x2f,
  CHAR_BACKWARD_SLASH: 0x5c,
  CHAR_COLON: 0x3a,
  CHAR_QUESTION_MARK: 0x3f
}
const os = require('bare-os')

const { normalizeString } = require('./shared')
const {
  CHAR_DOT,
  CHAR_FORWARD_SLASH
} = require('./constants')

function isPosixPathSeparator (code) {
  return code === CHAR_FORWARD_SLASH
}

exports.win32 = require('./win32')
exports.posix = exports

exports.sep = '/'
exports.delimiter = ':'

exports.resolve = function resolve (...args) {
  let resolvedPath = ''
  let resolvedAbsolute = false

  for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    const path = i >= 0 ? args[i] : os.cwd()

    if (path.length === 0) {
      continue
    }

    resolvedPath = `${path}/${resolvedPath}`
    resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH
  }

  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator)

  if (resolvedAbsolute) {
    return `/${resolvedPath}`
  }

  return resolvedPath.length > 0 ? resolvedPath : '.'
}

exports.normalize = function normalize (path) {
  if (path.length === 0) return '.'

  const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH
  const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH

  path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator)

  if (path.length === 0) {
    if (isAbsolute) return '/'
    return trailingSeparator ? './' : '.'
  }

  if (trailingSeparator) path += '/'

  return isAbsolute ? `/${path}` : path
}

exports.isAbsolute = function isAbsolute (path) {
  return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH
}

exports.join = function join (...args) {
  if (args.length === 0) return '.'
  let joined
  for (let i = 0; i < args.length; ++i) {
    const arg = args[i]
    if (arg.length > 0) {
      if (joined === undefined) joined = arg
      else joined += `/${arg}`
    }
  }
  if (joined === undefined) return '.'
  return exports.normalize(joined)
}

exports.relative = function relative (from, to) {
  if (from === to) return ''

  from = exports.resolve(from)
  to = exports.resolve(to)

  if (from === to) return ''

  const fromStart = 1
  const fromEnd = from.length
  const fromLen = fromEnd - fromStart
  const toStart = 1
  const toLen = to.length - toStart

  const length = (fromLen < toLen ? fromLen : toLen)
  let lastCommonSep = -1
  let i = 0
  for (; i < length; i++) {
    const fromCode = from.charCodeAt(fromStart + i)
    if (fromCode !== to.charCodeAt(toStart + i)) {
      break
    } else if (fromCode === CHAR_FORWARD_SLASH) {
      lastCommonSep = i
    }
  }
  if (i === length) {
    if (toLen > length) {
      if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
        return to.substring(toStart + i + 1)
      }
      if (i === 0) {
        return to.substring(toStart + i)
      }
    } else if (fromLen > length) {
      if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {
        lastCommonSep = i
      } else if (i === 0) {
        lastCommonSep = 0
      }
    }
  }

  let out = ''
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {
      out += out.length === 0 ? '..' : '/..'
    }
  }

  return `${out}${to.substring(toStart + lastCommonSep)}`
}

exports.toNamespacedPath = function toNamespacedPath (path) {
  return path
}

exports.dirname = function dirname (path) {
  if (path.length === 0) return '.'
  const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH
  let end = -1
  let matchedSlash = true
  for (let i = path.length - 1; i >= 1; --i) {
    if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
      if (!matchedSlash) {
        end = i
        break
      }
    } else {
      matchedSlash = false
    }
  }

  if (end === -1) return hasRoot ? '/' : '.'
  if (hasRoot && end === 1) return '//'
  return path.substring(0, end)
}

exports.basename = function basename (path, suffix) {
  let start = 0
  let end = -1
  let matchedSlash = true

  if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {
    if (suffix === path) { return '' }
    let extIdx = suffix.length - 1
    let firstNonSlashEnd = -1
    for (let i = path.length - 1; i >= 0; --i) {
      const code = path.charCodeAt(i)
      if (code === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          start = i + 1
          break
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false
          firstNonSlashEnd = i + 1
        }
        if (extIdx >= 0) {
          if (code === suffix.charCodeAt(extIdx)) {
            if (--extIdx === -1) {
              end = i
            }
          } else {
            extIdx = -1
            end = firstNonSlashEnd
          }
        }
      }
    }

    if (start === end) end = firstNonSlashEnd
    else if (end === -1) end = path.length
    return path.substring(start, end)
  }

  for (let i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
      if (!matchedSlash) {
        start = i + 1
        break
      }
    } else if (end === -1) {
      matchedSlash = false
      end = i + 1
    }
  }

  if (end === -1) return ''
  return path.substring(start, end)
}

exports.extname = function extname (path) {
  let startDot = -1
  let startPart = 0
  let end = -1
  let matchedSlash = true
  let preDotState = 0
  for (let i = path.length - 1; i >= 0; --i) {
    const code = path.charCodeAt(i)
    if (code === CHAR_FORWARD_SLASH) {
      if (!matchedSlash) {
        startPart = i + 1
        break
      }
      continue
    }
    if (end === -1) {
      matchedSlash = false
      end = i + 1
    }
    if (code === CHAR_DOT) {
      if (startDot === -1) startDot = i
      else if (preDotState !== 1) preDotState = 1
    } else if (startDot !== -1) {
      preDotState = -1
    }
  }

  if (startDot === -1 || end === -1 || preDotState === 0 || (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
    return ''
  }
  return path.substring(startDot, end)
}
const {
  CHAR_DOT,
  CHAR_FORWARD_SLASH
} = require('./constants')

exports.normalizeString = function normalizeString (path, allowAboveRoot, separator, isPathSeparator) {
  let res = ''
  let lastSegmentLength = 0
  let lastSlash = -1
  let dots = 0
  let code = 0
  for (let i = 0; i <= path.length; ++i) {
    if (i < path.length) {
      code = path.charCodeAt(i)
    } else if (isPathSeparator(code)) {
      break
    } else {
      code = CHAR_FORWARD_SLASH
    }

    if (isPathSeparator(code)) {
      if (lastSlash === i - 1 || dots === 1) ;
      else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator)
            if (lastSlashIndex === -1) {
              res = ''
              lastSegmentLength = 0
            } else {
              res = res.substring(0, lastSlashIndex)
              lastSegmentLength =
                res.length - 1 - res.lastIndexOf(separator)
            }
            lastSlash = i
            dots = 0
            continue
          } else if (res.length !== 0) {
            res = ''
            lastSegmentLength = 0
            lastSlash = i
            dots = 0
            continue
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? `${separator}..` : '..'
          lastSegmentLength = 2
        }
      } else {
        if (res.length > 0) {
          res += `${separator}${path.substring(lastSlash + 1, i)}`
        } else {
          res = path.substring(lastSlash + 1, i)
        }
        lastSegmentLength = i - lastSlash - 1
      }
      lastSlash = i
      dots = 0
    } else if (code === CHAR_DOT && dots !== -1) {
      ++dots
    } else {
      dots = -1
    }
  }
  return res
}
const os = require('bare-os')

const { normalizeString } = require('./shared')
const {
  CHAR_UPPERCASE_A,
  CHAR_LOWERCASE_A,
  CHAR_UPPERCASE_Z,
  CHAR_LOWERCASE_Z,
  CHAR_DOT,
  CHAR_FORWARD_SLASH,
  CHAR_BACKWARD_SLASH,
  CHAR_COLON,
  CHAR_QUESTION_MARK
} = require('./constants')

function isWindowsPathSeparator (code) {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH
}

function isWindowsDeviceRoot (code) {
  return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||
         (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z)
}

exports.posix = require('./posix')
exports.win32 = exports

exports.sep = '\\'
exports.delimiter = ';'

exports.resolve = function resolve (...args) {
  let resolvedDevice = ''
  let resolvedTail = ''
  let resolvedAbsolute = false

  for (let i = args.length - 1; i >= -1; i--) {
    let path
    if (i >= 0) {
      path = args[i]

      if (path.length === 0) continue
    } else if (resolvedDevice.length === 0) {
      path = os.cwd()
    } else {
      path = os.getEnv(`=${resolvedDevice}`) || os.cwd()

      if (path === undefined || (path.substring(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path.charCodeAt(2) === CHAR_BACKWARD_SLASH)) {
        path = `${resolvedDevice}\\`
      }
    }

    const len = path.length
    let rootEnd = 0
    let device = ''
    let isAbsolute = false
    const code = path.charCodeAt(0)

    if (len === 1) {
      if (isWindowsPathSeparator(code)) {
        rootEnd = 1
        isAbsolute = true
      }
    } else if (isWindowsPathSeparator(code)) {
      isAbsolute = true

      if (isWindowsPathSeparator(path.charCodeAt(1))) {
        let j = 2
        let last = j
        while (j < len && !isWindowsPathSeparator(path.charCodeAt(j))) {
          j++
        }
        if (j < len && j !== last) {
          const firstPart = path.substring(last, j)
          last = j
          while (j < len && isWindowsPathSeparator(path.charCodeAt(j))) {
            j++
          }
          if (j < len && j !== last) {
            last = j
            while (j < len && !isWindowsPathSeparator(path.charCodeAt(j))) {
              j++
            }
            if (j === len || j !== last) {
              device = `\\\\${firstPart}\\${path.substring(last, j)}`
              rootEnd = j
            }
          }
        }
      } else {
        rootEnd = 1
      }
    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
      device = path.substring(0, 2)
      rootEnd = 2
      if (len > 2 && isWindowsPathSeparator(path.charCodeAt(2))) {
        isAbsolute = true
        rootEnd = 3
      }
    }

    if (device.length > 0) {
      if (resolvedDevice.length > 0) {
        if (device.toLowerCase() !== resolvedDevice.toLowerCase()) { continue }
      } else {
        resolvedDevice = device
      }
    }

    if (resolvedAbsolute) {
      if (resolvedDevice.length > 0) { break }
    } else {
      resolvedTail = `${path.substring(rootEnd)}\\${resolvedTail}`
      resolvedAbsolute = isAbsolute
      if (isAbsolute && resolvedDevice.length > 0) {
        break
      }
    }
  }

  resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\', isWindowsPathSeparator)

  return resolvedAbsolute ? `${resolvedDevice}\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || '.'
}

exports.normalize = function normalize (path) {
  const len = path.length
  if (len === 0) return '.'
  let rootEnd = 0
  let device
  let isAbsolute = false
  const code = path.charCodeAt(0)

  if (len === 1) {
    return code === CHAR_FORWARD_SLASH ? '\\' : path
  }

  if (isWindowsPathSeparator(code)) {
    isAbsolute = true

    if (isWindowsPathSeparator(path.charCodeAt(1))) {
      let j = 2
      let last = j
      while (j < len && !isWindowsPathSeparator(path.charCodeAt(j))) {
        j++
      }
      if (j < len && j !== last) {
        const firstPart = path.substring(last, j)
        last = j
        while (j < len && isWindowsPathSeparator(path.charCodeAt(j))) {
          j++
        }
        if (j < len && j !== last) {
          last = j
          while (j < len && !isWindowsPathSeparator(path.charCodeAt(j))) {
            j++
          }
          if (j === len) {
            return `\\\\${firstPart}\\${path.substring(last)}\\`
          }
          if (j !== last) {
            device = `\\\\${firstPart}\\${path.substring(last, j)}`
            rootEnd = j
          }
        }
      }
    } else {
      rootEnd = 1
    }
  } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
    device = path.substring(0, 2)
    rootEnd = 2
    if (len > 2 && isWindowsPathSeparator(path.charCodeAt(2))) {
      isAbsolute = true
      rootEnd = 3
    }
  }

  let tail = rootEnd < len ? normalizeString(path.substring(rootEnd), !isAbsolute, '\\', isWindowsPathSeparator) : ''
  if (tail.length === 0 && !isAbsolute) {
    tail = '.'
  }
  if (tail.length > 0 && isWindowsPathSeparator(path.charCodeAt(len - 1))) {
    tail += '\\'
  }
  if (device === undefined) {
    return isAbsolute ? `\\${tail}` : tail
  }
  return isAbsolute ? `${device}\\${tail}` : `${device}${tail}`
}

exports.isAbsolute = function isAbsolute (path) {
  const len = path.length
  if (len === 0) return false

  const code = path.charCodeAt(0)

  return isWindowsPathSeparator(code) || (len > 2 && isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON && isWindowsPathSeparator(path.charCodeAt(2)))
}

exports.join = function join (...args) {
  if (args.length === 0) return '.'

  let joined
  let firstPart
  for (let i = 0; i < args.length; ++i) {
    const arg = args[i]
    if (arg.length > 0) {
      if (joined === undefined) joined = firstPart = arg
      else joined += `\\${arg}`
    }
  }

  if (joined === undefined) return '.'

  let needsReplace = true
  let slashCount = 0
  if (isWindowsPathSeparator(firstPart.charCodeAt(0))) {
    ++slashCount
    const firstLen = firstPart.length
    if (firstLen > 1 && isWindowsPathSeparator(firstPart.charCodeAt(1))) {
      ++slashCount
      if (firstLen > 2) {
        if (isWindowsPathSeparator(firstPart.charCodeAt(2))) {
          ++slashCount
        } else {
          needsReplace = false
        }
      }
    }
  }
  if (needsReplace) {
    while (slashCount < joined.length && isWindowsPathSeparator(joined.charCodeAt(slashCount))) {
      slashCount++
    }

    if (slashCount >= 2) {
      joined = `\\${joined.substring(slashCount)}`
    }
  }

  return exports.normalize(joined)
}

exports.relative = function relative (from, to) {
  if (from === to) return ''

  const fromOrig = exports.resolve(from)
  const toOrig = exports.resolve(to)

  if (fromOrig === toOrig) return ''

  from = fromOrig.toLowerCase()
  to = toOrig.toLowerCase()

  if (from === to) return ''

  let fromStart = 0
  while (fromStart < from.length && from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {
    fromStart++
  }
  let fromEnd = from.length
  while (fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {
    fromEnd--
  }
  const fromLen = fromEnd - fromStart

  let toStart = 0
  while (toStart < to.length && to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
    toStart++
  }
  let toEnd = to.length
  while (toEnd - 1 > toStart && to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {
    toEnd--
  }
  const toLen = toEnd - toStart

  const length = fromLen < toLen ? fromLen : toLen
  let lastCommonSep = -1
  let i = 0
  for (; i < length; i++) {
    const fromCode = from.charCodeAt(fromStart + i)
    if (fromCode !== to.charCodeAt(toStart + i)) {
      break
    } else if (fromCode === CHAR_BACKWARD_SLASH) {
      lastCommonSep = i
    }
  }

  if (i !== length) {
    if (lastCommonSep === -1) return toOrig
  } else {
    if (toLen > length) {
      if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
        return toOrig.substring(toStart + i + 1)
      }
      if (i === 2) {
        return toOrig.substring(toStart + i)
      }
    }
    if (fromLen > length) {
      if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
        lastCommonSep = i
      } else if (i === 2) {
        lastCommonSep = 3
      }
    }
    if (lastCommonSep === -1) lastCommonSep = 0
  }

  let out = ''
  for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
    if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
      out += out.length === 0 ? '..' : '\\..'
    }
  }

  toStart += lastCommonSep

  if (out.length > 0) {
    return `${out}${toOrig.substring(toStart, toEnd)}`
  }
  if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
    ++toStart
  }
  return toOrig.substring(toStart, toEnd)
}

exports.toNamespacedPath = function toNamespacedPath (path) {
  if (path.length === 0) return path

  const resolvedPath = exports.resolve(path)

  if (resolvedPath.length <= 2) return path

  if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
    if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
      const code = resolvedPath.charCodeAt(2)
      if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {
        return `\\\\?\\UNC\\${resolvedPath.substring(2)}`
      }
    }
  } else if (
    isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&
      resolvedPath.charCodeAt(1) === CHAR_COLON &&
      resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH
  ) {
    return `\\\\?\\${resolvedPath}`
  }

  return path
}

exports.dirname = function dirname (path) {
  const len = path.length
  if (len === 0) return '.'
  let rootEnd = -1
  let offset = 0
  const code = path.charCodeAt(0)

  if (len === 1) {
    return isWindowsPathSeparator(code) ? path : '.'
  }

  if (isWindowsPathSeparator(code)) {
    rootEnd = offset = 1

    if (isWindowsPathSeparator(path.charCodeAt(1))) {
      let j = 2
      let last = j
      while (j < len && !isWindowsPathSeparator(path.charCodeAt(j))) {
        j++
      }
      if (j < len && j !== last) {
        last = j
        while (j < len && isWindowsPathSeparator(path.charCodeAt(j))) {
          j++
        }
        if (j < len && j !== last) {
          last = j
          while (j < len && !isWindowsPathSeparator(path.charCodeAt(j))) {
            j++
          }
          if (j === len) {
            return path
          }
          if (j !== last) {
            rootEnd = offset = j + 1
          }
        }
      }
    }
  } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {
    rootEnd = len > 2 && isWindowsPathSeparator(path.charCodeAt(2)) ? 3 : 2
    offset = rootEnd
  }

  let end = -1
  let matchedSlash = true
  for (let i = len - 1; i >= offset; --i) {
    if (isWindowsPathSeparator(path.charCodeAt(i))) {
      if (!matchedSlash) {
        end = i
        break
      }
    } else {
      matchedSlash = false
    }
  }

  if (end === -1) {
    if (rootEnd === -1) return '.'

    end = rootEnd
  }
  return path.substring(0, end)
}

exports.basename = function basename (path, suffix) {
  let start = 0
  let end = -1
  let matchedSlash = true

  if (path.length >= 2 && isWindowsDeviceRoot(path.charCodeAt(0)) && path.charCodeAt(1) === CHAR_COLON) {
    start = 2
  }

  if (suffix !== undefined && suffix.length > 0 && suffix.length <= path.length) {
    if (suffix === path) return ''
    let extIdx = suffix.length - 1
    let firstNonSlashEnd = -1
    for (let i = path.length - 1; i >= start; --i) {
      const code = path.charCodeAt(i)
      if (isWindowsPathSeparator(code)) {
        if (!matchedSlash) {
          start = i + 1
          break
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false
          firstNonSlashEnd = i + 1
        }
        if (extIdx >= 0) {
          if (code === suffix.charCodeAt(extIdx)) {
            if (--extIdx === -1) {
              end = i
            }
          } else {
            extIdx = -1
            end = firstNonSlashEnd
          }
        }
      }
    }

    if (start === end) end = firstNonSlashEnd
    else if (end === -1) end = path.length
    return path.substring(start, end)
  }
  for (let i = path.length - 1; i >= start; --i) {
    if (isWindowsPathSeparator(path.charCodeAt(i))) {
      if (!matchedSlash) {
        start = i + 1
        break
      }
    } else if (end === -1) {
      matchedSlash = false
      end = i + 1
    }
  }

  if (end === -1) return ''
  return path.substring(start, end)
}

exports.extname = function extname (path) {
  let start = 0
  let startDot = -1
  let startPart = 0
  let end = -1
  let matchedSlash = true
  let preDotState = 0

  if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {
    start = startPart = 2
  }

  for (let i = path.length - 1; i >= start; --i) {
    const code = path.charCodeAt(i)
    if (isWindowsPathSeparator(code)) {
      if (!matchedSlash) {
        startPart = i + 1
        break
      }
      continue
    }
    if (end === -1) {
      matchedSlash = false
      end = i + 1
    }
    if (code === CHAR_DOT) {
      if (startDot === -1) startDot = i
      else if (preDotState !== 1) preDotState = 1
    } else if (startDot !== -1) {
      preDotState = -1
    }
  }

  if (startDot === -1 || end === -1 || preDotState === 0 || (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
    return ''
  }
  return path.substring(startDot, end)
}
{
  "name": "bare-path",
  "version": "3.0.0",
  "description": "Path manipulation library for JavaScript",
  "exports": {
    ".": "./index.js",
    "./package": "./package.json",
    "./posix": "./lib/posix.js",
    "./win32": "./lib/win32.js"
  },
  "files": [
    "index.js",
    "lib",
    "NOTICE"
  ],
  "scripts": {
    "test": "standard && bare test.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/holepunchto/bare-path.git"
  },
  "author": "Holepunch",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/holepunchto/bare-path/issues"
  },
  "homepage": "https://github.com/holepunchto/bare-path#readme",
  "dependencies": {
    "bare-os": "^3.0.1"
  },
  "devDependencies": {
    "brittle": "^3.3.2",
    "standard": "^17.0.0"
  }
}
module.exports = require.addon()
const EventEmitter = require('bare-events')
const { Duplex } = require('bare-stream')
const binding = require('./binding')
const constants = require('./lib/constants')
const errors = require('./lib/errors')

const defaultReadBufferSize = 65536

module.exports = exports = class Pipe extends Duplex {
  constructor(path, opts = {}) {
    if (typeof path === 'object' && path !== null) {
      opts = path
      path = null
    }

    const {
      allowHalfOpen = true,
      eagerOpen = true,
      readBufferSize = defaultReadBufferSize
    } = opts

    super({ eagerOpen })

    this._state = 0

    this._allowHalfOpen = allowHalfOpen

    this._fd = -1
    this._path = null

    this._pendingOpen = null
    this._pendingWrite = null
    this._pendingFinal = null
    this._pendingDestroy = null

    this._buffer = Buffer.alloc(readBufferSize)

    this._handle = binding.init(
      this._buffer,
      this,
      noop,
      this._onconnect,
      this._onwrite,
      this._onfinal,
      this._onread,
      this._onclose
    )

    if (typeof path === 'number') {
      this.open(path)
    } else if (typeof path === 'string') {
      this.connect(path)
    }
  }

  get connecting() {
    return (this._state & constants.state.CONNECTING) !== 0
  }

  get pending() {
    return (this._state & constants.state.CONNECTED) === 0
  }

  get readyState() {
    if (
      this._state & constants.state.READABLE &&
      this._state & constants.state.WRITABLE
    ) {
      return 'open'
    }

    if (this._state & constants.state.READABLE) {
      return 'readOnly'
    }

    if (this._state & constants.state.WRITABLE) {
      return 'writeOnly'
    }

    return 'opening'
  }

  open(fd, opts = {}, onconnect) {
    if (typeof opts === 'function') {
      onconnect = opts
      opts = {}
    }

    if (typeof fd === 'object' && fd !== null) {
      opts = fd || {}
      fd = opts.fd
    }

    try {
      const status = binding.open(this._handle, fd)

      this._state |= constants.state.CONNECTED
      this._fd = fd

      if (status & binding.READABLE) {
        this._state |= constants.state.READABLE
      } else {
        this.push(null)
      }

      if (status & binding.WRITABLE) {
        this._state |= constants.state.WRITABLE
      } else {
        this.end()
      }

      if (onconnect) this.once('connect', onconnect)

      queueMicrotask(() => this.emit('connect'))
    } catch (err) {
      queueMicrotask(() => {
        if (this._pendingOpen) this._pendingOpen(err)
        else this.destroy(err)
      })
    }

    return this
  }

  connect(path, opts = {}, onconnect) {
    if (
      this._state & constants.state.CONNECTING ||
      this._state & constants.state.CONNECTED
    ) {
      throw errors.PIPE_ALREADY_CONNECTED('Pipe is already connected')
    }

    this._state |= constants.state.CONNECTING

    if (typeof opts === 'function') {
      onconnect = opts
      opts = {}
    }

    if (typeof path === 'object' && path !== null) {
      opts = path || {}
      path = opts.path
    }

    try {
      binding.connect(this._handle, path)

      this._path = path

      if (onconnect) this.once('connect', onconnect)
    } catch (err) {
      queueMicrotask(() => {
        if (this._pendingOpen) this._pendingOpen(err)
        else this.destroy(err)
      })
    }

    return this
  }

  ref() {
    binding.ref(this._handle)
  }

  unref() {
    binding.unref(this._handle)
  }

  _open(cb) {
    if (this._state & constants.state.CONNECTED) return cb(null)
    this._pendingOpen = cb
  }

  _read() {
    if ((this._state & constants.state.READING) === 0) {
      this._state |= constants.state.READING
      binding.resume(this._handle)
    }
  }

  _writev(batch, cb) {
    this._pendingWrite = [cb, batch]
    binding.writev(
      this._handle,
      batch.map(({ chunk }) => chunk)
    )
  }

  _final(cb) {
    if (
      this._state & constants.state.READABLE &&
      this._state & constants.state.WRITABLE
    ) {
      this._pendingFinal = cb
      binding.end(this._handle)
    } else {
      cb(null)
    }
  }

  _predestroy() {
    if (this._state & constants.state.CLOSING) return
    this._state |= constants.state.CLOSING
    binding.close(this._handle)
  }

  _destroy(err, cb) {
    if (this._state & constants.state.CLOSING) return cb(err)
    this._state |= constants.state.CLOSING
    this._pendingDestroy = cb
    binding.close(this._handle)
  }

  _continueOpen(err) {
    if (this._pendingOpen === null) return
    const cb = this._pendingOpen
    this._pendingOpen = null
    cb(err)
  }

  _continueWrite(err) {
    if (this._pendingWrite === null) return
    const cb = this._pendingWrite[0]
    this._pendingWrite = null
    cb(err)
  }

  _continueFinal(err) {
    if (this._pendingFinal === null) return
    const cb = this._pendingFinal
    this._pendingFinal = null
    cb(err)
  }

  _continueDestroy() {
    if (this._pendingDestroy === null) return
    const cb = this._pendingDestroy
    this._pendingDestroy = null
    cb(null)
  }

  _onconnect(err) {
    if (err) {
      if (this._pendingOpen) this._continueOpen(err)
      else this.destroy(err)
      return
    }

    this._state |=
      constants.state.CONNECTED |
      constants.state.READABLE |
      constants.state.WRITABLE
    this._state &= ~constants.state.CONNECTING
    this._continueOpen()

    this.emit('connect')
  }

  _onread(err, read) {
    if (err) {
      this.destroy(err)
      return
    }

    if (read === 0) {
      this.push(null)
      if (this._allowHalfOpen === false) this.end()
      return
    }

    const copy = Buffer.allocUnsafe(read)
    copy.set(this._buffer.subarray(0, read))

    if (this.push(copy) === false && this.destroying === false) {
      this._state &= ~constants.state.READING
      binding.pause(this._handle)
    }
  }

  _onwrite(err) {
    this._continueWrite(err)
  }

  _onfinal(err) {
    this._continueFinal(err)
  }

  _onclose() {
    this._handle = null
    this._continueDestroy()
  }

  _onspawn(readable, writable) {
    this._state |= constants.state.CONNECTED

    if (readable) {
      this._state |= constants.state.READABLE
    } else {
      this.push(null)
    }

    if (writable) {
      this._state |= constants.state.WRITABLE
    } else {
      this.end()
    }

    this._continueOpen()
  }
}

exports.Pipe = exports

exports.pipe = function pipe() {
  return binding.pipe()
}

exports.Server = class PipeServer extends EventEmitter {
  constructor(opts = {}, onconnection) {
    if (typeof opts === 'function') {
      onconnection = opts
      opts = {}
    }

    super()

    const { readBufferSize = defaultReadBufferSize, allowHalfOpen = true } =
      opts

    this._state = 0

    this._readBufferSize = readBufferSize
    this._allowHalfOpen = allowHalfOpen

    this._path = null
    this._connections = new Set()

    this._error = null
    this._handle = null

    if (onconnection) this.on('connection', onconnection)
  }

  get listening() {
    return (this._state & constants.state.BOUND) !== 0
  }

  address() {
    if ((this._state & constants.state.BOUND) === 0) {
      return null
    }

    return this._path
  }

  listen(path, backlog = 511, opts = {}, onlistening) {
    if (
      this._state & constants.state.BINDING ||
      this._state & constants.state.BOUND
    ) {
      throw errors.SERVER_ALREADY_LISTENING('Server is already listening')
    }

    if (this._state & constants.state.CLOSING) {
      throw errors.SERVER_IS_CLOSED('Server is closed')
    }

    this._state |= constants.state.BINDING

    if (typeof backlog === 'function') {
      onlistening = backlog
      backlog = 511
    } else if (typeof opts === 'function') {
      onlistening = opts
      opts = {}
    }

    if (typeof path === 'object' && path !== null) {
      opts = path || {}
      path = opts.path
      backlog = opts.backlog || 511
    }

    this._handle = binding.init(
      empty,
      this,
      this._onconnection,
      noop,
      noop,
      noop,
      noop,
      this._onclose
    )

    if (this._state & constants.state.UNREFED) binding.unref(this._handle)

    try {
      binding.bind(this._handle, path, backlog)

      this._path = path
      this._state |= constants.state.BOUND
      this._state &= ~constants.state.BINDING

      if (onlistening) this.once('listening', onlistening)

      queueMicrotask(() => this.emit('listening'))
    } catch (err) {
      this._error = err

      binding.close(this._handle)
    }

    return this
  }

  close(onclose) {
    if (onclose) this.once('close', onclose)
    if (this._state & constants.state.CLOSING) return
    this._state |= constants.state.CLOSING
    this._closeMaybe()
  }

  ref() {
    this._state &= ~constants.state.UNREFED
    if (this._handle !== null) binding.ref(this._handle)
  }

  unref() {
    this._state |= constants.state.UNREFED
    if (this._handle !== null) binding.unref(this._handle)
  }

  _closeMaybe() {
    if (this._state & constants.state.CLOSING && this._connections.size === 0) {
      if (this._handle !== null) binding.close(this._handle)
      else queueMicrotask(() => this.emit('close'))
    }
  }

  _onconnection(err) {
    if (err) {
      this.emit('error', err)
      return
    }

    if (this._state & constants.state.CLOSING) return

    const pipe = new exports.Pipe({
      readBufferSize: this._readBufferSize,
      allowHalfOpen: this._allowHalfOpen
    })

    try {
      binding.accept(this._handle, pipe._handle)

      pipe._path = this._path
      pipe._state |=
        constants.state.CONNECTED |
        constants.state.READABLE |
        constants.state.WRITABLE

      this._connections.add(pipe)

      pipe.on('close', () => {
        this._connections.delete(pipe)
        this._closeMaybe()
      })

      this.emit('connection', pipe)
    } catch (err) {
      pipe.destroy()

      throw err
    }
  }

  _onclose() {
    const err = this._error

    this._state &= ~constants.state.BINDING
    this._error = null
    this._handle = null

    if (err) this.emit('error', err)
    else this.emit('close')
  }
}

exports.constants = constants
exports.errors = errors

exports.createConnection = function createConnection(path, opts, onconnect) {
  if (typeof opts === 'function') {
    onconnect = opts
    opts = {}
  }

  if (typeof path === 'object' && path !== null) {
    opts = path || {}
    path = opts.path
  }

  return new exports.Pipe(opts).connect(path, opts, onconnect)
}

exports.createServer = function createServer(opts, onconnection) {
  return new exports.Server(opts, onconnection)
}

const empty = Buffer.alloc(0)

function noop() {}
module.exports = {
  state: {
    CONNECTING: 0x1,
    CONNECTED: 0x2,
    BINDING: 0x4,
    BOUND: 0x8,
    READING: 0x10,
    CLOSING: 0x20,
    READABLE: 0x40,
    WRITABLE: 0x80
  }
}
module.exports = class PipeError extends Error {
  constructor(msg, code, fn = PipeError) {
    super(`${code}: ${msg}`)
    this.code = code

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, fn)
    }
  }

  get name() {
    return 'PipeError'
  }

  static PIPE_ALREADY_CONNECTED(msg) {
    return new PipeError(
      msg,
      'PIPE_ALREADY_CONNECTED',
      PipeError.PIPE_ALREADY_CONNECTED
    )
  }

  static SERVER_ALREADY_LISTENING(msg) {
    return new PipeError(
      msg,
      'SERVER_ALREADY_LISTENING',
      PipeError.SERVER_ALREADY_LISTENING
    )
  }

  static SERVER_IS_CLOSED(msg) {
    return new PipeError(msg, 'SERVER_IS_CLOSED', PipeError.SERVER_IS_CLOSED)
  }
}
{
  "name": "bare-pipe",
  "version": "4.0.6",
  "description": "Native I/O pipes for JavaScript",
  "exports": {
    "./package": "./package.json",
    ".": {
      "types": "./index.d.ts",
      "default": "./index.js"
    },
    "./constants": {
      "types": "./lib/constants.d.ts",
      "default": "./lib/constants.js"
    },
    "./errors": {
      "types": "./lib/errors.d.ts",
      "default": "./lib/errors.js"
    }
  },
  "files": [
    "index.js",
    "index.d.ts",
    "binding.c",
    "binding.js",
    "CMakeLists.txt",
    "lib",
    "prebuilds"
  ],
  "addon": true,
  "scripts": {
    "test": "prettier . --check && bare test.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/holepunchto/bare-pipe.git"
  },
  "author": "Holepunch",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/holepunchto/bare-pipe/issues"
  },
  "homepage": "https://github.com/holepunchto/bare-pipe#readme",
  "engines": {
    "bare": ">=1.16.0"
  },
  "dependencies": {
    "bare-events": "^2.0.0",
    "bare-stream": "^2.0.0"
  },
  "devDependencies": {
    "bare-path": "^3.0.0",
    "brittle": "^3.2.1",
    "cmake-bare": "^1.1.6",
    "prettier": "^3.4.1",
    "prettier-config-standard": "^7.0.0"
  }
}
ELF          >            @       A          @ 8 
 @         @       @       @       0      0                                                                          &      &                                 -      M      M                               /      _      _                               -      M      M                         Rtd   -      M      M                          Ptd                                          Qtd                                                         p      p      p                                    GNU _g]                                                                      ,                       F   "                   m                                                                                                                                                                                                                          <                     H                     T                     c                     {                                                                                                                                                                                                                                       !                     (                     >                     G                     L                     X                     f                     s                     |                                                                                                                                                                                                                                        6                     [                     g                     }                                          U     '      j                                                                           ui	            6                6   Ma __gmon_start__ _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize bare_register_module_v0 js_create_function js_set_named_property js_create_uint32 js_get_callback_info js_get_env_loop js_create_arraybuffer uv_pipe_init js_get_typedarray_info js_create_reference js_add_deferred_teardown_callback uv_err_name uv_strerror js_throw_error js_get_arraybuffer_info js_get_value_string_utf8 strlen uv_pipe_connect2 js_get_value_uint32 uv_pipe_open uv_is_readable uv_is_writable uv_pipe_bind2 uv_listen uv_accept js_get_array_length malloc js_get_array_elements uv_write free uv_shutdown uv_read_start uv_read_stop uv_close uv_ref uv_unref uv_pipe js_create_array_with_length js_create_int64 js_set_element js_open_handle_scope js_get_reference_value js_delete_reference js_call_function js_close_handle_scope js_finish_deferred_teardown_callback js_get_null js_create_string_utf8 js_create_error js_create_int32 libc.so.6 GLIBC_2.2.5 bare-pipe@4.bare     M             0'      M             p'      _             _      O                    O                    O                    O                    _                    _                    _                    _                    _                    _         	           _         
           _                     `                    `                    `                    `                     `                    (`                    0`                    8`                    @`                    H`                    P`                    X`                    ``                    h`                    p`                    x`                    `                    `                    `                    `                    `                     `         !           `         "           `         #           `         $           `         %           `         &           `         '           `         (           `         )           `         *           `         +            a         ,           a         -           a         .           a         /            a         0           (a         1           0a         2           8a         3           @a         4           Ha         5           READABLE close pause unref accept writev pipe ref resume init open bind WRITABLE connect end    ;                 H      `    @            p      P           @!     !  @  !  `  p"    "    #    $    %  (  p&  X  `'    p'               zR x  4        j   BBA D0[ ABB       4   T        ABA D ABA      <            ABB A(G (A BBA       ,            ABA DP ABA4            ABA G  ABA       ,   4  H      ABA DP ABAL   d    M   ABB B(B0A8D48A0B(B BBA      ,           ABA D@ ABA,           ABA D@ ABA,     x      ABA D@x ABA   D    Z    AD0SA   d    L    AD0EA     H  L    AD0EA     x      AD0|A       #           ,            BBA D@ ABB,           ABA DP ABA,   <         ABA DP ABA,   l  P!      ABA DP ABA,     "      ABA DP ABA     "             4     "  /   BBA D`  ABB               H=8  H8  H9tH(  Ht	        H=8  H58  H)HH?HHHtHu(  HtfD      =:   u+UH=R(   HtH=N8  i  d9  ]     wAWAVSHIHL=#HS  LL$LHE1  HL$HLL  L=H  LL$HLHE1  HL$HLL  L=Hp  LL$HLHE1  HL$HLL  L=H  LL$HLHE1k  HL$HLLh  L=H  LL$HLHE10  HL$HLL-  L=H  LL$HLHE1  HL$HLL  L=H  LL$HLHE1  HL$HLL  L=HY  LL$HLHE1  HL$HLL|  L=$H  LL$HLHE1D  HL$HLLA  L=H	  LL$HLHE1	  HL$HLL  L=H8	  LL$HLHE1  HL$HLL  L=yHM	  LL$HLHE1  HL$HLL  L=RHb	  LL$HLHE1X  HL$HLLU  HT$H   S  HL$HHL,  HT$H   *  HL$HHL  LH[A^A_fD  UAVSHpHHD$(   HT$(HL$0E1E1  Ht$ H  HT$HL$  H  H|$ Ht$1  $  LD$I  fA    Ht$0Ix  I  H$    H1E1  Ht$8  HL$H     Ht$@  HL$H     Ht$H  HL$H   h  Ht$P  HL$H   L  Ht$X  HL$H   0  Ht$`  HL$H     Ht$h  HL$H     HT$H  H5  H  HD$#  I  HLH  1Hp[A^]f.     UAWAVSH(  IHD$   HT$HL$E1E1"  Ht$HL1  Ht$Lt$   LLE1  H,$H  H  L  LR  HHLHA     y!  H$  LHH&  1H(  [A^A_]fD  UAVSH0HHD$   HT$HL$ E1E1W  Ht$ HH1  Ht$(HT$H  H<$t$  x6H<$  1@H<$  uDHT$H  HD$#S  IY  HLH[  1H0[A^]UAVSHP  HHD$   HT$HL$ E1E1  Ht$ HT$H1   Ht$(Lt$@  HLE1  Ht$0HT$H1  Hl$L  HLH   Q  xH|$t$H  H  y!{  I  HLH  1HP  [A^]D  UAVSH0HHD$   HT$HL$ E1E1  Ht$ HT$H1C  Ht$(HT$H1/  H|$Ht$  y!  I  HLH  1H0[A^]UAWAVAUATSHHIHD$    E1HT$ HL$0E1E1  Ht$0HT$L1  H\$8HT$LHE  l$HHE  IH<    5  ILL$,LHHHE1)  |$ tD1Lf.      I4LCH$    L1HE1
  HDl$HL9rHt$Hh  Hh  L  LD  L  L  y
  H
  LHH
  1HH[A\A]A^A_] UAVSH HHD$   HT$HL$E1E1	  Ht$HT$H1c
  Ht$H(  H(  H  D  y!
  I
  HLH
  1H [A^]@ UAVSH HHD$   HT$HL$E1E1G	  Ht$HT$H1	  H|$)
  t=H|$H5Y  Hb  
  y!p	  Iv	  HLHx	  1H [A^]f.      UAVSH HHD$   HT$HL$E1E1  Ht$HT$H13	  H|$	  t/H|$;
  y!  I  HLH  1H [A^]f.     SH HHD$   HT$HL$E1E1  Ht$HT$H1  H|$  H5s  	  1H [fD  SH HHD$   HT$HL$E1E1  Ht$HT$H1F  H|$|	  1H [@ SH HHD$   HT$HL$E1E1j  Ht$HT$H1  H|$<	  1H [@ SH HH|$@   @   $	  H   H$	  Hct$HT$H"	  Hct$HT$H	  H4$HL$H1	  H4$HL$H     H$H [f.           tH   HH]  f.      AWAVSH HL  L  Ht$L  H  HT$L  H  HT$L  H  L  H  Ls  H  Ld  H  LU  H  LF  H  L7  H  L(     uHt$HT$L1E1E1  Ht$L  L   H [A^A_fD  UAVSH0H/      AH  Ht$(H  H  HT$ H  H  HT$Hy  ExHH  SD  HL$HHH  Dp  HL$HHH  Ht$HT$HH  Ht$ HT$I   HE1  Ht$(H  H0[A^]UAVSH0      AHH  Ht$(H  H  HT$ H  H  HT$H  ExHH  SD  HL$HHH  D  HL$HHH  Ht$HT$HH  Ht$ HT$I   HE1'  Ht$(H*  H0[A^]UAVSH0H/      AH  Ht$(H  H  HT$ H  H  HT$H  ExHH  SD  HL$HHH  D  HL$HHH  Ht$HT$HH  Ht$ HT$I   HE17  Ht$(H:  H0[A^]UAVSH0H/      AH  Ht$(H  H  HT$ H  H  HT$H  ExHH  SD  HL$HHH  D  HL$HHH  Ht$HT$HH  Ht$ HT$I   HE1G  Ht$(HJ  H0[A^]x  D  AWAVSH@HHtIH        E1      L  Ht$8L  H  HT$0L  H  HT$(L  MxHL  HT$LD]D  HL$ LHH  Dp  HL$LHH  Ht$ HT$HL  HT$L1  Ht$0HT$(I   LE1  Ht$8L  H@[A^A_ HH  HtH HH       5$  %$  @ %$  h    %$  h   %$  h   %$  h   %$  h   %$  h   %$  h   %$  h   p%$  h   `%$  h	   P%$  h
   @%$  h   0%$  h    %$  h   %$  h    %$  h   %z$  h   %r$  h   %j$  h   %b$  h   %Z$  h   %R$  h   %J$  h   %B$  h   p%:$  h   `%2$  h   P%*$  h   @%"$  h   0%$  h    %$  h   %
$  h    %$  h   %#  h    %#  h!   %#  h"   %#  h#   %#  h$   %#  h%   %#  h&   %#  h'   p%#  h(   `%#  h)   P%#  h*   @%#  h+   0%#  h,    %#  h-   %#  h.    %#  h/   %z#  h0   %r#  h1                                                    (                    	              o                                            _                                                      `      
             o    @             M                           M                           :             :      o          o           o                                                                   M                      :      :      :      :      ;      ;      &;      6;      F;      V;      f;      v;      ;      ;      ;      ;      ;      ;      ;      ;      <      <      &<      6<      F<      V<      f<      v<      <      <      <      <      <      <      <      <      =      =      &=      6=      F=      V=      f=      v=      =      =      =      =      =      =      Ubuntu clang version 14.0.0-1ubuntu1.1 GCC: (Ubuntu 12.3.0-1ubuntu1~22.04) 12.3.0  Linker: Ubuntu LLD 14.0.0                                                     _                   &              .     &              A     0'              W     Pa             c     M                   p'                   M                 _                                       *                 ,                  -                  @.                   /                 /      M            1             .    1             ?    02             O    2      Z       _     3      L       m    p3      L       }    3                 P4      #           5                 p6                 `7                 P8                 @9                 P9      /      $    4             8                   C                     _              `   :              |   :              f    _              (    M              Q                                                                    "                       '      j                                                !                     2                     G                     W                     m                     z                                                                                                                                                                                             &                     7                     K                     X                     g                     v                                                                                                                                                                                                                                                                                                                                                ;                     K                     Z                     o                                                                                                                                                                                              .note.gnu.build-id .dynsym .gnu.version .gnu.version_r .gnu.hash .dynstr .rela.dyn .rela.plt .rodata .eh_frame_hdr .eh_frame .text .init .fini .plt .fini_array .init_array .dynamic .got .data .tm_clone_table .got.plt .bss .comment .symtab .shstrtab .strtab  crtstuff.c __TMC_LIST__ deregister_tm_clones register_tm_clones __do_global_dtors_aux completed.0 __do_global_dtors_aux_fini_array_entry frame_dummy __frame_dummy_init_array_entry binding.c bare_pipe_init bare_pipe_connect bare_pipe_open bare_pipe_bind bare_pipe_accept bare_pipe_writev bare_pipe_end bare_pipe_resume bare_pipe_pause bare_pipe_close bare_pipe_ref bare_pipe_unref bare_pipe_pipe bare_pipe__on_teardown bare_pipe__on_connect bare_pipe__on_connection bare_pipe__on_write bare_pipe__on_shutdown bare_pipe__on_alloc bare_pipe__on_read bare_pipe__on_close crtstuff.c __FRAME_END__ __gmon_start__ _init _GLOBAL_OFFSET_TABLE_ _fini __TMC_END__ _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __dso_handle __cxa_finalize bare_register_module_v0 js_create_function js_set_named_property js_create_uint32 js_get_callback_info js_get_env_loop js_create_arraybuffer uv_pipe_init js_get_typedarray_info js_create_reference js_add_deferred_teardown_callback uv_err_name uv_strerror js_throw_error js_get_arraybuffer_info js_get_value_string_utf8 strlen uv_pipe_connect2 js_get_value_uint32 uv_pipe_open uv_is_readable uv_is_writable uv_pipe_bind2 uv_listen uv_accept js_get_array_length malloc js_get_array_elements uv_write free uv_shutdown uv_read_start uv_read_stop uv_close uv_ref uv_unref uv_pipe js_create_array_with_length js_create_int64 js_set_element js_open_handle_scope js_get_reference_value js_delete_reference js_call_function js_close_handle_scope js_finish_deferred_teardown_callback js_get_null js_create_string_utf8 js_create_error js_create_int32 _DYNAMIC                                                                                   p      p                                                             (                             o                   n                            )   o                                                  8   o       @      @                                    B             `      `                                   J             (      (                                  T      B                                             ^      2                   ]                             f                                                       t                                                      ~             &                                                      :      *                                                 :      *                                                 :      *      0                                          M      -                                                M      -                                                M      -                                              O      /                                                  _      /                                                 _      /                                                  _      /                                                Pa      P1                                          0               P1      m                                                   1               (                                       :                                                         ;      1                             exports.constants = require('./lib/constants')
exports.errors = require('./lib/errors')

const Version = exports.Version = require('./lib/version')
const Range = exports.Range = require('./lib/range')
exports.Comparator = require('./lib/comparator')

exports.satisfies = function satisfies (version, range) {
  if (typeof version === 'string') version = Version.parse(version)
  if (typeof range === 'string') range = Range.parse(range)

  return range.test(version)
}
const constants = require('./constants')

const symbols = {
  [constants.EQ]: '=',
  [constants.LT]: '<',
  [constants.LTE]: '<=',
  [constants.GT]: '>',
  [constants.GTE]: '>='
}

module.exports = class Comparator {
  constructor (operator, version) {
    this.operator = operator
    this.version = version
  }

  test (version) {
    const result = version.compare(this.version)

    switch (this.operator) {
      case constants.LT: return result < 0
      case constants.LTE: return result <= 0
      case constants.GT: return result > 0
      case constants.GTE: return result >= 0
      default: return result === 0
    }
  }

  toString () {
    return symbols[this.operator] + this.version
  }
}
module.exports = {
  EQ: 1,
  LT: 2,
  LTE: 3,
  GT: 4,
  GTE: 5
}
module.exports = class SemVerError extends Error {
  constructor (msg, code, fn = SemVerError) {
    super(`${code}: ${msg}`)
    this.code = code

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, fn)
    }
  }

  get name () {
    return 'SemVerError'
  }

  static INVALID_VERSION (msg, fn = SemVerError.INVALID_VERSION) {
    return new SemVerError(msg, 'INVALID_VERSION', fn)
  }

  static INVALID_RANGE (msg, fn = SemVerError.INVALID_RANGE) {
    return new SemVerError(msg, 'INVALID_RANGE', fn)
  }
}
const constants = require('./constants')
const errors = require('./errors')
const Version = require('./version')
const Comparator = require('./comparator')

const Range = module.exports = exports = class Range {
  constructor (comparators = []) {
    this.comparators = comparators
  }

  test (version) {
    for (const set of this.comparators) {
      let matches = true

      for (const comparator of set) {
        if (comparator.test(version)) continue
        matches = false
        break
      }

      if (matches) return true
    }

    return false
  }

  toString () {
    let result = ''
    let first = true

    for (const set of this.comparators) {
      if (first) first = false
      else result += ' || '

      result += set.join(' ')
    }

    return result
  }
}

exports.parse = function parse (input, state = { position: 0, partial: false }) {
  let i = state.position
  let c

  const unexpected = (expected) => {
    let msg

    if (i >= input.length) {
      msg = `Unexpected end of input in '${input}'`
    } else {
      msg = `Unexpected token '${input[i]}' in '${input}' at position ${i}`
    }

    if (expected) msg += `, ${expected}`

    throw errors.INVALID_VERSION(msg, unexpected)
  }

  const comparators = []

  while (i < input.length) {
    const set = []

    while (i < input.length) {
      c = input[i]

      let operator = constants.EQ

      if (c === '<') {
        operator = constants.LT
        c = input[++i]

        if (c === '=') {
          operator = constants.LTE
          c = input[++i]
        }
      } else if (c === '>') {
        operator = constants.GT
        c = input[++i]

        if (c === '=') {
          operator = constants.GTE
          c = input[++i]
        }
      } else if (c === '=') {
        c = input[++i]
      }

      const state = { position: i, partial: true }

      set.push(new Comparator(operator, Version.parse(input, state)))

      c = input[i = state.position]

      while (c === ' ') c = input[++i]

      if (c === '|' && input[i + 1] === '|') {
        c = input[i += 2]

        while (c === ' ') c = input[++i]

        break
      }

      if (c && c !== '<' && c !== '>') unexpected('expected \'||\', \'<\', or \'>\'')
    }

    if (set.length) comparators.push(set)
  }

  if (i < input.length && state.partial === false) unexpected('expected end of input')

  state.position = i

  return new Range(comparators)
}
const errors = require('./errors')

const Version = module.exports = exports = class Version {
  constructor (major, minor, patch, opts = {}) {
    const {
      prerelease = [],
      build = []
    } = opts

    this.major = major
    this.minor = minor
    this.patch = patch
    this.prerelease = prerelease
    this.build = build
  }

  compare (version) {
    return exports.compare(this, version)
  }

  toString () {
    let result = `${this.major}.${this.minor}.${this.patch}`

    if (this.prerelease.length) {
      result += '-' + this.prerelease.join('.')
    }

    if (this.build.length) {
      result += '+' + this.build.join('.')
    }

    return result
  }
}

exports.parse = function parse (input, state = { position: 0, partial: false }) {
  let i = state.position
  let c

  const unexpected = (expected) => {
    let msg

    if (i >= input.length) {
      msg = `Unexpected end of input in '${input}'`
    } else {
      msg = `Unexpected token '${input[i]}' in '${input}' at position ${i}`
    }

    if (expected) msg += `, ${expected}`

    throw errors.INVALID_VERSION(msg, unexpected)
  }

  const components = []

  while (components.length < 3) {
    c = input[i]

    if (components.length > 0) {
      if (c === '.') c = input[++i]
      else unexpected('expected \'.\'')
    }

    if (c === '0') {
      components.push(0)

      i++
    } else if (c >= '1' && c <= '9') {
      let j = 0
      do c = input[i + ++j]
      while (c >= '0' && c <= '9')

      components.push(parseInt(input.substring(i, i + j)))

      i += j
    } else unexpected('expected /[0-9]/')
  }

  const prerelease = []

  if (input[i] === '-') {
    i++

    while (true) {
      c = input[i]

      let tag = ''
      let j = 0

      while (c >= '0' && c <= '9') c = input[i + ++j]

      let isNumeric = false

      if (j) {
        tag += input.substring(i, i + j)

        c = input[i += j]

        isNumeric = tag[0] !== '0' || tag.length === 1
      }

      j = 0

      while ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c === '-') c = input[i + ++j]

      if (j) {
        tag += input.substring(i, i + j)

        c = input[i += j]
      } else if (!isNumeric) unexpected('expected /[a-zA-Z-]/')

      prerelease.push(tag)

      if (c === '.') c = input[++i]
      else break
    }
  }

  const build = []

  if (input[i] === '+') {
    i++

    while (true) {
      c = input[i]

      let tag = ''
      let j = 0

      while ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c === '-') c = input[i + ++j]

      if (j) {
        tag += input.substring(i, i + j)

        c = input[i += j]
      } else unexpected('expected /[0-9a-zA-Z-]/')

      build.push(tag)

      if (c === '.') c = input[++i]
      else break
    }
  }

  if (i < input.length && state.partial === false) unexpected('expected end of input')

  state.position = i

  return new Version(...components, { prerelease, build })
}

const integer = /^[0-9]+$/

exports.compare = function compare (a, b) {
  if (a.major > b.major) return 1
  if (a.major < b.major) return -1

  if (a.minor > b.minor) return 1
  if (a.minor < b.minor) return -1

  if (a.patch > b.patch) return 1
  if (a.patch < b.patch) return -1

  if (a.prerelease.length === 0) return b.prerelease.length === 0 ? 0 : 1
  if (b.prerelease.length === 0) return -1

  let i = 0
  do {
    let x = a.prerelease[i]
    let y = b.prerelease[i]

    if (x === undefined) return y === undefined ? 0 : -1
    if (y === undefined) return 1

    if (x === y) continue

    const xInt = integer.test(x)
    const yInt = integer.test(y)

    if (xInt && yInt) {
      x = +x
      y = +y
    } else {
      if (xInt) return -1
      if (yInt) return 1
    }

    return x > y ? 1 : -1
  } while (++i)
}
{
  "name": "bare-semver",
  "version": "1.0.1",
  "description": "Minimal semantic versioning library for Bare",
  "exports": {
    ".": "./index.js",
    "./package": "./package.json",
    "./constants": "./lib/constants.js",
    "./errors": "./lib/errors.js",
    "./version": "./lib/version.js",
    "./range": "./lib/range.js",
    "./comparator": "./lib/comparator.js"
  },
  "files": [
    "index.js",
    "lib"
  ],
  "scripts": {
    "test": "standard && bare test.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/holepunchto/bare-semver.git"
  },
  "author": "Holepunch",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/holepunchto/bare-semver/issues"
  },
  "homepage": "https://github.com/holepunchto/bare-semver#readme",
  "devDependencies": {
    "brittle": "^3.2.1",
    "standard": "^17.0.0"
  }
}
const stream = require('streamx')

const defaultEncoding = 'utf8'

module.exports = exports = stream.Stream

exports.pipeline = stream.pipeline

exports.isStream = stream.isStream
exports.isEnded = stream.isEnded
exports.isFinished = stream.isFinished
exports.isDisturbed = stream.isDisturbed

exports.getStreamError = stream.getStreamError

exports.Stream = exports

exports.Readable = class Readable extends stream.Readable {
  constructor(opts = {}) {
    super({
      ...opts,
      byteLength: null,
      byteLengthReadable: null,
      map: null,
      mapReadable: null
    })

    if (this._construct) this._open = this._construct

    if (this._read !== stream.Readable.prototype._read) {
      this._read = read.bind(this, this._read)
    }

    if (this._destroy !== stream.Stream.prototype._destroy) {
      this._destroy = destroy.bind(this, this._destroy)
    }
  }

  push(chunk, encoding) {
    if (typeof chunk === 'string') {
      chunk = Buffer.from(chunk, encoding || defaultEncoding)
    }

    return super.push(chunk)
  }

  unshift(chunk, encoding) {
    if (typeof chunk === 'string') {
      chunk = Buffer.from(chunk, encoding || defaultEncoding)
    }

    super.unshift(chunk)
  }
}

exports.Writable = class Writable extends stream.Writable {
  constructor(opts = {}) {
    super({
      ...opts,
      byteLength: null,
      byteLengthWritable,
      map: null,
      mapWritable: null
    })

    if (this._construct) this._open = this._construct

    if (this._write !== stream.Writable.prototype._write) {
      this._write = write.bind(this, this._write)
    }

    if (this._destroy !== stream.Stream.prototype._destroy) {
      this._destroy = destroy.bind(this, this._destroy)
    }
  }

  write(chunk, encoding, cb) {
    if (typeof encoding === 'function') {
      cb = encoding
      encoding = null
    }

    if (typeof chunk === 'string') {
      encoding = encoding || defaultEncoding
      chunk = Buffer.from(chunk, encoding)
    } else {
      encoding = 'buffer'
    }

    const result = super.write({ chunk, encoding })

    if (cb) stream.Writable.drained(this).then(() => cb(null), cb)

    return result
  }

  end(chunk, encoding, cb) {
    if (typeof chunk === 'function') {
      cb = chunk
      chunk = null
    } else if (typeof encoding === 'function') {
      cb = encoding
      encoding = null
    }

    if (typeof chunk === 'string') {
      encoding = encoding || defaultEncoding
      chunk = Buffer.from(chunk, encoding || defaultEncoding)
    } else {
      encoding = 'buffer'
    }

    const result =
      chunk !== undefined && chunk !== null
        ? super.end({ chunk, encoding })
        : super.end()

    if (cb) this.once('end', () => cb(null))

    return result
  }
}

exports.Duplex = class Duplex extends stream.Duplex {
  constructor(opts = {}) {
    super({
      ...opts,
      byteLength: null,
      byteLengthReadable: null,
      byteLengthWritable,
      map: null,
      mapReadable: null,
      mapWritable: null
    })

    if (this._construct) this._open = this._construct

    if (this._read !== stream.Readable.prototype._read) {
      this._read = read.bind(this, this._read)
    }

    if (this._write !== stream.Duplex.prototype._write) {
      this._write = write.bind(this, this._write)
    }

    if (this._destroy !== stream.Stream.prototype._destroy) {
      this._destroy = destroy.bind(this, this._destroy)
    }
  }

  push(chunk, encoding) {
    if (typeof chunk === 'string') {
      chunk = Buffer.from(chunk, encoding || defaultEncoding)
    }

    return super.push(chunk)
  }

  unshift(chunk, encoding) {
    if (typeof chunk === 'string') {
      chunk = Buffer.from(chunk, encoding || defaultEncoding)
    }

    super.unshift(chunk)
  }

  write(chunk, encoding, cb) {
    if (typeof encoding === 'function') {
      cb = encoding
      encoding = null
    }

    if (typeof chunk === 'string') {
      encoding = encoding || defaultEncoding
      chunk = Buffer.from(chunk, encoding)
    } else {
      encoding = 'buffer'
    }

    const result = super.write({ chunk, encoding })

    if (cb) stream.Writable.drained(this).then(() => cb(null), cb)

    return result
  }

  end(chunk, encoding, cb) {
    if (typeof chunk === 'function') {
      cb = chunk
      chunk = null
    } else if (typeof encoding === 'function') {
      cb = encoding
      encoding = null
    }

    if (typeof chunk === 'string') {
      encoding = encoding || defaultEncoding
      chunk = Buffer.from(chunk, encoding)
    } else {
      encoding = 'buffer'
    }

    const result =
      chunk !== undefined && chunk !== null
        ? super.end({ chunk, encoding })
        : super.end()

    if (cb) this.once('end', () => cb(null))

    return result
  }
}

exports.Transform = class Transform extends stream.Transform {
  constructor(opts = {}) {
    super({
      ...opts,
      byteLength: null,
      byteLengthReadable: null,
      byteLengthWritable,
      map: null,
      mapReadable: null,
      mapWritable: null
    })

    if (this._transform !== stream.Transform.prototype._transform) {
      this._transform = transform.bind(this, this._transform)
    } else {
      this._transform = passthrough
    }
  }

  push(chunk, encoding) {
    if (typeof chunk === 'string') {
      chunk = Buffer.from(chunk, encoding || defaultEncoding)
    }

    return super.push(chunk)
  }

  unshift(chunk, encoding) {
    if (typeof chunk === 'string') {
      chunk = Buffer.from(chunk, encoding || defaultEncoding)
    }

    super.unshift(chunk)
  }

  write(chunk, encoding, cb) {
    if (typeof encoding === 'function') {
      cb = encoding
      encoding = null
    }

    if (typeof chunk === 'string') {
      encoding = encoding || defaultEncoding
      chunk = Buffer.from(chunk, encoding)
    } else {
      encoding = 'buffer'
    }

    const result = super.write({ chunk, encoding })

    if (cb) stream.Writable.drained(this).then(() => cb(null), cb)

    return result
  }

  end(chunk, encoding, cb) {
    if (typeof chunk === 'function') {
      cb = chunk
      chunk = null
    } else if (typeof encoding === 'function') {
      cb = encoding
      encoding = null
    }

    if (typeof chunk === 'string') {
      encoding = encoding || defaultEncoding
      chunk = Buffer.from(chunk, encoding)
    } else {
      encoding = 'buffer'
    }

    const result =
      chunk !== undefined && chunk !== null
        ? super.end({ chunk, encoding })
        : super.end()

    if (cb) this.once('end', () => cb(null))

    return result
  }
}

exports.PassThrough = class PassThrough extends exports.Transform {}

exports.finished = function finished(stream, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts
    opts = {}
  }

  if (!opts) opts = {}

  const { cleanup = false } = opts

  const done = () => {
    cb(exports.getStreamError(stream, { all: true }))

    if (cleanup) detach()
  }

  const detach = () => {
    stream.off('close', done)
    stream.off('error', noop)
  }

  if (stream.destroyed) {
    done()
  } else {
    stream.on('close', done)
    stream.on('error', noop)
  }

  return detach
}

function read(read, cb) {
  read.call(this, 65536)

  cb(null)
}

function write(write, data, cb) {
  write.call(this, data.chunk, data.encoding, cb)
}

function transform(transform, data, cb) {
  transform.call(this, data.chunk, data.encoding, cb)
}

function destroy(destroy, cb) {
  destroy.call(this, exports.getStreamError(this), cb)
}

function passthrough(data, cb) {
  cb(null, data.chunk)
}

function byteLengthWritable(data) {
  return data.chunk.byteLength
}

function noop() {}
{
  "name": "bare-stream",
  "version": "2.6.5",
  "description": "Streaming data for JavaScript",
  "exports": {
    ".": {
      "types": "./index.d.ts",
      "default": "./index.js"
    },
    "./package": "./package.json",
    "./promises": "./promises.js",
    "./web": "./web.js",
    "./global": "./global.js"
  },
  "files": [
    "index.js",
    "index.d.ts",
    "promises.js",
    "web.js",
    "global.js"
  ],
  "scripts": {
    "test": "prettier . --check && bare test.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/holepunchto/bare-stream.git"
  },
  "author": "Holepunch",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/holepunchto/bare-stream/issues"
  },
  "homepage": "https://github.com/holepunchto/bare-stream#readme",
  "dependencies": {
    "streamx": "^2.21.0"
  },
  "devDependencies": {
    "bare-buffer": "^3.0.0",
    "bare-events": "^2.5.4",
    "brittle": "^3.5.2",
    "prettier": "^3.3.3",
    "prettier-config-standard": "^7.0.0"
  },
  "peerDependencies": {
    "bare-buffer": "*",
    "bare-events": "*"
  },
  "peerDependenciesMeta": {
    "bare-buffer": {
      "optional": true
    },
    "bare-events": {
      "optional": true
    }
  }
}
module.exports = require.addon()
const path = require('bare-path')
const binding = require('./binding')
const errors = require('./lib/errors')
const URLSearchParams = require('./lib/url-search-params')

const kind = Symbol.for('bare.url.kind')

const isWindows = Bare.platform === 'win32'

module.exports = exports = class URL {
  static get [kind]() {
    return 0 // Compatibility version
  }

  constructor(input, base, opts = {}) {
    if (arguments.length === 0) throw errors.INVALID_URL()

    input = String(input)

    if (base !== undefined) base = String(base)

    this._components = new Uint32Array(8)

    this._parse(input, base, opts.throw !== false)

    if (this._href) this._params = new URLSearchParams(this.search, this)
  }

  get [kind]() {
    return URL[kind]
  }

  // https://url.spec.whatwg.org/#dom-url-href

  get href() {
    return this._href
  }

  set href(value) {
    this._update(value)

    this._params._parse(this.search)
  }

  // https://url.spec.whatwg.org/#dom-url-protocol

  get protocol() {
    return this._slice(0, this._components[0]) + ':'
  }

  set protocol(value) {
    this._update(
      this._replace(value.replace(/:+$/, ''), 0, this._components[0])
    )
  }

  // https://url.spec.whatwg.org/#dom-url-username

  get username() {
    return this._slice(this._components[0] + 3 /* :// */, this._components[1])
  }

  set username(value) {
    if (cannotHaveCredentialsOrPort(this)) {
      return
    }

    if (this.username === '') value += '@'

    this._update(
      this._replace(
        value,
        this._components[0] + 3 /* :// */,
        this._components[1]
      )
    )
  }

  // https://url.spec.whatwg.org/#dom-url-password

  get password() {
    return this._href.slice(
      this._components[1] + 1 /* : */,
      this._components[2] - 1 /* @ */
    )
  }

  set password(value) {
    if (cannotHaveCredentialsOrPort(this)) {
      return
    }

    let start = this._components[1] + 1 /* : */
    let end = this._components[2] - 1 /* @ */

    if (this.password === '') {
      value = ':' + value
      start--
    }

    if (this.username === '') {
      value += '@'
      end++
    }

    this._update(this._replace(value, start, end))
  }

  // https://url.spec.whatwg.org/#dom-url-host

  get host() {
    return this._slice(this._components[2], this._components[5])
  }

  set host(value) {
    if (hasOpaquePath(this)) {
      return
    }

    this._update(
      this._replace(
        value,
        this._components[2],
        this._components[value.includes(':') ? 5 : 3]
      )
    )
  }

  // https://url.spec.whatwg.org/#dom-url-hostname

  get hostname() {
    return this._slice(this._components[2], this._components[3])
  }

  set hostname(value) {
    if (hasOpaquePath(this)) {
      return
    }

    this._update(this._replace(value, this._components[2], this._components[3]))
  }

  // https://url.spec.whatwg.org/#dom-url-port

  get port() {
    return this._slice(this._components[3] + 1 /* : */, this._components[5])
  }

  set port(value) {
    if (cannotHaveCredentialsOrPort(this)) {
      return
    }

    let start = this._components[3] + 1 /* : */

    if (this.port === '') {
      value = ':' + value
      start--
    }

    this._update(this._replace(value, start, this._components[5]))
  }

  // https://url.spec.whatwg.org/#dom-url-pathname

  get pathname() {
    return this._slice(this._components[5], this._components[6] - 1 /* ? */)
  }

  set pathname(value) {
    if (hasOpaquePath(this)) {
      return
    }

    if (value[0] !== '/' && value[0] !== '\\') {
      value = '/' + value
    }

    this._update(
      this._replace(value, this._components[5], this._components[6] - 1 /* ? */)
    )
  }

  // https://url.spec.whatwg.org/#dom-url-search

  get search() {
    return this._slice(
      this._components[6] - 1 /* ? */,
      this._components[7] - 1 /* # */
    )
  }

  set search(value) {
    if (value && value[0] !== '?') value = '?' + value

    this._update(
      this._replace(
        value,
        this._components[6] - 1 /* ? */,
        this._components[7] - 1 /* # */
      )
    )

    this._params._parse(this.search)
  }

  // https://url.spec.whatwg.org/#dom-url-searchparams

  get searchParams() {
    return this._params
  }

  // https://url.spec.whatwg.org/#dom-url-hash

  get hash() {
    return this._slice(this._components[7] - 1 /* # */)
  }

  set hash(value) {
    if (value && value[0] !== '#') value = '#' + value

    this._update(this._replace(value, this._components[7] - 1 /* # */))
  }

  toString() {
    return this._href
  }

  toJSON() {
    return this._href
  }

  [Symbol.for('bare.inspect')]() {
    return {
      __proto__: { constructor: URL },

      href: this.href,
      protocol: this.protocol,
      username: this.username,
      password: this.password,
      host: this.host,
      hostname: this.hostname,
      port: this.port,
      pathname: this.pathname,
      search: this.search,
      searchParams: this.searchParams,
      hash: this.hash
    }
  }

  _slice(start, end = this._href.length) {
    return this._href.slice(start, end)
  }

  _replace(replacement, start, end = this._href.length) {
    return this._slice(0, start) + replacement + this._slice(end)
  }

  _parse(input, base, shouldThrow) {
    try {
      this._href = binding.parse(
        String(input),
        base ? String(base) : null,
        this._components,
        shouldThrow
      )
    } catch (err) {
      if (err instanceof TypeError) throw err

      throw errors.INVALID_URL()
    }
  }

  _update(input) {
    try {
      this._parse(input, null, true)
    } catch (err) {
      if (err instanceof TypeError) throw err
    }
  }
}

// https://url.spec.whatwg.org/#url-opaque-path
function hasOpaquePath(url) {
  return url.pathname[0] !== '/'
}

// https://url.spec.whatwg.org/#cannot-have-a-username-password-port
function cannotHaveCredentialsOrPort(url) {
  return url.hostname === '' || url.protocol === 'file:'
}

const URL = exports

exports.URL = URL
exports.URLSearchParams = URLSearchParams

exports.errors = errors

exports.isURL = function isURL(value) {
  if (value instanceof URL) return true

  return (
    typeof value === 'object' && value !== null && value[kind] === URL[kind]
  )
}

// https://url.spec.whatwg.org/#dom-url-parse
exports.parse = function parse(input, base) {
  const url = new URL(input, base, { throw: false })
  return url._href ? url : null
}

// https://url.spec.whatwg.org/#dom-url-canparse
exports.canParse = function canParse(input, base) {
  return binding.canParse(String(input), base ? String(base) : null)
}

exports.fileURLToPath = function fileURLToPath(url) {
  if (typeof url === 'string') {
    url = new URL(url)
  }

  if (url.protocol !== 'file:') {
    throw errors.INVALID_URL_SCHEME('The URL must use the file: protocol')
  }

  if (isWindows) {
    if (/%2f|%5c/i.test(url.pathname)) {
      throw errors.INVALID_FILE_URL_PATH(
        'The file: URL path must not include encoded \\ or / characters'
      )
    }
  } else {
    if (url.hostname) {
      throw errors.INVALID_FILE_URL_HOST(
        "The file: URL host must be 'localhost' or empty"
      )
    }

    if (/%2f/i.test(url.pathname)) {
      throw errors.INVALID_FILE_URL_PATH(
        'The file: URL path must not include encoded / characters'
      )
    }
  }

  const pathname = path.normalize(decodeURIComponent(url.pathname))

  if (isWindows) {
    if (url.hostname) return '\\\\' + url.hostname + pathname

    const letter = pathname.charCodeAt(1) | 0x20

    if (
      letter < 0x61 /* a */ ||
      letter > 0x7a /* z */ ||
      pathname.charCodeAt(2) !== 0x3a /* : */
    ) {
      throw errors.INVALID_FILE_URL_PATH('The file: URL path must be absolute')
    }

    return pathname.slice(1)
  }

  return pathname
}

exports.pathToFileURL = function pathToFileURL(pathname) {
  let resolved = path.resolve(pathname)

  if (pathname[pathname.length - 1] === '/') {
    resolved += '/'
  } else if (isWindows && pathname[pathname.length - 1] === '\\') {
    resolved += '\\'
  }

  resolved = resolved
    .replaceAll('%', '%25') // Must be first
    .replaceAll('#', '%23')
    .replaceAll('?', '%3f')
    .replaceAll('\n', '%0a')
    .replaceAll('\r', '%0d')
    .replaceAll('\t', '%09')

  if (!isWindows) {
    resolved = resolved.replaceAll('\\', '%5c')
  }

  return new URL('file:' + resolved)
}

exports.format = function format(parts) {
  const {
    protocol,
    auth,
    host,
    hostname,
    port,
    pathname,
    search,
    query,
    hash,
    slashes
  } = parts

  let result = ''

  if (typeof protocol === 'string') {
    result += protocol

    if (protocol[protocol.length - 1] !== ':') {
      result += ':'
    }

    if (slashes === true || /https?|ftp|gopher|file/.test(protocol)) {
      result += '//'
    }
  }

  if (typeof auth === 'string') {
    if (host || hostname) result += auth + '@'
  }

  if (typeof host === 'string') result += host
  else {
    result += hostname

    if (port) result += ':' + port
  }

  if (typeof pathname === 'string' && pathname !== '') {
    if (pathname[0] !== '/') result += '/'
    result += pathname
  }

  if (typeof search === 'string') {
    if (search[0] !== '?') result += '?'
    result += search
  } else if (typeof query === 'object' && query !== null) {
    result += '?' + new URLSearchParams(query)
  }

  if (typeof hash === 'string') {
    if (hash[0] !== '#') result += '#'
    result += hash
  }

  return result
}
module.exports = class URLError extends Error {
  constructor(msg, code, fn = URLError) {
    super(`${code}: ${msg}`)
    this.code = code

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, fn)
    }
  }

  get name() {
    return 'URLError'
  }

  static INVALID_URL(msg = 'Invalid URL') {
    return new URLError(msg, 'INVALID_URL', URLError.INVALID_URL)
  }

  static INVALID_URL_SCHEME(msg = 'Invalid URL') {
    return new URLError(msg, 'INVALID_URL_SCHEME', URLError.INVALID_URL_SCHEME)
  }

  static INVALID_FILE_URL_HOST(msg = 'Invalid file: URL host') {
    return new URLError(
      msg,
      'INVALID_FILE_URL_HOST',
      URLError.INVALID_FILE_URL_HOST
    )
  }

  static INVALID_FILE_URL_PATH(msg = 'Invalid file: URL path') {
    return new URLError(
      msg,
      'INVALID_FILE_URL_PATH',
      URLError.INVALID_FILE_URL_PATH
    )
  }
}
module.exports = class URLSearchParams {
  static _urls = new WeakMap()

  // https://url.spec.whatwg.org/#dom-urlsearchparams-urlsearchparams
  constructor(init, url = null) {
    this._params = new Map()

    if (url) URLSearchParams._urls.set(this, url)

    if (typeof init === 'string') {
      this._parse(init)
    } else if (init) {
      for (const [name, value] of typeof init[Symbol.iterator] === 'function'
        ? init
        : Object.entries(init)) {
        this.append(name, value)
      }
    }
  }

  // https://url.spec.whatwg.org/#dom-urlsearchparams-size
  get size() {
    return this._params.length
  }

  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
  append(name, value = null) {
    if (value === null) return

    let list = this._params.get(name)

    if (list === undefined) {
      list = []
      this._params.set(name, list)
    }

    list.push(value)

    this._update()
  }

  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
  delete(name, value = null) {
    if (value === null) this._params.delete(name)
    else {
      let list = this._params.get(name)

      if (list === undefined) return

      list = list.filter((found) => found !== value)

      if (list.length === 0) this._params.delete(name)
      else this._params.set(name, list)
    }

    this._update()
  }

  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
  get(name) {
    const list = this._params.get(name)

    if (list === undefined) return null

    return list[0]
  }

  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
  getAll(name) {
    const list = this._params.get(name)

    if (list === undefined) return []

    return Array.from(list)
  }

  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
  has(name, value = null) {
    const list = this._params.get(name)

    if (list === undefined) return false

    if (value === null) return true

    return list.includes(value)
  }

  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
  set(name, value = null) {
    if (value === null) this._params.delete(name)
    else this._params.set(name, [value])

    this._update()
  }

  toString() {
    return this._serialize()
  }

  toJSON() {
    return [...this]
  }

  *[Symbol.iterator]() {
    for (const [name, values] of this._params) {
      for (const value of values) yield [name, value]
    }
  }

  [Symbol.for('bare.inspect')]() {
    const object = {
      __proto__: { constructor: URLSearchParams }
    }

    for (const [name, values] of this._params) {
      if (values.length === 1) object[name] = values[0]
      else object[name] = values
    }

    return object
  }

  // https://url.spec.whatwg.org/#concept-urlsearchparams-update
  _update() {
    const url = URLSearchParams._urls.get(this)

    if (url === undefined) return

    url.search = this._serialize()
  }

  // https://url.spec.whatwg.org/#concept-urlencoded-parser
  _parse(input) {
    if (input[0] === '?') input = input.substring(1)

    this._params = new Map()

    for (const sequence of input.split('&')) {
      if (sequence.length === 0) continue

      let i = sequence.indexOf('=')
      if (i === -1) i = sequence.length

      const name = decodeURIComponent(sequence.substring(0, i))
      const value = decodeURIComponent(
        sequence.substring(i + 1, sequence.length)
      )

      let list = this._params.get(name)

      if (list === undefined) {
        list = []
        this._params.set(name, list)
      }

      list.push(value)
    }
  }

  // https://url.spec.whatwg.org/#concept-urlencoded-serializer
  _serialize() {
    let output = ''

    for (let [name, values] of this._params) {
      name = encodeURIComponent(name)

      for (const value of values) {
        if (output) output += '&'

        output += name + '=' + encodeURIComponent(value)
      }
    }

    return output
  }
}
{
  "name": "bare-url",
  "version": "2.3.1",
  "description": "WHATWG URL implementation for JavaScript",
  "exports": {
    "./package": "./package.json",
    ".": {
      "types": "./index.d.ts",
      "default": "./index.js"
    },
    "./global": {
      "types": "./global.d.ts",
      "default": "./global.js"
    }
  },
  "files": [
    "index.js",
    "index.d.ts",
    "global.js",
    "global.d.ts",
    "binding.c",
    "binding.js",
    "CMakeLists.txt",
    "lib",
    "prebuilds"
  ],
  "addon": true,
  "scripts": {
    "test": "prettier . --check && bare test.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/holepunchto/bare-url.git"
  },
  "author": "Holepunch",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/holepunchto/bare-url/issues"
  },
  "homepage": "https://github.com/holepunchto/bare-url",
  "dependencies": {
    "bare-path": "^3.0.0"
  },
  "devDependencies": {
    "brittle": "^3.3.2",
    "cmake-bare": "^1.1.6",
    "cmake-fetch": "^1.0.0",
    "prettier": "^3.3.3",
    "prettier-config-standard": "^7.0.0"
  }
}
ELF          >            @       p         @ 8 
 @         @       @       @       0      0                                           B      B                   B      R      R                             [     {     {                              ]                                          [     {     {                        Rtd   [     {     {           @             Ptd   +      +      +      t      t             Qtd                                                         p      p      p                                    GNU X                                                                      ,                       F   "                                                                                                                                                                                                  	                                          $                     ;                     J                     Y                     a                                                               ]                                          0      L       i    P     
      		     	     -       U     pS                                         j                            `      /      h    p                p             )          ]                       	    0	            	    P	     	                 	       o           N      i	     
     #                                                     ^                L                k                          p                             P                 I    p      6       e          '           @                 `     I               _       m     S             :	    	     #       a                      @                0             ,                                 .           5          @            Y                           6                        _                w                ]          L                       +	    `	            	    `
     #                 P          P                       Z           0                 `                                       	       A                 
    `      o                      v	    0
     #       @          	      #          E                *                 $                       j    0      F           `      *          `      2      @                 	    
                             E    @                      T                     \	    	             w                           A          P      M                P      '          3       F           #       )          4                                                   %      X          k       	    
     /                        9          T      K	    	     &       ~          K                        w                    P                                                                                                                                    	         ui	   	        	                                 
   @  "       @  @     "              (     @ 	 a         !, `   H                `   	    	      h P B         @ 	                  
    $%0 P          -R  @           &   )   /   7   9   ;   >   B   I   J   M   Q   T   [   ^   c   j   o   r   s   Hc7KT&r`I.6#\&?&[k*X[m'E2;!Tn[\~@`.R9CLa\Eu,F.J668JgR/FHDw05mZmuVW4,A)PH4n4MH,~"qj_,l~?J#pc*-/dIR(u`
fq6c~lzXJ;ZK1c/\xr uL __gmon_start__ _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize bare_get_module_name_v0 bare_register_module_v0 js_create_function js_set_named_property js_get_callback_info js_get_value_bool js_is_string js_get_value_string_utf8 malloc strlen free js_create_string_utf8 js_get_typedarray_info js_throw_error js_get_boolean realloc memcpy utf8_string_append_literal utf8_string_append_character utf8_string_append_view utf8_string_append memmove snprintf utf_endianness utf_is_le utf_is_be utf_swap_uint16 utf_swap_uint32 ascii_validate latin1_convert_to_utf8 latin1_convert_to_utf16le latin1_convert_to_utf32 latin1_length_from_utf8 latin1_length_from_utf16le latin1_length_from_utf32 utf8_convert_to_latin1 utf8_convert_to_utf16le utf8_convert_to_utf32 utf8_length_from_latin1 utf8_length_from_utf16le utf8_length_from_utf32 utf8_string_init utf8_string_view_init utf8_string_destroy utf8_string_reserve utf8_string_shrink_to_fit utf8_string_view utf8_string_clear utf8_string_empty utf8_string_view_empty utf8_string_copy utf8_string_view_copy utf8_string_prepend utf8_string_prepend_view utf8_string_prepend_character utf8_string_prepend_literal utf8_string_insert utf8_string_insert_view utf8_string_insert_character utf8_string_insert_literal utf8_string_replace utf8_string_replace_view utf8_string_replace_character utf8_string_replace_literal utf8_string_erase utf8_string_concat utf8_string_view_concat utf8_string_concat_view utf8_string_view_concat_view utf8_string_concat_character utf8_string_view_concat_character utf8_string_concat_literal utf8_string_view_concat_literal utf8_string_compare strncmp utf8_string_view_compare utf8_string_compare_literal utf8_string_view_compare_literal utf8_string_substring utf8_string_view_substring utf8_string_substring_copy utf8_string_view_substring_copy utf8_string_index_of_character utf8_string_view_index_of_character utf8_string_last_index_of_character utf8_string_view_last_index_of_character utf8_validate utf16le_convert_to_latin1 utf16le_convert_to_utf8 utf16le_convert_to_utf32 utf16_length_from_latin1 utf16_length_from_utf8 utf16_length_from_utf32 utf16le_validate utf32_convert_to_latin1 utf32_convert_to_utf8 utf32_convert_to_utf16le utf32_length_from_latin1 utf32_length_from_utf8 utf32_length_from_utf16le utf32_validate url_init url_destroy url_get_href url_get_scheme url_get_username url_get_password url_get_host url_get_port url_get_path url_get_query url_get_fragment url_parse libc.so.6 GLIBC_2.2.5 GLIBC_2.14 bare-url@2.bare    {             S      {            `S                       `}                   h}                   p}                   x}                                                                                                                          	                   
                                                                                                                                                                                                            (                   0        j           8        o           @                   H                   P                                                                                                                                                                                   ;  $<  =  R=  ~=  =  W>  >  >  >  y;  y;  N?  ?  @  <A  A  A  B  B  y  A  J  MK  tK  Y  K  >  H  H  H  H  H  H  H  H  H  H  H  >  H  H  H  H  H  H  H  H  H  H  H  H  H  H  H  >  7J                 x                       P         P         P      %00%01%02%03%04%05%06%07%08%09%0A%0B%0C%0D%0E%0F%10%11%12%13%14%15%16%17%18%19%1A%1B%1C%1D%1E%1F%20%21%22%23%24%25%26%27%28%29%2A%2B%2C%2D%2E%2F%30%31%32%33%34%35%36%37%38%39%3A%3B%3C%3D%3E%3F%40%41%42%43%44%45%46%47%48%49%4A%4B%4C%4D%4E%4F%50%51%52%53%54%55%56%57%58%59%5A%5B%5C%5D%5E%5F%60%61%62%63%64%65%66%67%68%69%6A%6B%6C%6D%6E%6F%70%71%72%73%74%75%76%77%78%79%7A%7B%7C%7D%7E%7F%80%81%82%83%84%85%86%87%88%89%8A%8B%8C%8D%8E%8F%90%91%92%93%94%95%96%97%98%99%9A%9B%9C%9D%9E%9F%A0%A1%A2%A3%A4%A5%A6%A7%A8%A9%AA%AB%AC%AD%AE%AF%B0%B1%B2%B3%B4%B5%B6%B7%B8%B9%BA%BB%BC%BD%BE%BF%C0%C1%C2%C3%C4%C5%C6%C7%C8%C9%CA%CB%CC%CD%CE%CF%D0%D1%D2%D3%D4%D5%D6%D7%D8%D9%DA%DB%DC%DD%DE%DF%E0%E1%E2%E3%E4%E5%E6%E7%E8%E9%EA%EB%EC%ED%EE%EF%F0%F1%F2%F3%F4%F5%F6%F7%F8%F9%FA%FB%FC%FD%FE%FF                                                 	       
                          
                                                                                                                                                         P     P        %d // canParse bare-url@2.3.1 :: :// Invalid URL %40 %x Invalid base URL parse                                                            )   x                        h                &  	   x                     $    R  ~    W        y  y  N      <          $     M  t                                                               7                 x                       P         P         P      %00%01%02%03%04%05%06%07%08%09%0A%0B%0C%0D%0E%0F%10%11%12%13%14%15%16%17%18%19%1A%1B%1C%1D%1E%1F%20%21%22%23%24%25%26%27%28%29%2A%2B%2C%2D%2E%2F%30%31%32%33%34%35%36%37%38%39%3A%3B%3C%3D%3E%3F%40%41%42%43%44%45%46%47%48%49%4A%4B%4C%4D%4E%4F%50%51%52%53%54%55%56%57%58%59%5A%5B%5C%5D%5E%5F%60%61%62%63%64%65%66%67%68%69%6A%6B%6C%6D%6E%6F%70%71%72%73%74%75%76%77%78%79%7A%7B%7C%7D%7E%7F%80%81%82%83%84%85%86%87%88%89%8A%8B%8C%8D%8E%8F%90%91%92%93%94%95%96%97%98%99%9A%9B%9C%9D%9E%9F%A0%A1%A2%A3%A4%A5%A6%A7%A8%A9%AA%AB%AC%AD%AE%AF%B0%B1%B2%B3%B4%B5%B6%B7%B8%B9%BA%BB%BC%BD%BE%BF%C0%C1%C2%C3%C4%C5%C6%C7%C8%C9%CA%CB%CC%CD%CE%CF%D0%D1%D2%D3%D4%D5%D6%D7%D8%D9%DA%DB%DC%DD%DE%DF%E0%E1%E2%E3%E4%E5%E6%E7%E8%E9%EA%EB%EC%ED%EE%EF%F0%F1%F2%F3%F4%F5%F6%F7%F8%F9%FA%FB%FC%FD%FE%FF                                                 	       
                          
                                                                                                                                                         P     P        ;p  m   '    '    L(    ,+  $  \-  t  m    ln    |p  ,                    4    L    d    |  <    |            \    l    |  $    T  <  l  ,            ,    <    L    l  ,  <  l                    	    L	    	    	    $
    l
    
    
    D          L  ,    |      <      l      \      \  <          $  ,  t            d  L          $    D  l  l                    T  <  l  l                    |          ,  \  D    \    t          |        ,        <    l  4    L    d    |          <    l              $    T  l   ,    <"   \: |  :          zR x        $             ,   4   $      BBA D0 ABBL   d   p$     ABB B(B0A8G8A0B(B BBA      L       '  '   ABB B(B0A8G8A0B(B BBA      L     (  O@   ABB B(B0A8G3@8A0B(B BBA         T  h             L   l  i     ABB B(B0A8A@8A0B(B BBAA@    l     Hk     ABB B(B0A8Dl8A0B(B BBAEE8A0B(B BBAA          ,    T           L   D  @     ABB B(B0A8D`q8A0B(B BBAA`                           x                  p                  h                  `                  X  Z              $    5             <                 T  @               l                   `                  X             ,     P     ABA BA                      ,          ABA BA        ,                 D                  \    T             t  @                  8                  0             <     8      ABB B(A0(B BBA      <       j    ABB B(A0Z(B BBA         <                  T    	              l    	                             <           BBB B(A0(B BBB      D           ABB B(B0A8A@8A0B(B BBAD   $  0      ABB B(B0A8A@8A0B(B BBAD   l        ABB B(B0A8A@8A0B(B BBAD           ABB B(B0A8A@8A0B(B BBAD     8     ABB B(B0A8A@8A0B(B BBAD   D        ABB B(B0A8A@8A0B(B BBAD       	   ABB B(B0A8A@8A0B(B BBAD           ABB B(B0A8A@8A0B(B BBAL     H     ABB B(B0A8A@8A0B(B BBA       L   l    A   ABB B(B0A8DP(8A0B(B BBA       L       P   ABB B(B0A8DP78A0B(B BBA       L   	    2   ABB B(B0A8DP8A0B(B BBA       L   \	    T   ABB B(B0A8DP;8A0B(B BBA       L   	    ^   ABB B(B0A8DPE8A0B(B BBA       L   	  (  o   ABB B(B0A8D`V8A0B(B BBA       L   L
  H  E   ABB B(B0A8DP,8A0B(B BBA       L   
  H     ABB B(B0A8D`h8A0B(B BBA       $   
    L    BAA DABL       N   ABB B(B0A8A@88A0B(B BBA       L   d    M   ABB B(B0A8A@78A0B(B BBA       L       L   ABB B(B0A8A@68A0B(B BBA       L       k   ABB B(B0A8DPR8A0B(B BBA       L   T    /   ABB B(B0A8A@8A0B(B BBA       L       %   ABB B(B0A8DP8A0B(B BBA       L       P   ABB B(B0A8A@:8A0B(B BBA       L   D    ]   ABB B(B0A8DPD8A0B(B BBA              6    At              '    Ae       $       K    BAA CAB,       L    BBA BBB         ,    *              D  0  $           <   \  H      BBB B(A0(B BBB      D          ABB B(B0A8A@8A0B(B BBA       3                  #                  F              ,    6              D  @               \    *             t                   x                                      4                                  k                  
                 I             4  @                L                  d                 |  8                   _                  -                0                  8  	                0                  8  #              $  P  &              <  h                 T  p  #              l    #                  #                             ,       /    BBA dBB       L       O@   ABB B(B0A8G3@8A0B(B BBA         4  	            L   L  h
    ABB B(B0A8A@8A0B(B BBAA@    l     (    ABB B(B0A8Dl8A0B(B BBAEE8A0B(B BBAA            # T           L   $   $    ABB B(B0A8D`q8A0B(B BBAA`            H=: H: H9tH* Ht	        H=: H5: H)HH?HHHtHe* HtfD      =-;  u+UH=B*  HtH=>: 	 d; ]     wH     AWAVSHIHL=Hs   LL$LHE1 HL$HLL L=<H  LL$HLHE1q HL$HLLn LH[A^A_UAWAVAUATSH   IH$      H$   HL$`E1E18 Ht$xHT$L6 Ht$hHT$L4 $    $       W$   ($   L$   L$   H$       |$ tvHt$hLD$ L11 H\$ H IHt$hLHHE1 HT$ HuL HH$   L1   L {  Ht$`1LD$L11f H\$Hi IHt$`LHHE1@ D$  D$$    WD$@($D$PLl$8Ll$(HD$0    HT$|$ H$   HDHuL HH|$ LHE  L    Ht$(HT$0H$   L Ht$pH$    H$   L1E1E1 H$   D$@L$PH H$   L9t H|$(L9tz H$   iH$   L9t^ H|$(L9tO |$ t?H1L1e ,H$   L9t! |$ tHoL19 1HH   [A\A]A^A_]fUAWAVAUATSH   IHD$0   HT$0HL$E1E1^ Ht$HT$Ll D$x D$|    W$   (]$   L$   L$   H$       |$ tsHt$LD$8L11 Hl$8H HHt$LHHE1 HT$8HuH HH|$xH1A  H    Ht$E1LD$L11 Hl$H HHt$LHHE1 D$8 D$<    WD$X(dD$hLd$PLd$@HD$H    HT$|$ Hl$xIDHuHK HH|$8HH   H> H$   L9t, H|$@L9t 1@HT$(LH HD$(&H$   L9t HT$L1  HD$H   [A\A]A^A_]f     UAWAVAUATSH   HL$(IHt$XIHD$HHD$8HD$@    H_L_L9tI   MBL9LL$ LT$L$LD$   IAHHH	HHH	HHH	HHH	HHH	HH H	HL9t+HHR LD$L$LT$LL$ IMu@D?  H IHD$HPLH# LD$L$LT$LL$ M	?  M0I+IBHD$   1HD$hD$d    1HD$xE1%I   f.     D  IM9>  fAM9s
HD$XF4(CwHHcHfA:  D$d$  Ht$@Hd>  IZH|$81Az LGA  LD$L$LT$LL$ .>  AZ(ABAB,HD$@       MAHHAA1I)AHH5J0DHT$X   fA:q  M9LIGIIDH  
fS  H#  HHD$$  zt$  zp#  D$P   D$0    #  f.     AH1$dIEfAL9sD4IH|$( <  HD$( ;  xHD$L8IGIL9m  IH9o  !  fA/ImL9HD$X<(/,  HD$H(fA/M  HEM8M9[  IH9]  R  Az  b  ABfA/  HL$H  HCM8M9?  IH9A  HCHHH	HHH	HHH	HHH	HHH	HH H	HM9;  LH ID  ABm  	   fA/fA\]  fA/1  ImL9$  HD$X<(/  HD$L8IGM0M9c  IH9e  =  	   fA/]fA\RI
   DAfX	  HUHcHHD$@D$ht	H:  HIHD$@       AF<	  H\$8L|$@IG   Ld$HL9tHL$HH9%  LHL	HHH	HHH	HHH	HHH	HH H	HL9  HH H  MzEz(   fA/HfA\=HL$(H	  y	  i,HAH9HBY(H9HBH)I/I8L9H#  IHZH9#  HHHH	HHH	HHH	HHH	HHH	II I	IL9.(  LC HT$H$H?(     fA/rfA\gHL$(H	  y  i(Y,HAH9HBH9HBH)HD$L J#M0M9H"  IHjH9"  (  Af9  H    H  IH|$8Ht$@H  HHH$  G<|t<:  ABAB(AB,AB4   xAz      fA/]fA\RIIfAt-fA/t&Az fA\ufA?tfA#  HD$8HL$@HQH  H5
HcH8.  fA/q#  Az tfA\_#  HD$L8IGIL92  I2  fA%&  fA?l  fA#  AH5kL#8  LD$L$LT$LL$    S7  fA#tfA  HD$L8IGIL9	  IH9  Q  fA?wAH     HrfAtAz   fA\  ABHt$@t	H6  1HD$HH|$8Li9  LD$L$LT$LL$ P6  IAZ(  I	   s   IbAj$Aj(Aj,Aj4^-  fA?wAH     HrfAtAz 5  fA\5  HT$@H3  HD$8HrH  111  fA#5  HT$(Dr HBL9LBHD$H(I.M M9  IHrH9  Ht$0HHHH	HHH	HHH	HHH	HHH	HH H	HM9)  LH I2  ABAB(H  AB,  HT$(Z HBH9HBHD$H(H+M M9r  IHrH9t  HHHH	HHH	HHH	HHH	HHH	II I	IM9Ht$0  LL: HT$H$IM  24  
   fA/`HT$(r(Db,HJL9LBI9IBI)]  Ht$0HrHt$PHD$'  L8IGIL9)  IH9+  IGHHH	HHH	HHH	HHH	HHH	HH H	HL95'  HHX LD$L$LT$H<'  fA.  fA  fA#*  MzIjEAB8HEM9  IH9'    fA]H\$8L|$@IG   Ld$HL9tHL$HH9  LHL	HHH	HHH	HHH	HHH	HH H	HL9  HHk H  H\$8L|$@IG   Ld$HL9tHL$HH9  LHL	HHH	HHH	HHH	HHH	HH H	HL9  HH H  H  
w  zs  H,  H  zs  D$P   D$0      fAAz tfA\H\$8L|$@IG   Ld$HL9tHL$HH9%  LHL	HHH	HHH	HHH	HHH	HH H	HL9u$  HH LD$L$LT$LL$ H{$        H9K  LHL	HHH	HHH	HHH	HHH	HH H	HL9  HHj H  ABAB(1Az LX3  LD$L$LT$LL$ ?0  ABAB,HD$@    AB4   ^Ez,Ez4b'  ABAB,Q'     H9  HEHHH	HHH	HHH	HHH	HHH	HH H	HM9h  LH Iq  fA/m     fA?&     HrH9L  L|$@D$h'  IGH\$8   Lt$HL9tHL$HH9*'  IGHHH	HHH	HHH	HHH	HHH	HH H	HL9&  HH  H&  8.  EB4AJ8IjMbI9IBL9LHBHH)E  H~HHD  |/  H
HHH9v  8%  x2  PE  %d  .v  x%l  x2b  P98%T  x2J  PE;  x%1  x2'  PE  H11f     <,0|} <l0|} <l0|} <l0}/HH9uHt&H1f.     4<wHH9u  @-  ABwHH;z  HD$L8IGM0M9U  IH9W  LHL	HHH	HHH	HHH	HHH	HH H	HM9  LH  I  u?HL$(A ;A$u/   LH5@  LD$L$LT$LL$ [,  ABAB$AB(AB,#     HrH9M  H?h6ztu&ztu zpuH+  Hu
zs;D$0D$P    D$P    D$0HD$|  MH8  HHLL  HLT$H$LD$+  IH(HD$L8B;?IBHIBAz AB8H|$8Ht$@HHHDLF  LD$LT$LL$ L$++  HD$@    IjEAB<   fA#EHEM8M9  IH9
  HHH	HHH	HHH	HHH	HHH	HH H	HM9	  LH  LD$L$LT$LL$ IM	  t*     H9	  HHH	HHH	HHH	HHH	HHH	HH H	HM9  LH  LD$L$LT$LL$ IM	  )     H9HD$A	     H9HD$	  fA[(  fA]#  D$d      H  HHLL  HLL$ LT$L$LD$g)  H\$8Hl$HL|$@F4;HD$@   MH  IHLH&  MLL$ LT$L$LD$)  M8IHD$H(fA///IBHIBAB$
      H9  IGHHH	HHH	HHH	HHH	HHH	HH H	HM9M  LHf  LD$L$LT$LL$ IMY  T(     H9#  IGHHH	HHH	HHH	HHH	HHH	HH H	HL9  HH  H  MHZ  IHLH  MH$HL$Ht$0'  L!HHL$H)HLHL  Ht$L~HFJ,0HnHT$(JNn n(n,n$I9HtHLHH9r      LHH9   HHH	HHH	HHH	HHH	HHH	HH H	HI9t&LH  HL$H<$Ht$IMu6&  HD  IHH4$H  HL$H<$Ht$M&  L9HHD$H(HT$(A/:L~HFL`LfDf4Dr8AHJL9LBZ4I9IBI)HZI9txHIHH9szLHHH	HHH	HHH	HHH	HHH	HH H	HI9t:LH  IMH$HL$uJ%     IHH9rHl$;H-  IHH4$L  MH$HL$%  L9H(Hl$Le MLHLi  Lu Lu HL$(i8Y<HAH9HBH9HBH)tEHiLt$L?   F  HL$%  AA8LHH5  H|$y$  AHD$Dp8H|$#     LD$L$LT$LL$ $  ABAB<      H9HD$
     L  IHH4$Hr  HT$H$Mb$  L"L9HD$H(IHt$0LHH<  LT$MbIBH,IjHL$(IAJAj M9MtI   LL$ LD$HHH9soHHH	HHH	HHH	HHH	HHH	HH H	HM9t2LH  LD$L$LT$LL$ IMuB#  HD$DH  IHH4$H_  LD$L$LT$LL$ ME#  M IHD$H(A,:H ABfA/t0fA\u)HD$L8IGIL9   IH9   a  HL$(q(Da,HAL9LBI9IBI)  HD$H8HGIL9  IHqH9Ht$0  HGHHH	HHH	HHH	HHH	HHH	II I	IL94  HL.  HD     H9  IGHHH	HHH	HHH	HHH	HHH	HH H	HL9  HH  LD$L$LT$LL$ HH  !  A HT$H2;A$I  HFIL9  I  H  HHLLe  HLL$ LT$L$LD$K!  H\$8Hl$HL|$@F4;HD$@   fH  IHH4$H  LD$L$LT$LL$ M   M8IHD$H(A/#  HP  IHH4$H  LD$L$LT$LL$ M   M8IHD$H(A/#H    MH  IHLHe  MLL$ LT$L$LD$K   M8I+HD$HfA//HHHAZ$   \   HqH9Ht$0pHD$3  AH5 HT$8   LD$L$LT$LL$    x2uPEu
x.AzuRAR4Ar8IzH9HBH9w7Hu1HHH52sH|t:u@:HD$L8IGIL9tmIH9soLHL	HHH	HHH	HHH	HHH	HH H	HL9t2HH  LD$L$HHuB     H9rHD$:H;  HHH4$L  LD$L$H  II+HD$L8B;/HH HhH)M8M9tIHT$@H4HH9r       HT$@H4HH9   HHHH	HHH	HHH	HHH	HHH	HH H	HM9t!LH  IMH$HL$u3  MHG  IHLH  MH$HL$  L9HHD$H(HT$@LHt$8H  H\$@LL$ LT$LD$HD$HHHD$@    fA?t0fA#L$$	  CAB8HCMzM9tIH9r!      L$T   H9   HHH	HHH	HHH	HHH	HHH	HH H	HM9t+LH  LD$L$LT$LL$ IMu;  H  IHH4$H}  LD$L$LT$LL$ Mc  M8I+HD$HA#IBHIBAB<   tH  IHH4$L  LD$L$LT$LL$ M   M0IHD$L8fC>//IBHIBAB$	   IHD  HHH4$L  LD$L$LT$LL$ H  II+HD$L8fB;//IBHIBAB$   MH  HHLLK  HLL$ LT$L$LD$1  II+HD$L8B;fileMzIBHhIjAB   Aj HHM9tIH9r      H9   HHHH	HHH	HHH	HHH	HHH	HH H	HM9tLHv  IMH  IHLHe  MLL$ LT$L$LD$K  M8IHD$H(AD//fA/:/IBHIBAB$I   PMH  IHLL  MH$LD$  M0H(HD$L8C>:H LHt$8  LD$LL$ LT$L$  AJ0HD$@    ABAB4I   ziHD$uzluzeuD$P   D$0    D$P    L$0MuM9LIGIIDL IM8M9teIH9sgLt$pHHHH	HHH	HHH	HHH	HHH	HH H	HM9t!LH  I-   H9rHl$BMH!  IHLL  MH$HL$Lt$p{  L9H(Hl$Le MLHt$XHW  HE L$Le |$0 tAI   HHDH   1LL$ Ht$XLT$L$LD$   LT$L$PAJAD$AB LL$ Ht$XL$LD$j    ID$M8M9  IH9    A   1LL$ Ht$XLT$L$LD$sI1LL$ Ht$XLT$L$LD$    I
 IL
 IL
 IL
 HI9uHt I
 HHuHD$L IL$MIDI Hr9fuyH  Hn  xtd     xpU    HF  w;  xs1  Hy  H     xse  	  Hrhuxt  xt  xp  H  H     xs       HZH9xM.     HjH9.  HHHH	HHH	HHH	HHH	HHH	II I	IM9  LL  H$I     H9HD$	  D$dLd$8L|$@IG   HT$HI9tHL$HH9  LHL	HHH	HHH	HHH	HHH	HH H	HHD$HI9!  LH  I)  Hq  HHLL  HLL$ LT$L$LD$  H\$8Hl$HL|$@F4;HD$@   HH)tOAzu5Hu/Hu)THHH=4>s|:tI)M$IHD$L fA/LD$tAz   fA\  HD$@       ULH|$PL  HHHHT$P  HLT$H$LD$  IL8HD$H8HL$(f;//HH HHq Q$HyH9HBH9HBH)   HqL  H|$HL$u  AA$HD$(X$h(H@H9HBH9HBH)t8HD$(HX:   R  H|$'  HHJ  H|$  @   #  LD$LT$  HD$ AB$AB(LHt$0L   H|$LT$L$  IrAr,HL$(Y,i4HAH9HBH9HBH)H  HY:     H|$p  HH  L$LT$T  HL$(A0AB0Ir  ID$L9  I  xi   xl   xe   AB   AD$AB ID$M8M9/   H9  ID$HHH	HHH	HHH	HHH	HHH	HH H	HM9-  LHq  I6  AB    AD$AB M9sB<6/uEb$   MA
Eb$Eb(Eb,Eb4   mL  HD$0HH4$L  H|$0HT$H$H  H:L!HD$L8IILHH  HT$HjHjj,j4HL$(Y8HAH9HBDy4L9LBL)LyH+HzL9LthH
H9sjHHHH	HHH	HHH	HHH	HHH	II I	IH9  L!  H$H     H9rLd$  L  IHH4$L  H$HD$M  L0L9HD$L MLHH  LT$IZIZAZ,AZ4LL$ LL)HL$LD$reHL$XB)HHH52s>HL$XB|):u1H  HD$XBD(<9wH    H  HL$(A4Q8HIH9HBH9HBHH)HS  Ht$(H~H4HHHH1fD  </tHH9u  H  HH9HGH   HDHH)H  HHH<  |:  L  LD$L$LT$LL$   E  L  HD$0HH4$H'  H|$0H$HD$H  H8L!Ld$I,$HHLH  I$I$fAtJfA?LL$ LT$  fA#   AZ8H\$H#     LT$LL$   HL$(Dy8i<HAH9HBL9LBL)  LyH\$H?   w  HL$L  AA8HLHf  LD$L$LT$LL$    HD$XJ<(M)L%(    LT$AB4IB  Hc  IHHt$HL  MLL$ LT$L$LD$  Ld$8Hl$HL|$@G4<HD$@H  HHLL}  LD$L$LT$LL$ Hc  H\$8Hl$HL|$@F4;HD$@
   ~H  HHH4$L$  LD$L$LT$H  II+HD$L8HT$(fB;//H HrHJDr Dz$AL9LBM9MBH(M)tI/I8L9tIH9r   Aj$g     H9   HHHH	HHH	HHH	HHH	HHH	HH H	HL9Ht$ptH0  HT$H$H0H  H$   HH4$H  H$   HT$H$H
  H:HHD$H(Ht$pHLHL  HD$LxLxDx$HD$(X$h(H@H9HBH9HBH)H|$t8HD$(HX:     H|$y
  HH  H|$a
  @   u  L$LT$F
  HD$H(Aj(I,MzM9tIH9r      H9   HHHH	HHH	HHH	HHH	HHH	HH H	HM9t!LH  H$IHD$Mu1	  H  IHH4$H  H$HD$M}	  L8HHD$H(Ht$PLHt$0HLU  LT$MbMbEb,HT$(B,J4HRH9HBH9LL$ L$LD$vaL:   +  H|$ 	  HL$(q,Q4HAH9HBH9HBH)Hq  LD$L$LT$LL$   ABAB4I      H9s_HFHHH	HHH	HHH	HHH	HHH	HH H	HL9  HH0  H  HD$  H  HHLL  H  H\$8Hl$HL|$@H{HL>  HD$8f %4@0L|$@IL|$@LL$ LT$L$LD$MQ  1L|$hGf.      H5L~  LD$L$LT$LL$ u  HI9  HD$8(<:uHL$xuMbMrEr$IFM9t\IH9s^LHL	HHH	HHH	HHH	HHH	HH H	HM9t!LH  I-   H9rHD$KMHB  IHLL  L|$hMLL$ LT$L$LD$  M IHD$L0C4:H HD$xHI9HD$L8D$xuEz$IGIL9toIH9sqLHL	HHH	HHH	HHH	HHH	HH H	HL9t4HH  LD$L$LT$LL$ H>   H9rHD$DH>  HHH4$L  LD$L$LT$LL$ H  II+HD$L8B;@H HD$@    
   HD$hMH  IHLLC  MLL$ LT$L$LD$)  M8IHD$L fC'//IBHIBAB$   8D$P   D$0    H\$H  ILL$ L$LD$LT$AZ8   p     H9snLHL	HHH	HHH	HHH	HHH	HH H	HL9d  HH=  LD$H$LT$LL$ Hk  HD$x     H9snLHL	HHH	HHH	HHH	HHH	HH H	HL95  HH  LD$H$LT$LL$ H<  HD$E  MHI  HHLL  HLT$L$HD$r  HI+HD$H0HL$(f3//H0HH0Ar$Ar(Ar,Ar4Y8HAH9HBDy4L9LBL)LyH3MbM9t`IH9sbHHHH	HHH	HHH	HHH	HHH	HH H	HM9t!LH  I2   H9rHl$BHHt$0  IHH4$HT$0{  MH$HL$k  L!H(Hl$Hu LHLHI  H] H] fAt]fA?LL$ LT$tBfA#   AZ8H\$H#   %  LT$LL$ L$  I'      HL$(Dy8i<HAH9HBL9LBL)tlLyH\$H?     HL$  AA8HLH  LD$L$LT$LL$    HL  LT$I   LT$AZ8   LL$ L$LD$g   AJAEb HD$(Ht   ;H>   4Hl  HHH4$L  LD$H$LT$LL$ H   IH)HD$L8B;/   9H  HHH4$L  LD$H$LT$LL$ HtqI(HHD$L BD% /   D$P   D$0    o   H|$XLM)HLL  xH|$81HD$HH9uH|$8HD$HH9t  H   [A\A]A^A_]DG4O8HGH9HBL9MLBIM)t2L_IALHf.     A|/tH4
HHH9vHL)Hru5Hu0Iu*CDHHH5e2$sC|:tM)IHHGf.     D  UAWAVAUATSPIAHDs"Im M}IOIEH9t8HH9r>@  Im M}IGMeL9   I$H9   m     H9  IOHHH	HHH	HHH	HHH	HHH	HH H	HH9   HH%  HH        H9   LHL	HHH	HHH	HHH	HHH	HH H	HL9t{HH  HH      H.  IHHL  LH   Im I]M}AH@H&HIABD=fBD=    8H  HHLL>  Ht/Im I]M}IFt=    IE 1H[A\A]A^A_] UAWAVAUATSHHIIIHHL$ tlA$[uxAC|]  1LH@AH)o  LW)$>:   HR  ~:H  HA  1        u      IR  11L9   HHAt+A4HHH-</@@HLt[Hf.     fA4HH<@@ALHH4HI9uAa  HLLLHH[A\A]A^A_]  I"  11L9   HHAt*AHHH-</@HLt`H~f.     @ AHH<@AtHH<@@@@HI9u@LD$(   HD$H$HD$       E1M   fC<<%tIM9uMI	rdI@HHH	HHH	HHH	HHH	HHH	HH H	HH  LD$(H  H$H\$1M9MMGIMDL9   IVHHH	HHH	HHH	HHH	HHH	HH H	H  H%  H  E  M7MoK(IM9  IH9  HHHH	HHH	HHH	HHH	HHH	HH H	HM9
  LH  IHl$ MLD$(
  d  16     1H-f.     fHH</@@ALHH4.ALHH4.ALHH4.HpL9AHk   1Hf.      HH<@AtHH<@@ATHH4AtHH<@@@@@HPL99AHeA1OIL9@  L(I?   ?   f.     @ >:uA  HAHL9
  M Q
r1q@%3  @I%  BHuL9   Q
rf Q%   I   BHuL9   Q
rf Q%   IsyBHuL9tNQ
rf Q%wFIs=BHL9f Hf 
f f 	  :u-HL9  fD<  1H:t.  f  <  H)L9  1ft>.r  fh  HL9[  	M  Hfft"f6  <W   v  L9tH
rHL,Tf<TJfuL9Tf  
     H9}Hl$   HH  H
  H$H\$H|$HLL  Lt$Lt$Ht$(I9R  HT$f     G,<A%   I_H9   C|'HHH   A,HHHx   IFL<$   I9tHL$H9  Hl$8H|$@LHL	HHH	HHH	HHH	HHH	HH H	HI9  LH  IMHt$(  >	  IFH,$   H9tHL$H9   LHL	HHH	HHH	HHH	HHH	HH H	HH9tHH  HHHt$(u.  H  HHHt$L  HHt$(  H,$H\$Lt$HT$Fl5 LLt$ILt$HIH9_IH   IHLL  MHt$(/  L<$Hl$Lt$HT$H|$@Hl$8H}D C7L<$IvHA<.tHH9vHHzL9HIGLH)  LHvi80udPXuYHty   H?   ?   f.     D  HH9tP<o@
r@@%  @Hr  1f.     
  HH9uM  E111    A<.tHI9uHL9HIGIIIDM9MBHtsH  
A?0udAG$<X   H     E1I@IHH9tiA/p@
rp@rp@g  
L1E1     	>  @85  LIHH9uI  H  I       MM)AE	EMe  IwHjHtbHHrHHL9s$Hf.     A<.tHH9vHHL9HIGHIDH9HBH)HL$ L)LaK4HYI9tgHH9siHHHH	HHH	HHH	HHH	HHH	HH H	HI9  LH+  I     H9rH\$   H  IHLL  Hl$ MLD$(V	  Lu H]LmMLLLL  H]E1  E1Hl$ H]   Ld$3H\$@IH"  IHHL  M6  Hl$ L} H]LuH\$@L$(C7.HEDL$(   LH
z1  tLcL  IL} LeK4I9tkHH9smHHHH	HHH	HHH	HHH	HHH	HHH H	HI9t)LH  IMu8\     H9rHl$ 8H  IHHL  M)  Hl$ L} H]LeH\$@MLLd$3LLO  LuLuL$(   IFL} I9tHH9   H9LHL	HHH	HHH	HHH	HHH	HHH H	HI9LH  IM(Y  H#  IHHL  M7  H\$ L+HkLcMLLLh  LsHD$H<$E1H9    1fLA   A(   HH|$,lf\$f<l<   HB|$,lf\$f<l<   HB|$
,lf\$
f<l<|wHB|$,lf\$f<l<|ZHB|$,lf\$f<l<|=HB|$,lf\$f<l<| D$LfT$fL<  I/LMIGHH9HL$8tH	   H9sVLHL	HHH	HHH	HHH	HHH	HH H	HH;l$8tHH  H#Ht$ 1H6  IHHL  LHt$ Ht_H.H^L~BD= [LfILf11IHl$8      HAI9v+H<$AHD$H9t  DHH[A\A]A^A_]E	EXHL|$ Hl$8  )@9  HHHH   f<T uH   HCHwf|T t5HrHH)@9vHHl$8HHHr   Hwf|T tHrH_f|T tHrHGf|T tHrH/f|T
 t	HrlHf|T HrL|$ Hf|T Hr3HD$(<   H HD$@Ll$3E11lH@  HHLL  HLl$3  IIoMgHl$8ILH5ftH\$@Hw  MgIMgII  tfB<t tL9t$(u)HD$@LIH9tEHM H9rJf.     @ Bt   LHt1e     Lc      H9UHHHH	HHH	HHH	HHH	HHH	IHH H	HL9HH|  HHLl$3  L  IM/I_J#I9tHM H9r      H9   HHHH	HHH	HHH	HHH	HHH	II I	II9tLL  IMu'B  LW  IHHH  M   HD$ L(LxIHXLHLl$3LL  MgMgI   ID$M?I9t]HM H9s^LHL	HHH	HHH	HHH	HHH	HH H	HI9t!LH  I*   H9rHD$ 3H  IHHL  MtLHD$ L8HXL`Ll$3C':L`IL`I1IITID$M?I9tHM AY   AH9sTLHL	HHH	HHH	HHH	HHH	HH H	HI9tLH#  I HD$ 2H  IHHL  MHD$ L8HXL`C']H@E1 HrKHHHp$s,:u&HtG<9wH    H1f.     fUAWAVAUATSH(HHIIHHL$t1E1f     C7HH$rIM9uE1M9   H] LmK,HH9   HM H9   HHHH	HHH	HHH	HHH	HHH	II I	IH9   HL  HHl$H   ~  H} HuJ&HUH9t%H
H9r+%     H9cHl$      H9   HHHH	HHH	HHH	HHH	HHH	II I	IH9HT$ tiL  HH     LV  HHHL  Hl$H  H] LuLmILLL  LeE1  H|$LHt$  HHHt$HT$g  HHl$HH  H} LmHuHT$ M9LIGIIDH.H9   H
H9   Hl$HHHH	HHH	HHH	HHH	HHH	II I	IH9   L  HH   HD$H8LhIHpHl$   H9sLl$HHLHw  ImLE1M9s`     C<7HH@xVIM9u9LHT$ Ht$  HHHt$ HT$  HHYADH([A\A]A^A_]A1f.      f.      1f.      ff     1I@ HQH9wHDHHLt1H9sH     xHQH9HuHH%  E1IH0fDA?ADXHILIH9   MJI9v	FfNJLL	LtExDHIwDIJL9   BLHBLHBLHBLHBLHBLHBLHBLHBL	H	BL
H
BLHBLHBLHBLHBLHHLHH)HHq  HrH7H9   HrH9   E1HMIIIIt"f.     fBfHIIuI  BfBLfHBLfHBLfHBLfHBLfH
BLfHBLfHHIL9u   IIIBIIIH   MI1f@ ~~Tf`f`BTB~L~Tf`f`LB TB0H IuAt"~~Lff`f`BLBJRI9H)H1AuHH  HrH7H9   HH9   E1HMIIIIt!f.     fBHIIuI&  BBLHBLHBLHBLHBLHBLHBLHH IL9u   IIIBIIIH   MI1ff.     ffnfnTf`faf`faTfnLfnTf`faf`faL T0HIuAt*fnfnLff`faf`faLJI9H)H1AuHtHs11\  1HHHAIIIHP  MIf1foafoaff     fnDfnfdf`pfpfffdf`pfpffDfnDfnfdf`pfpfffdf`pfpffHIgAtUfnDfnfo%H`fdf`pfpfo->`fffdf`pfpffffpffH~H9tD  1<HHH9uf1fAeHHUAVSIHw  1II1f.     D  LYI9vDLH\L	L      EyXED     HYH9  DD   AA   AA?E   EEHIILI9`   HwELQM9   \AY\AY\AY\AY\AY\AY\AY\AY\	AY	\
AY
\AY\AY\AY\AYLAIIMFI=I)L[A^]HH  IHE1@ MQI9vB	JLtjDExfDHI  f.      D      IIH9  AABL?D	fHIM  IC  fIIL9A  BLfHBLfHBLfHBLfHBLfH
BLfHBLfHHLIH9   D   u>IIH9   AF\A?AE	BL?D	fHI   D      IIH9   AAF\A?AE	BL?D	FTA?E
A  D	A
A      fDfHHILIH9!HIH9H)H1UAVSIH  1IIE1f.     @ IjH9vBJJ\H	Lte   @N       IJH9e     P  ?	        /  I  A	IJH9  BLAIBLAIBLAIBLAIBLAIBLAIBLAIBLAI BL	AI$BL
AI(BLAI,BLAI0BLAI4BLAI8BLAI<I@HIH9Z     u~MZI9J  AL:   3  FD     ?	         A?A	   DA               IZH9   Et:D      E\:D         uzA?AA	A?AE	?B    rIA	   Df     A)IILIH9gIIH9UI)IL[A^]HtHs1H[  1HHfHnHAIIIHI  MIf1fo?Xff.     fnDfnfqffqff`fafbff`fafbfDfnDfnfqffqff`fafbff`fafbfHIkAtOfnDfnfqfo%wWffqfff`fafbff`fafbfffpffH~H9t#f.     D  HHHH9uf1AfHtOHuLE11@t=BW      r(      r    1   HH1IIE11f.     LIM9tBWA         r*D   A   r    1   HHBLW   rA      r    E1   AIqHtHsE11   1IIf1fo3VfDoUfDo1VfDoUfDo?Vfvf    ~fAfpfofAfff~LfAfpfofAffffofAfffofAfffAfffffAfffffoffofHI9fffpffH~I9tBHf.     fB1H   H   HHIHL9uHGHHG    HHf     HH?HH9t  f.     UAWAVATSHL?HGI9tHE1H9r      E1H9   HHHH	HHH	HHH	HHH	HHH	HH H	HI9tLHu  IMt(L#Hk%H  IHSHLZ  MuAD[A\A^A_] UAWAVATSH/LgE1L9tGHLIwLHL  H  L#HL  Ht	HL{AD[A\A^A_]fD  HHW     HG        H     Hf     AWAVAUATSIIHWL&HFI9t
HH9rp   H9sfHHHH	HHH	HHH	HHH	HHH	HH H	HI9t5LH  IMtDM'I_IVI6L  IFIG1'HX  IIWHL  MMu[A\A]A^A_f.     D  UAWAVAUATSPIIIL*HBI9t
HL9rn   L9sdINHHH	HHH	HHH	HHH	HHH	HH H	HI9t3LH	  IMtCM,$I\$LLL  Mt$1(Hi  HIT$HL  IMuH[A\A]A^A_]f.     UAWAVAUATSPIIL'LoHVJ*HGI9t
H0H9rt   H9sjHHHH	HHH	HHH	HHH	HHH	HH H	HI9t<LH  IMtJM'I_MoIVMI6L  IFIG1&Hg  HHLL  IMuH[A\A]A^A_]f.     UAWAVAUATSPIIIL/H_HHGI9t
HH9rs   H9siHHHH	HHH	HHH	HHH	HHH	HH H	HI9t;LH  IMtQM,$Il$I\$LHLL  Mt$1.Hi  L<$IHLH  ML<$MuH[A\A]A^A_]@ UAWAVAUATSPAHL'LIOHGI9t
HH9rl   H9sbLHL	HHH	HHH	HHH	HHH	HH H	HI9t+LH  IMt9L#HkL{G4<HC1&H  IHLL  MMuH[A\A]A^A_] UAWAVAUATSPIIIHuL>  IM,$I\$J;ID$I9t
HH9rs   H9siHHHH	HHH	HHH	HHH	HHH	HH H	HI9t;LH  IMtQM,$Il$I\$LHLL  M|$1.Hu  L4$IHLH  ML4$MuH[A\A]A^A_]UAWAVAUATSPIIL/LgH~J'IGI9t
HH9rt   H9sjHHHH	HHH	HHH	HHH	HHH	HH H	HI9tKLH   IMtYM/I_I~MgLLL[  I?I6IV  IFIG1&Hh  HHLL  IMuH[A\A]A^A_]f.     UAWAVAUATSPIIIHLoJ*HGH9t
HH9rs   H9siHHHH	HHH	HHH	HHH	HHH	HH H	HH9tHHH  HHt^I$Il$Ml$J<3HLL  I<$LL  Mt$1.H\  L<$IHHL  LL<$HuH[A\A]A^A_]    UAWAVAUATSPAIH/LIOHGH9t
HH9ro   H9seLHL	HHH	HHH	HHH	HHH	HH H	HH9tAHH  HHtOI,$I\$M|$H}HLC  I$D0ID$1&HZ  IHHL  LHuH[A\A]A^A_]f.      UAWAVAUATSPIIIHuL  II$Ml$K/ID$H9t
HH9rs   H9siHHHH	HHH	HHH	HHH	HHH	HH H	HH9tHHH  HHt^I$Il$Ml$J<;HL(  I<$LL  M|$1.H8  L4$IHHL  LL4$HuH[A\A]A^A_] UAWAVAUATSHHoH9  HIIHzL</M.IFI9tHL9r      L9   H\$L|$IOHHH	HHH	HHH	HHH	HHH	II I	II9tLL  IMu(nL4  HHLH  IMtHM.M~H\$H{InL|$LLML)LH  M&H3HSLT  M~1H[A\A]A^A_]f.     D  UAWAVAUATSHLI9!  HIIIIHHGH9tHH9HT$r      H9HT$   Lt$H,$HJHHH	HHH	HHH	HHH	HHH	II I	IH9tHLc  HHu(uL  HHHLK  HHtOI$Mt$M|$H,$Lt$HLHLM)HL]  M,$LLH  HD$ID$1H[A\A]A^A_]UAWAVAUATSHH_AH9   AIIHSH/HGH9tHHT$H9r      HT$H9   Dt$HHH	HHH	HHH	HHH	HHH	II I	IH9tHL  HHu'cL  HD$HHH  Hl$Ht>Im MuI]Dt$I</HLL)HH$  IE F48HD$IEE1DH[A\A]A^A_]f.     @ UAWAVAUATSHHoH9%  IIHIHuL  II,M7IGI9tHH9HT$r      H9HT$   Ll$HJHHH	HHH	HHH	HHH	HHH	II I	II9tLL  IMu*lL?  H$HLH  L4$MtDM7MoIoLl$I<LIH)LH  IHLLf  HD$IG1H[A\A]A^A_]f.     fUAWAVAUATSHHoHH),  IIIH2H9HFHyHH)HM/IGI9tHH9HT$r      H9HT$   Lt$HJHHH	HHH	HHH	HHH	HHH	II I	II9tLLc  IMu*sL  H$HLHJ  L,$MtKM/MwLt$I~IoLLLIH)LH^  M'I6IVL  HD$IG1H[A\A]A^A_]fUAWAVAUATSH(LoMI)=  MHH2L9LFK(L)L'HGI9tH8H9HL$ HT$r      H9HL$ HT$   Ht$Lt$HJHHH	HHH	HHH	HHH	HHH	II I	II9tLL  IMHt$u-yLq  HHLL  IMHt$tNLe LuLmLt$I<6LIMM)HLL  H] HHt$ L  HD$HE1H([A\A]A^A_]UAWAVAUATSHLwI9  AIHMI)IH/HGH9tHL9r      L9   Ht$Dl$IOHHH	HHH	HHH	HHH	HHH	II I	IH9tHL  HHHt$u1kL  HD$HHL  Hl$HHt$t<H+LkLsDl$H<.HILM)IHL  HF, L{1H[A\A]A^A_]f.     UAWAVAUATSH(LgLH)O  IIHH2L9HFIuLk  ILH)LL3HCI9tHH9HT$ r      H9HT$    LD$Ll$H\$HJHHH	HHH	HHH	HHH	HHH	II I	II9tLL,  IMLD$u-zL  HHLL  IMLD$tOH\$L3LkLcLl$K<8LLII)LLL  L;LLH  HD$ HC1H([A\A]A^A_]f.     D  AVSPHHWHH)r,IH1H9HFHH<0HHH)H  I)^1H[A^@ UAWAVAUATSPIIILzL:HB    HWHFH   @H	ryHHHH	HHH	HHH	HHH	HHH	HH H	HH9  H   IE I]IT$L9   I/1H9r   LH9   HHHH	HHH	HHH	HHH	HHH	HH H	H@t H  Ht#IE I]I}IT$.HH  HuI]1   @H9l1HI4$  I]I\$I]IVHMe M9tIH9r      H9   HHHH	HHH	HHH	HHH	HHH	HH H	HM9tLHA  IMu DH  IHLH.  Mt&Me ImI]IVLI6H  IFIE1H[A\A]A^A_]fUAWAVAUATSPIIIHLaL!HA    HBL   @H	r|H4$HHHH	HHH	HHH	HHH	HHH	HH H	HH  H   IIoL9   I$1H4$L9r   LL9   HIMHHH	HHH	HHH	HHH	HHH	HH H	H@tHZ  Ht IIoIH2HH  HuMo/   H4$@L9h1HL  MoMoIVJ*IL9tI$H9r      H9   HHHH	HHH	HHH	HHH	HHH	HH H	HL9tHH  HHu CHo  HHLL  Ht%IIoMoIVII6L  IFIG1H[A\A]A^A_] UAWAVAUATSPIIH4$ILaL!HA    HWJ2   @H	rxHHHH	HHH	HHH	HHH	HHH	HH H	HH  H   II_IUL9   I,$1H9r   LH9   HHHH	HHH	HHH	HHH	HHH	HH H	H@tH  Ht!II_IIUGHH^  HuIoI.M/M9uK   H9rN      @H9U1HIu &  IoImIoI.M/M9tI$H9   HHHH	HHH	HHH	HHH	HHH	HH H	HM9tLH  IMu ?H  IHLH  Mt!M/I_IoLHH4$Li  Mw1H[A\A]A^A_]@ UAWAVAUATSHMIHT$HHMhM(I@    HA   @H	   Ht$HHHH	HHH	HHH	HHH	HHH	HH H	HH;  H   I$Il$L9   M} 1Ht$I9r   LI9   IHKHHH	HHH	HHH	HHH	HHH	HH H	H@t H  Ht#I$Il$I|$LNHH  HuI\$J3I,$L9uN   H9rQ      Ht$@I9I1HH  I\$I\$J3I,$L9tIM H9   HHHH	HHH	HHH	HHH	HHH	II I	IL9tHL4  HHu DL  HHLH!  Ht&I,$M|$I\$HHHt$L  Mt$1H[A\A]A^A_]D  UAWAVAUATSPIt$HLzL:HB    HWHBA   AH   HHH	HHH	HHH	HHH	HHH	HH H	HH  HM  I$I\$HUL9tM7E1I9sqHHHH	HHH	HHH	HHH	HHH	HH H	HEt_Hd  HtbI$I\$I|$HU
LI9r1HHu   I\$H]I\$HCM,$M9t/IH9r5   HHr  HuI\$HCM,$M9u   H9   HHH	HHH	HHH	HHH	HHH	HH H	HM9tLH~  IMu'B=Hu~  IHLH~  MtM,$Il$I\$D$AD ID$1H[A\A]A^A_]UAWAVAUATSHIT$IHLyL9HA    IFA   @HwuHt$LHL	HHH	HHH	HHH	HHH	HH H	HH}  HD  IE I]L9tM'1Ht$M9r1oLM9sIINHHH	HHH	HHH	HHH	HHH	HH H	H@tIH#}  HtLIE I]I}LHL}  MuMuIFI] L9t.IH9r4   HHG}  HuMuIFI] L9u   H9   LHL	HHH	HHH	HHH	HHH	HH H	HL9tHH|  HHu'>9HK|  HHLL|  HtI] ImMuD$B3IE1H[A\A]A^A_]f.     UAWAVAUATSPIIH4$ILaL!HA    HWJ:   @H	rxHHHH	HHH	HHH	HHH	HHH	HH H	HHx{  H   II^IUL9   I,$1H9r   LH9   HHHH	HHH	HHH	HHH	HHH	HH H	H@tHz  HuMHHM{  Ht=II^I~IU   @H9r1HIu #{  IEIFIuH<$z  IM.InI/M9tI$H9r      H9   HHHH	HHH	HHH	HHH	HHH	HH H	HM9tLHzz  IMu ?Hy  IHLHgz  Mt!M.I^InLHH4$LEz  M~1H[A\A]A^A_]UAWAVAUATSHMIHT$IHM`M I@    J)   @H	r~Ht$HHHH	HHH	HHH	HHH	HHH	HH H	HH y  H   II^L9   I,$1Ht$L9r   LL9   HIMHHH	HHH	HHH	HHH	HHH	HH H	H@tHx  HuLHHx  Ht<II^I~H   Ht$@L9k1HLx  MnIuH|$@x  IM.I^J;M9tI$H9r      H9   HHHH	HHH	HHH	HHH	HHH	HH H	HM9tLHx  IMu @Hw  IHLHx  Mt"M.InI^LHHt$Lw  M~1H[A\A]A^A_] SHHHHV1H9HB@CHHx  D[f.     S1H9HBCHHw  D[f     AVSPIHHuLv  HH;HC1H9HBCLw  DH[A^D  AWAVSIHIHuLv  H1H9HGFLLH?w  D[A^A_@ HGH9HHBHHDHH9HBH)HHfD  H9ILGHLDI9IBHI)Lf.     fAWAVAUATSIHGH9HHBIIHHDH9LBHyH9HA    L)H	rZHCHHH	HHH	HHH	HHH	HHH	II I	ILNu  Ht HIMnM'LHu  I^1[A\A]A^A_f.     UAWAVAUATSPH9HHGHHDMIIH9LBL)M(I@I9t
HH9rl   H9sbHKHHH	HHH	HHH	HHH	HHH	HH H	HI9t3LHt  IMtDM.InMLLHt  I^1)H=t  H$IVHLt  L,$MuH[A\A]A^A_]f.      HOHH9vH?f.      87t
HH9uHf.      HH9s@ 8t
HH9uHf.      HOHtHH9wHHHHf.     f8tHH9vHf.     HtHH9rHHH 8tHH9vHH  II1ILHI9wHTHLJ  HfD  TxIHHHu,     u3LHI9  L1        fD     ueLHI9   DTD      D$<   A?AA	1A      A   A   up   upH9wkDLD   uWLuKLu?A?AB
  I  rf.      LI911H  HrHwH9   H2H9   1IE1MIIHHt$f.     FGD	EIIHuI  L)NGI1ALx	A:ALxAL:ELxD		EL:Ax	AL:HH9uI?  III@IIIH1  LHf1fox$ff~$G~lGfofaffofafffgffgf~$f~l~dG~lGfofaffofafffgffgf~df~lHHtAtJ~G~\Gffofaffofaffo%#ffgffgf~f~\fNfpffpUff~I90   t1I)Lf1fAjHH  IHE1fDHILIH9c  MQI9vFOfD  NOMt>fAvD      tof   DA?ADXHIwDIIL9   BLOHBLOHBLOHHLIH9_   IIH9   A (  FTOA
FA $AA $  DD?HAA?ADPA?ADXHIEDAA?ADPA?ADXHHIH9H)1HHtzHE1D MHI9scFWD   A      uA (  EA  w;IJH9s2BLW $   uA
AA   A   H)H1HHtHsE11   1IIf1fDo fo fDoq fvff     fnTfnfofAftfAdf`pfpfffofAftfAdf`pfpffff`pfpffff`pfpffHI9^ffpffH~I9t*H@ B1HHIHL9uHtHs11l  1HHHAIIIHc  LHf1fofofo%fo-ff     ~4fpfffff~Dfpfffff~Dfpffff~LfpffffffffHHufvfoffofAtU~~Lfpfo%ffo-fffo5fffpffffffofoffpffH~H9t%f.      <   HHHH9ufo/1foAVHt`E1fD  IH9sMBG%   IH=   u1H9s1      u BDG%   =   uILH9r11H  HrHH9   H2H9   1IE1MIIHHt#f.     FD	EIIHuIq  L)NI1AL	A:ALAL:ELD		EL:A	AL:HH9uI#  III@IIIH  LHf1fo,f     oodffffgfgffgfgf~f~do\ od0ffffgfgffgfgf~\f~dHHuAt>oo\fffo%ffgfgffgfgf~f~\fNfpffpUff~I9P=   wI)L1f1fAvHH6  IHE1fDHIMI9  MYI9vFf.     NM   AvA  w$DA?ADPH    A  wbD       DD?HA?ADPHJDBLHHMI9>GA wBDD?HD?HA?ADPHH)1HHt}E1H	IL9tlFA  w*D    tUfDHf.     D  A w3A  
 A  A   ffDHHH)H1HHtHs11\  1HHHAIIIHP  MIf1foEfoMff     fnDfnfdf`pfpfffdf`pfpffDfnDfnfdf`pfpfffdf`pfpffHIgAtUfnDfnfo%xfdf`pfpfo-nfffdf`pfpffffpffH~H9tD  1<HHH9uf1fAeHtHs1E1[  1IIIAIIIH\  LHf1fodfofo%ffn,WfntWfffufp pUfffufp pUfffnDWfnLWfffufp pUfffufp pUffHHsAtWfnWfn\Wfo%fffo%
fufp pUfo-fffufp pUffffpffH~I9t1f.     D  BO   1   HIL9uf1fALHtW1 wJ    t<   f.     fHH9t w HP   uH9 G    WG (G0HGHGHG     HHHH9ta  f.     HGHW    W HGHOH9HBf.      G W$HOH9HBH9HBH)HGf.      G$W(HOH9HBH9HBH)HGf.     W,HGH9HBG(H9HBH)HGG,W4HOH9HBH9HBH)HGf.      W8HGH9HBG4H9HBH)HGf.      W<HGH9HBG8H9HBH)HGf.      G<HWH9HBH)HGf.     AWAVSIHIHuH`  HLHL[A^A_UAWAVAUATSH   HL$(IHt$XIHD$HHD$8HD$@    H_L_L9tI   MBL9LL$ LT$L$LD$   IAHHH	HHH	HHH	HHH	HHH	HH H	HL9t+HH_  LD$L$LT$LL$ IMu@D?  H^  IHD$HPLHc_  LD$L$LT$LL$ M	?  M0I+IBHD$   1HD$hD$d    1HD$xE1%I   f.     D  IM9>  fAM9s
HD$XF4(CwHHcHfA:  D$d$  Ht$@Hd>  IZH|$81Az LGA  LD$L$LT$LL$ .>  AZ(ABAB,HD$@       MAHH[AA1I)AHH50DHT$X   fA:q  M9LIGIIDH  
fS  H#  HHD$$  zt$  zp#  D$P   D$0    #  f.     AH1$dIEfAL9sD4IH|$( <  HD$( ;  xHD$L8IGIL9m  IH9o  !  fA/ImL9HD$X<(/,  HD$H(fA/M  HEM8M9[  IH9]  R  Az  b  ABfA/  HL$H  HCM8M9?  IH9A  HCHHH	HHH	HHH	HHH	HHH	HH H	HM9;  LH[  ID  ABm  	   fA/fA\]  fA/1  ImL9$  HD$X<(/  HD$L8IGM0M9c  IH9e  =  	   fA/]fA\RI
   DAfX	  HUHcHHD$@D$ht	H:  HIHD$@       AF<	  H\$8L|$@IG   Ld$HL9tHL$HH9%  LHL	HHH	HHH	HHH	HHH	HH H	HL9  HHXZ  H  MzEz(   fA/HfA\=HL$(H	  y	  i,HAH9HBY(H9HBH)I/I8L9H#  IHZH9#  HHHH	HHH	HHH	HHH	HHH	II I	IL9.(  LY  HT$H$H?(     fA/rfA\gHL$(H	  y  i(Y,HAH9HBH9HBH)HD$L J#M0M9H"  IHjH9"  (  Af9  H    H  IH|$8Ht$@H  HHH$  G<|t<:  ABAB(AB,AB4   xAz      fA/]fA\RIIfAt-fA/t&Az fA\ufA?tfA#  HD$8HL$@HQH  H5
HcH8.  fA/q#  Az tfA\_#  HD$L8IGIL92  I2  fA%&  fA?l  fA#  AH5kL#8  LD$L$LT$LL$    S7  fA#tfA  HD$L8IGIL9	  IH9  Q  fA?wAH     HrfAtAz   fA\  ABHt$@t	H6  1HD$HH|$8Li9  LD$L$LT$LL$ P6  IAZ(  I	   s   IbAj$Aj(Aj,Aj4^-  fA?wAH     HrfAtAz 5  fA\5  HT$@H3  HD$8HrH  111  fA#5  HT$(Dr HBL9LBHD$H(I.M M9  IHrH9  Ht$0HHHH	HHH	HHH	HHH	HHH	HH H	HM9)  LH3U  I2  ABAB(H  AB,  HT$(Z HBH9HBHD$H(H+M M9r  IHrH9t  HHHH	HHH	HHH	HHH	HHH	II I	IM9Ht$0  LLzT  HT$H$IM  24  
   fA/`HT$(r(Db,HJL9LBI9IBI)]  Ht$0HrHt$PHD$'  L8IGIL9)  IH9+  IGHHH	HHH	HHH	HHH	HHH	HH H	HL95'  HHS  LD$L$LT$H<'  fA.  fA  fA#*  MzIjEAB8HEM9  IH9'    fA]H\$8L|$@IG   Ld$HL9tHL$HH9  LHL	HHH	HHH	HHH	HHH	HH H	HL9  HHR  H  H\$8L|$@IG   Ld$HL9tHL$HH9  LHL	HHH	HHH	HHH	HHH	HH H	HL9  HH%R  H  H  
w  zs  H,  H  zs  D$P   D$0      fAAz tfA\H\$8L|$@IG   Ld$HL9tHL$HH9%  LHL	HHH	HHH	HHH	HHH	HH H	HL9u$  HH0Q  LD$L$LT$LL$ H{$        H9K  LHL	HHH	HHH	HHH	HHH	HH H	HL9  HHP  H  ABAB(1Az LX3  LD$L$LT$LL$ ?0  ABAB,HD$@    AB4   ^Ez,Ez4b'  ABAB,Q'     H9  HEHHH	HHH	HHH	HHH	HHH	HH H	HM9h  LHO  Iq  fA/m     fA?&     HrH9L  L|$@D$h'  IGH\$8   Lt$HL9tHL$HH9*'  IGHHH	HHH	HHH	HHH	HHH	HH H	HL9&  HH O  H&  8.  EB4AJ8IjMbI9IBL9LHBHH)E  H~HHD  |/  H
HHH9v  8%  x2  PE  %d  .v  x%l  x2b  P98%T  x2J  PE;  x%1  x2'  PE  H11f     <,0|} <l0|} <l0|} <l0}/HH9uHt&H1f.     4<wHH9u  @-  ABwHH;z  HD$L8IGM0M9U  IH9W  LHL	HHH	HHH	HHH	HHH	HH H	HM9  LHL  I  u?HL$(A ;A$u/   LH5L  LD$L$LT$LL$ [,  ABAB$AB(AB,#     HrH9M  H?h6ztu&ztu zpuH+  Hu
zs;D$0D$P    D$P    D$0HD$|  MHxK  HHLLK  HLT$H$LD$+  IH(HD$L8B;?IBHIBAz AB8H|$8Ht$@HHHDLF  LD$LT$LL$ L$++  HD$@    IjEAB<   fA#EHEM8M9  IH9
  HHH	HHH	HHH	HHH	HHH	HH H	HM9	  LHJ  LD$L$LT$LL$ IM	  t*     H9	  HHH	HHH	HHH	HHH	HHH	HH H	HM9  LHAJ  LD$L$LT$LL$ IM	  )     H9HD$A	     H9HD$	  fA[(  fA]#  D$d      HRI  HHLLI  HLL$ LT$L$LD$g)  H\$8Hl$HL|$@F4;HD$@   MHH  IHLHfI  MLL$ LT$L$LD$)  M8IHD$H(fA///IBHIBAB$
      H9  IGHHH	HHH	HHH	HHH	HHH	HH H	HM9M  LHH  LD$L$LT$LL$ IMY  T(     H9#  IGHHH	HHH	HHH	HHH	HHH	HH H	HL9  HHH  H  MHG  IHLH	H  MH$HL$Ht$0'  L!HHL$H)HLHLG  Ht$L~HFJ,0HnHT$(JNn n(n,n$I9HtHLHH9r      LHH9   HHH	HHH	HHH	HHH	HHH	HH H	HI9t&LHG  HL$H<$Ht$IMu6&  HF  IHH4$HF  HL$H<$Ht$M&  L9HHD$H(HT$(A/:L~HFL`LfDf4Dr8AHJL9LBZ4I9IBI)HZI9txHIHH9szLHHH	HHH	HHH	HHH	HHH	HH H	HI9t:LHF  IMH$HL$uJ%     IHH9rHl$;HmE  IHH4$LE  MH$HL$%  L9H(Hl$Le MLHLE  Lu Lu HL$(i8Y<HAH9HBH9HBH)tEHiLt$L?   E  HL$%  AA8LHHuE  H|$y$  AHD$Dp8H|$#   ;E  LD$L$LT$LL$ $  ABAB<      H9HD$
     LDD  IHH4$HD  HT$H$Mb$  L"L9HD$H(IHt$0LHH|D  LT$MbIBH,IjHL$(IAJAj M9MtI   LL$ LD$HHH9soHHH	HHH	HHH	HHH	HHH	HH H	HM9t2LHC  LD$L$LT$LL$ IMuB#  HD$DH1C  IHH4$HC  LD$L$LT$LL$ ME#  M IHD$H(A,:H ABfA/t0fA\u)HD$L8IGIL9   IH9   a  HL$(q(Da,HAL9LBI9IBI)  HD$H8HGIL9  IHqH9Ht$0  HGHHH	HHH	HHH	HHH	HHH	II I	IL94  HLnB  HD     H9  IGHHH	HHH	HHH	HHH	HHH	HH H	HL9  HHB  LD$L$LT$LL$ HH  !  A HT$H2;A$I  HFIL9  I  H6A  HHLLA  HLL$ LT$L$LD$K!  H\$8Hl$HL|$@F4;HD$@   fH@  IHH4$HLA  LD$L$LT$LL$ M   M8IHD$H(A/#  H@  IHH4$H@  LD$L$LT$LL$ M   M8IHD$H(A/#H    MH6@  IHLH@  MLL$ LT$L$LD$K   M8I+HD$HfA//HHHAZ$   \   HqH9Ht$0pHD$3  AH5 HT$8   LD$L$LT$LL$    x2uPEu
x.AzuRAR4Ar8IzH9HBH9w7Hu1HHH52sH|t:u@:HD$L8IGIL9tmIH9soLHL	HHH	HHH	HHH	HHH	HH H	HL9t2HH?  LD$L$HHuB     H9rHD$:H{>  HHH4$L>  LD$L$H  II+HD$L8B;/HH HhH)M8M9tIHT$@H4HH9r       HT$@H4HH9   HHHH	HHH	HHH	HHH	HHH	HH H	HM9t!LH>  IMH$HL$u3  MH=  IHLH=  MH$HL$  L9HHD$H(HT$@LHt$8H=  H\$@LL$ LT$LD$HD$HHHD$@    fA?t0fA#L$$	  CAB8HCMzM9tIH9r!      L$T   H9   HHH	HHH	HHH	HHH	HHH	HH H	HM9t+LH<  LD$L$LT$LL$ IMu;  HO<  IHH4$H<  LD$L$LT$LL$ Mc  M8I+HD$HA#IBHIBAB<   tH;  IHH4$LZ<  LD$L$LT$LL$ M   M0IHD$L8fC>//IBHIBAB$	   IH;  HHH4$L;  LD$L$LT$LL$ H  II+HD$L8fB;//IBHIBAB$   MH;  HHLL;  HLL$ LT$L$LD$1  II+HD$L8B;fileMzIBHhIjAB   Aj HHM9tIH9r      H9   HHHH	HHH	HHH	HHH	HHH	HH H	HM9tLH:  IMH6:  IHLH:  MLL$ LT$L$LD$K  M8IHD$H(AD//fA/:/IBHIBAB$I   PMH9  IHLL4:  MH$LD$  M0H(HD$L8C>:H LHt$8>:  LD$LL$ LT$L$  AJ0HD$@    ABAB4I   ziHD$uzluzeuD$P   D$0    D$P    L$0MuM9LIGIIDL IM8M9teIH9sgLt$pHHHH	HHH	HHH	HHH	HHH	HH H	HM9t!LH8  I-   H9rHl$BMHa8  IHLL8  MH$HL$Lt$p{  L9H(Hl$Le MLHt$XH8  HE L$Le |$0 tAI   HHDH   1LL$ Ht$XLT$L$LD$   LT$L$PAJAD$AB LL$ Ht$XL$LD$j    ID$M8M9  IH9    A   1LL$ Ht$XLT$L$LD$sI1LL$ Ht$XLT$L$LD$    I
 IL
 IL
 IL
 HI9uHt I
 HHuHD$L IL$MIDI Hr9fuyH  Hn  xtd     xpU    HF  w;  xs1  Hy  H     xse  	  Hrhuxt  xt  xp  H  H     xs       HZH9xM.     HjH9.  HHHH	HHH	HHH	HHH	HHH	II I	IM9  LL5  H$I     H9HD$	  D$dLd$8L|$@IG   HT$HI9tHL$HH9  LHL	HHH	HHH	HHH	HHH	HH H	HHD$HI9!  LH15  I)  H4  HHLL 5  HLL$ LT$L$LD$  H\$8Hl$HL|$@F4;HD$@   HH)tOAzu5Hu/Hu)THHH=4>s|:tI)M$IHD$L fA/LD$tAz   fA\  HD$@       ULH|$PL3  HHHHT$P24  HLT$H$LD$  IL8HD$H8HL$(f;//HH HHq Q$HyH9HBH9HBH)   HqL3  H|$HL$u  AA$HD$(X$h(H@H9HBH9HBH)t8HD$(HX:   3  H|$'  HH3  H|$  @   c3  LD$LT$  HD$ AB$AB(LHt$0L@3  H|$LT$L$  IrAr,HL$(Y,i4HAH9HBH9HBH)H  HY:   2  H|$p  HH2  L$LT$T  HL$(A0AB0Ir  ID$L9  I  xi   xl   xe   AB   AD$AB ID$M8M9/   H9  ID$HHH	HHH	HHH	HHH	HHH	HH H	HM9-  LH1  I6  AB    AD$AB M9sB<6/uEb$   MA
Eb$Eb(Eb,Eb4   mL0  HD$0HH4$LQ1  H|$0HT$H$H  H:L!HD$L8IILHH1  HT$HjHjj,j4HL$(Y8HAH9HBDy4L9LBL)LyH+HzL9LthH
H9sjHHHH	HHH	HHH	HHH	HHH	II I	IH9  La0  H$H     H9rLd$  L/  IHH4$L70  H$HD$M  L0L9HD$L MLHH0  LT$IZIZAZ,AZ4LL$ LL)HL$LD$reHL$XB)HHH52s>HL$XB|):u1H  HD$XBD(<9wH    H  HL$(A4Q8HIH9HBH9HBHH)HS  Ht$(H~H4HHHH1fD  </tHH9u  H  HH9HGH   HDHH)H  HHH<  |:  L.  LD$L$LT$LL$   E  L-  HD$0HH4$Hg.  H|$0H$HD$H  H8L!Ld$I,$HHLH0.  I$I$fAtJfA?LL$ LT$  fA#   AZ8H\$H#   .  LT$LL$   HL$(Dy8i<HAH9HBL9LBL)  LyH\$H?   -  HL$L  AA8HLH-  LD$L$LT$LL$    HD$XJ<(M)L%(    LT$AB4IB  H,  IHHt$HL-  MLL$ LT$L$LD$  Ld$8Hl$HL|$@G4<HD$@HN,  HHLL,  LD$L$LT$LL$ Hc  H\$8Hl$HL|$@F4;HD$@
   ~H+  HHH4$Ld,  LD$L$LT$H  II+HD$L8HT$(fB;//H HrHJDr Dz$AL9LBM9MBH(M)tI/I8L9tIH9r   Aj$g     H9   HHHH	HHH	HHH	HHH	HHH	HH H	HL9Ht$ptHp+  HT$H$H0H*  H$   HH4$HS+  H$   HT$H$H
  H:HHD$H(Ht$pHLHL+  HD$LxLxDx$HD$(X$h(H@H9HBH9HBH)H|$t8HD$(HX:   *  H|$y
  HH*  H|$a
  @   *  L$LT$F
  HD$H(Aj(I,MzM9tIH9r      H9   HHHH	HHH	HHH	HHH	HHH	HH H	HM9t!LH)  H$IHD$Mu1	  H_)  IHH4$H)  H$HD$M}	  L8HHD$H(Ht$PLHt$0HL)  LT$MbMbEb,HT$(B,J4HRH9HBH9LL$ L$LD$vaL:   k)  H|$ 	  HL$(q,Q4HAH9HBH9HBH)HqB)  LD$L$LT$LL$   ABAB4I      H9s_HFHHH	HHH	HHH	HHH	HHH	HH H	HL9  HHp(  H  HD$  H'  HHLLU(  H  H\$8Hl$HL|$@H{HL~(  HD$8f %4@0L|$@IL|$@LL$ LT$L$LD$MQ  1L|$hGf.      H5L~  LD$L$LT$LL$ u  HI9  HD$8(<:uHL$xuMbMrEr$IFM9t\IH9s^LHL	HHH	HHH	HHH	HHH	HH H	HM9t!LH'  I-   H9rHD$KMH&  IHLL&  L|$hMLL$ LT$L$LD$  M IHD$L0C4:H HD$xHI9HD$L8D$xuEz$IGIL9toIH9sqLHL	HHH	HHH	HHH	HHH	HH H	HL9t4HH&  LD$L$LT$LL$ H>   H9rHD$DH~%  HHH4$L%  LD$L$LT$LL$ H  II+HD$L8B;@H HD$@    
   HD$hMH%  IHLL%  MLL$ LT$L$LD$)  M8IHD$L fC'//IBHIBAB$   8D$P   D$0    H\$H  ILL$ L$LD$LT$AZ8   p     H9snLHL	HHH	HHH	HHH	HHH	HH H	HL9d  HH}$  LD$H$LT$LL$ Hk  HD$x     H9snLHL	HHH	HHH	HHH	HHH	HH H	HL95  HH#  LD$H$LT$LL$ H<  HD$E  MHIX#  HHLL#  HLT$L$HD$r  HI+HD$H0HL$(f3//H0HH0Ar$Ar(Ar,Ar4Y8HAH9HBDy4L9LBL)LyH3MbM9t`IH9sbHHHH	HHH	HHH	HHH	HHH	HH H	HM9t!LH"  I2   H9rHl$BHHt$0O"  IHH4$HT$0"  MH$HL$k  L!H(Hl$Hu LHLH"  H] H] fAt]fA?LL$ LT$tBfA#   AZ8H\$H#   e"  LT$LL$ L$  I'      HL$(Dy8i<HAH9HBL9LBL)tlLyH\$H?   "  HL$  AA8HLH!  LD$L$LT$LL$    HL  LT$I   LT$AZ8   LL$ L$LD$g   AJAEb HD$(Ht   ;H>   4H   HHH4$L!  LD$H$LT$LL$ H   IH)HD$L8B;/   9HY   HHH4$L   LD$H$LT$LL$ HtqI(HHD$L BD% /   D$P   D$0    o   H|$XLM)HLL  xH|$81HD$HH9uH|$8HD$HH9t  H   [A\A]A^A_]DG4O8HGH9HBL9MLBIM)t2L_IALHf.     A|/tH4
HHH9vHL)Hru5Hu0Iu*CDHHH52$sC|:tM)IHHGf.     D  UAWAVAUATSPIAHDs"Im M}IOIEH9t8HH9r>@  Im M}IGMeL9   I$H9   m     H9  IOHHH	HHH	HHH	HHH	HHH	HH H	HH9   HHe  HH        H9   LHL	HHH	HHH	HHH	HHH	HH H	HL9t{HH  HH      Hn  IHHL  LH   Im I]M}AH@H&HIABD=fBD=    8H  HHLL~  Ht/Im I]M}IFt=    IE 1H[A\A]A^A_] UAWAVAUATSHHIIIHHL$ tlA$[uxAC|]  1LH@AH)o  LW)$>:   HR  ~:H  HA  1        u      IR  11L9   HHAt+A4HHH- </@@HLt[Hf.     fA4HH<@@ALHH4HI9uAa  HLLLHH[A\A]A^A_]  I"  11L9   HHAt*AHHH-</@HLt`Hf.     @ AHH<@AtHH<@@@@HI9u@LD$(   HD$H$HD$       E1M   fC<<%tIM9uMI	rdI@HHH	HHH	HHH	HHH	HHH	HH H	HH  LD$(H  H$H\$1M9MMGIMDL9   IVHHH	HHH	HHH	HHH	HHH	HH H	H  He  H  E  M7MoK(IM9  IH9  HHHH	HHH	HHH	HHH	HHH	HH H	HM9
  LHL  IHl$ MLD$(
  d  16     1H-f.     fHH</@@ALHH4.ALHH4.ALHH4.HpL9AHk   1Hf.      HH<@AtHH<@@ATHH4AtHH<@@@@@HPL99AHeA1OIL9@  L(I?   ?   f.     @ >:uA  HAHL9
  M Q
r1q@%3  @I%  BHuL9   Q
rf Q%   I   BHuL9   Q
rf Q%   IsyBHuL9tNQ
rf Q%wFIs=BHL9f Hf 
f f 	  :u-HL9  fD<  1H:t.  f  <  H)L9  1ft>.r  fh  HL9[  	M  Hfft"f6  <W   v  L9tH
rHL,Tf<TJfuL9Tf  
     H9}Hl$   HH  H
  H$H\$H|$HLL  Lt$Lt$Ht$(I9R  HT$f     G,<A%   I_H9   C|'HHH   A,HHH   IFL<$   I9tHL$H9  Hl$8H|$@LHL	HHH	HHH	HHH	HHH	HH H	HI9  LH  IMHt$(  >	  IFH,$   H9tHL$H9   LHL	HHH	HHH	HHH	HHH	HH H	HH9tHHQ  HHHt$(u.  H  HHHt$L4  HHt$(  H,$H\$Lt$HT$Fl5 LLt$ILt$HIH9_IH`  IHLL  MHt$(/  L<$Hl$Lt$HT$H|$@Hl$8HD C7L<$IvHA<.tHH9vHHzL9HIGLH)  LHvi80udPXuYHty   H?   ?   f.     D  HH9tP<o@
r@@%  @Hr  1f.     
  HH9uM  E111    A<.tHI9uHL9HIGIIIDM9MBHtsH  
A?0udAG$<X   H     E1I@IHH9tiA/p@
rp@rp@g  
L1E1     	>  @85  LIHH9uI  H  I       MM)AE	EMe  IwHjHtbHHrHHL9s$Hf.     A<.tHH9vHHL9HIGHIDH9HBH)HL$ L)LaK4HYI9tgHH9siHHHH	HHH	HHH	HHH	HHH	HH H	HI9  LHk  I     H9rH\$   H  IHLLF  Hl$ MLD$(V	  Lu H]LmMLLLL  H]E1  E1Hl$ H]   Ld$3H\$@IHb  IHHL  M6  Hl$ L} H]LuH\$@L$(C7.HEDL$(   LHJ1  tLcL  IL} LeK4I9tkHH9smHHHH	HHH	HHH	HHH	HHH	HHH H	HI9t)LH  IMu8\     H9rHl$ 8HU  IHHL  M)  Hl$ L} H]LeH\$@MLLd$3LL  LuLuL$(   IFL} I9tHH9   H9LHL	HHH	HHH	HHH	HHH	HHH H	HI9LH  IM(Y  Hc  IHHL  M7  H\$ L+HkLcMLLL  LsHD$H<$E1H9    1fLA   A(   HH|$,lf\$f<l<   HB|$,lf\$f<l<   HB|$
,lf\$
f<l<|wHB|$,lf\$f<l<|ZHB|$,lf\$f<l<|=HB|$,lf\$f<l<| D$LfT$fL<  I/LMIGHH9HL$8tH	   H9sVLHL	HHH	HHH	HHH	HHH	HH H	HH;l$8tHH
  H#Ht$ 1Hv
  IHHL
  LHt$ Ht_H.H^L~BD= [LfILf11IHl$8      HAI9v+H<$AHD$H9t
  DHH[A\A]A^A_]E	EXHL|$ Hl$8  )@9  HHHH   f<T uH   HCHwf|T t5HrHH)@9vHHl$8HHHr   Hwf|T tHrH_f|T tHrHGf|T tHrH/f|T
 t	HrlHf|T HrL|$ Hf|T Hr3HD$(<   H HD$@Ll$3E11lH  HHLL  HLl$3  IIoMgHl$8ILH5H\$@H  MgIMgII  tfB<t tL9t$(u)HD$@LIH9tEHM H9rJf.     @ Bt   LHE1     Lc      H9UHHHH	HHH	HHH	HHH	HHH	IHH H	HL9HH  HHLl$3  L>  IM/I_J#I9tHM H9r      H9   HHHH	HHH	HHH	HHH	HHH	II I	II9tLL  IMu'B  L  IHHH  M   HD$ L(LxIHXLHLl$3LL  MgMgI   ID$M?I9t]HM H9s^LHL	HHH	HHH	HHH	HHH	HH H	HI9t!LHM  I*   H9rHD$ 3H  IHHL.  MtLHD$ L8HXL`Ll$3C':L`IL`I1IITID$M?I9tHM AY   AH9sTLHL	HHH	HHH	HHH	HHH	HH H	HI9tLHc  I HD$ 2H  IHHLN  MHD$ L8HXL`C']H@E1 HrKHHH)$s,:u&HtG<9wH    H1f.     fUAWAVAUATSH(HHIIHHL$t1E1f     C7HH$rIM9uE1M9   H] LmK,HH9   HM H9   HHHH	HHH	HHH	HHH	HHH	II I	IH9   HL  HHl$H   ~  H} HuJ&HUH9t%H
H9r+%     H9cHl$      H9   HHHH	HHH	HHH	HHH	HHH	II I	IH9HT$ tiL  HH     L  HHHL  Hl$H  H] LuLmILLL  LeE1  H|$LHt$<  HHHt$HT$  HHl$HH  H} LmHuHT$ M9LIGIIDH.H9   H
H9   Hl$HHHH	HHH	HHH	HHH	HHH	II I	IH9   L  HH   HD$H8LhIHpHl$   H9sLl$HHLH  ImLE1M9s`     C<7HH@xVIM9u9LHT$ Ht$   HHHt$ HT$Z  HHYADH([A\A]A^A_]A HHA  HtH HH       5J#  %L#  @ %J#  h    %B#  h   %:#  h   %2#  h   %*#  h   %"#  h   %#  h   %#  h   p%
#  h   `%#  h	   P%"  h
   @%"  h   0%"  h    %"  h   %"  h    %"  h   %"  h   %"  h   %"  h   %"  h   %"  h   %"  h   %"  h                          	             	                                 	              o                  (             (                                                                        
       	      o                 {                          {                          j            ,j     o          o          o                                                                   {                     Vj     fj     vj     j     j     j     j     j     j     j     j     k     k     &k     6k     Fk     Vk     fk     vk     k     k     k     k     Ubuntu clang version 14.0.0-1ubuntu1.1 GCC: (Ubuntu 12.3.0-1ubuntu1~22.04.2) 12.3.0  Linker: Ubuntu LLD 14.0.0                                                                     R              .     R              A      S              W     X            c     {                  `S                   {                                                      T                 V      '            Y      O@           @                	 `%                 	 %              5   	 p               X    0            v   	                   	                                   	 P                   `      T          	 0               9    p             K   	                l   	               }   	 %                 	 %                 	 #                	 %                                                                       $                   7                   J                   ]                   q                                                                                                                                                                                              $                   6                   I                   ^                   q                                                                                                                                                                                                  
     O@      !     N           1   	 `%              P   	 %              j   	 0'                  K              	 P'                 	 p'                  f           
   	 '              '     f     T       M   	 &              n    0K               	 '                 	 '                	 %                 	 %                 	 *             	   	 %              /                   :    8/              y                W   j             s   ,j             ]                 .    {             H                                                                    "                       pS                 S                                                       0                     E                     W                     d                     }                                                                                                                                                                                                 p            	                 "	                 :	                 M	                     U	                     ^	    P             m	    `             w	    p             	                 	                 	          Z       	           5      	    @            	                	                
                  ,
    0             E
    @            \
                t
                 
                
                 
          T      
                 
                  
                     0             !           j       ;    p             L          	       ^          	       p                                                                             	                                                 A      (          P      @    `      2      ]          T      x           ^          `      o                E                                 L                  N          P      M                L      4          k      Q    `      /      n          %                P                ]          p      6                                      '                  K           0      L       =          *       S          $       n                                           3                  #           0      F                 6       9                G    `      *      a                y    @                                        4                                 k           P     
          `     I                      2    @            K    P           b               |         _            	     -           0	                P	     	           `	                	     #           	     &           	                  
     #           0
     #           `
     #           
            $    
     /        .note.gnu.build-id .dynsym .gnu.version .gnu.version_r .gnu.hash .dynstr .rela.dyn .rela.plt .rodata .eh_frame_hdr .eh_frame .text .init .fini .plt .fini_array .init_array .dynamic .got .data .tm_clone_table .got.plt .bss .comment .symtab .shstrtab .strtab  crtstuff.c __TMC_LIST__ deregister_tm_clones register_tm_clones __do_global_dtors_aux completed.0 __do_global_dtors_aux_fini_array_entry frame_dummy __frame_dummy_init_array_entry binding.c bare_url_parse bare_url_can_parse url__parse url__parse_host url__ascii_alpha_character_set url__scheme_character_set url__c0_control_percent_encode_set url__percent_encode_character url__special_query_percent_encode_set url__query_percent_encode_set url__percent_encode_string url__path_percent_encode_set url__starts_with_windows_drive_letter url__userinfo_percent_encode_set url__shorten_path url__fragment_percent_encode_set url__hex_encoded url__forbidden_host_character_set url__forbidden_domain_character_set url__hex_decoded url__ascii_alphanumeric_character_set endianness.c validate.c convert-to-utf8.c convert-to-utf16.c convert-to-utf32.c length-from-utf8.c length-from-utf16.c length-from-utf32.c convert-to-latin1.c convert-to-utf16.c convert-to-utf32.c length-from-latin1.c length-from-utf16.c length-from-utf32.c string.c validate.c convert-to-latin1.c convert-to-utf8.c convert-to-utf32.c length-from-latin1.c length-from-utf8.c length-from-utf32.c validate.c convert-to-latin1.c convert-to-utf8.c convert-to-utf16.c length-from-latin1.c length-from-utf8.c length-from-utf16.c validate.c url.c url__parse url__parse_host url__ascii_alpha_character_set url__scheme_character_set url__c0_control_percent_encode_set url__percent_encode_character url__special_query_percent_encode_set url__query_percent_encode_set url__percent_encode_string url__path_percent_encode_set url__starts_with_windows_drive_letter url__userinfo_percent_encode_set url__shorten_path url__fragment_percent_encode_set url__hex_encoded url__forbidden_host_character_set url__forbidden_domain_character_set url__hex_decoded url__ascii_alphanumeric_character_set crtstuff.c __FRAME_END__ __gmon_start__ _init _GLOBAL_OFFSET_TABLE_ _fini __TMC_END__ _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __dso_handle __cxa_finalize bare_get_module_name_v0 bare_register_module_v0 js_create_function js_set_named_property js_get_callback_info js_get_value_bool js_is_string js_get_value_string_utf8 malloc strlen free js_create_string_utf8 js_get_typedarray_info js_throw_error js_get_boolean realloc memcpy utf8_string_append_literal utf8_string_append_character utf8_string_append_view utf8_string_append memmove snprintf utf_endianness utf_is_le utf_is_be utf_swap_uint16 utf_swap_uint32 ascii_validate latin1_convert_to_utf8 latin1_convert_to_utf16le latin1_convert_to_utf32 latin1_length_from_utf8 latin1_length_from_utf16le latin1_length_from_utf32 utf8_convert_to_latin1 utf8_convert_to_utf16le utf8_convert_to_utf32 utf8_length_from_latin1 utf8_length_from_utf16le utf8_length_from_utf32 utf8_string_init utf8_string_view_init utf8_string_destroy utf8_string_reserve utf8_string_shrink_to_fit utf8_string_view utf8_string_clear utf8_string_empty utf8_string_view_empty utf8_string_copy utf8_string_view_copy utf8_string_prepend utf8_string_prepend_view utf8_string_prepend_character utf8_string_prepend_literal utf8_string_insert utf8_string_insert_view utf8_string_insert_character utf8_string_insert_literal utf8_string_replace utf8_string_replace_view utf8_string_replace_character utf8_string_replace_literal utf8_string_erase utf8_string_concat utf8_string_view_concat utf8_string_concat_view utf8_string_view_concat_view utf8_string_concat_character utf8_string_view_concat_character utf8_string_concat_literal utf8_string_view_concat_literal utf8_string_compare strncmp utf8_string_view_compare utf8_string_compare_literal utf8_string_view_compare_literal utf8_string_substring utf8_string_view_substring utf8_string_substring_copy utf8_string_view_substring_copy utf8_string_index_of_character utf8_string_view_index_of_character utf8_string_last_index_of_character utf8_string_view_last_index_of_character utf8_validate utf16le_convert_to_latin1 utf16le_convert_to_utf8 utf16le_convert_to_utf32 utf16_length_from_latin1 utf16_length_from_utf8 utf16_length_from_utf32 utf16le_validate utf32_convert_to_latin1 utf32_convert_to_utf8 utf32_convert_to_utf16le utf32_length_from_latin1 utf32_length_from_utf8 utf32_length_from_utf16le utf32_validate url_init url_destroy url_get_href url_get_scheme url_get_username url_get_password url_get_host url_get_port url_get_path url_get_query url_get_fragment url_parse _DYNAMIC                                                                                     p      p                                                                                          o                                               )   o                   0                            8   o                                               B                         	                             J                                                     T      B       (      (      (                          ^      2       P      P      t                             f             +      +      t                             t             8/      8/      t                             ~             R      B      _                                         j     Z                                                ,j     ,Z                                                @j     @Z                                               {     [                                               {     [                                               {     [                                             `}     `]                                                      ]                                                     ]                                                      ]                                                X     X^                                         0               X^     o                                                   ^     h         Z                                       0r                                                        2s     7                             const LE = exports.LE = (new Uint8Array(new Uint16Array([0xff]).buffer))[0] === 0xff

exports.BE = !LE
const b4a = require('b4a')

const { BE } = require('./endian')

exports.state = function (start = 0, end = 0, buffer = null) {
  return { start, end, buffer, cache: null }
}

const raw = exports.raw = require('./raw')

const uint = exports.uint = {
  preencode (state, n) {
    state.end += n <= 0xfc ? 1 : n <= 0xffff ? 3 : n <= 0xffffffff ? 5 : 9
  },
  encode (state, n) {
    if (n <= 0xfc) uint8.encode(state, n)
    else if (n <= 0xffff) {
      state.buffer[state.start++] = 0xfd
      uint16.encode(state, n)
    } else if (n <= 0xffffffff) {
      state.buffer[state.start++] = 0xfe
      uint32.encode(state, n)
    } else {
      state.buffer[state.start++] = 0xff
      uint64.encode(state, n)
    }
  },
  decode (state) {
    const a = uint8.decode(state)
    if (a <= 0xfc) return a
    if (a === 0xfd) return uint16.decode(state)
    if (a === 0xfe) return uint32.decode(state)
    return uint64.decode(state)
  }
}

const uint8 = exports.uint8 = {
  preencode (state, n) {
    state.end += 1
  },
  encode (state, n) {
    validateUint(n)
    state.buffer[state.start++] = n
  },
  decode (state) {
    if (state.start >= state.end) throw new Error('Out of bounds')
    return state.buffer[state.start++]
  }
}

const uint16 = exports.uint16 = {
  preencode (state, n) {
    state.end += 2
  },
  encode (state, n) {
    validateUint(n)
    state.buffer[state.start++] = n
    state.buffer[state.start++] = n >>> 8
  },
  decode (state) {
    if (state.end - state.start < 2) throw new Error('Out of bounds')
    return (
      state.buffer[state.start++] +
      state.buffer[state.start++] * 0x100
    )
  }
}

const uint24 = exports.uint24 = {
  preencode (state, n) {
    state.end += 3
  },
  encode (state, n) {
    validateUint(n)
    state.buffer[state.start++] = n
    state.buffer[state.start++] = n >>> 8
    state.buffer[state.start++] = n >>> 16
  },
  decode (state) {
    if (state.end - state.start < 3) throw new Error('Out of bounds')
    return (
      state.buffer[state.start++] +
      state.buffer[state.start++] * 0x100 +
      state.buffer[state.start++] * 0x10000
    )
  }
}

const uint32 = exports.uint32 = {
  preencode (state, n) {
    state.end += 4
  },
  encode (state, n) {
    validateUint(n)
    state.buffer[state.start++] = n
    state.buffer[state.start++] = n >>> 8
    state.buffer[state.start++] = n >>> 16
    state.buffer[state.start++] = n >>> 24
  },
  decode (state) {
    if (state.end - state.start < 4) throw new Error('Out of bounds')
    return (
      state.buffer[state.start++] +
      state.buffer[state.start++] * 0x100 +
      state.buffer[state.start++] * 0x10000 +
      state.buffer[state.start++] * 0x1000000
    )
  }
}

const uint40 = exports.uint40 = {
  preencode (state, n) {
    state.end += 5
  },
  encode (state, n) {
    validateUint(n)
    const r = Math.floor(n / 0x100)
    uint8.encode(state, n)
    uint32.encode(state, r)
  },
  decode (state) {
    if (state.end - state.start < 5) throw new Error('Out of bounds')
    return uint8.decode(state) + 0x100 * uint32.decode(state)
  }
}

const uint48 = exports.uint48 = {
  preencode (state, n) {
    state.end += 6
  },
  encode (state, n) {
    validateUint(n)
    const r = Math.floor(n / 0x10000)
    uint16.encode(state, n)
    uint32.encode(state, r)
  },
  decode (state) {
    if (state.end - state.start < 6) throw new Error('Out of bounds')
    return uint16.decode(state) + 0x10000 * uint32.decode(state)
  }
}

const uint56 = exports.uint56 = {
  preencode (state, n) {
    state.end += 7
  },
  encode (state, n) {
    validateUint(n)
    const r = Math.floor(n / 0x1000000)
    uint24.encode(state, n)
    uint32.encode(state, r)
  },
  decode (state) {
    if (state.end - state.start < 7) throw new Error('Out of bounds')
    return uint24.decode(state) + 0x1000000 * uint32.decode(state)
  }
}

const uint64 = exports.uint64 = {
  preencode (state, n) {
    state.end += 8
  },
  encode (state, n) {
    validateUint(n)
    const r = Math.floor(n / 0x100000000)
    uint32.encode(state, n)
    uint32.encode(state, r)
  },
  decode (state) {
    if (state.end - state.start < 8) throw new Error('Out of bounds')
    return uint32.decode(state) + 0x100000000 * uint32.decode(state)
  }
}

const int = exports.int = zigZagInt(uint)
exports.int8 = zigZagInt(uint8)
exports.int16 = zigZagInt(uint16)
exports.int24 = zigZagInt(uint24)
exports.int32 = zigZagInt(uint32)
exports.int40 = zigZagInt(uint40)
exports.int48 = zigZagInt(uint48)
exports.int56 = zigZagInt(uint56)
exports.int64 = zigZagInt(uint64)

const biguint64 = exports.biguint64 = {
  preencode (state, n) {
    state.end += 8
  },
  encode (state, n) {
    const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 8)
    view.setBigUint64(0, n, true) // little endian
    state.start += 8
  },
  decode (state) {
    if (state.end - state.start < 8) throw new Error('Out of bounds')
    const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 8)
    const n = view.getBigUint64(0, true) // little endian
    state.start += 8
    return n
  }
}

exports.bigint64 = zigZagBigInt(biguint64)

const biguint = exports.biguint = {
  preencode (state, n) {
    let len = 0
    for (let m = n; m; m = m >> 64n) len++
    uint.preencode(state, len)
    state.end += 8 * len
  },
  encode (state, n) {
    let len = 0
    for (let m = n; m; m = m >> 64n) len++
    uint.encode(state, len)
    const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 8 * len)
    for (let m = n, i = 0; m; m = m >> 64n, i += 8) {
      view.setBigUint64(i, BigInt.asUintN(64, m), true) // little endian
    }
    state.start += 8 * len
  },
  decode (state) {
    const len = uint.decode(state)
    if (state.end - state.start < 8 * len) throw new Error('Out of bounds')
    const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 8 * len)
    let n = 0n
    for (let i = len - 1; i >= 0; i--) n = (n << 64n) + view.getBigUint64(i * 8, true) // little endian
    state.start += 8 * len
    return n
  }
}

exports.bigint = zigZagBigInt(biguint)

exports.lexint = require('./lexint')

exports.float32 = {
  preencode (state, n) {
    state.end += 4
  },
  encode (state, n) {
    const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 4)
    view.setFloat32(0, n, true) // little endian
    state.start += 4
  },
  decode (state) {
    if (state.end - state.start < 4) throw new Error('Out of bounds')
    const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 4)
    const float = view.getFloat32(0, true) // little endian
    state.start += 4
    return float
  }
}

exports.float64 = {
  preencode (state, n) {
    state.end += 8
  },
  encode (state, n) {
    const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 8)
    view.setFloat64(0, n, true) // little endian
    state.start += 8
  },
  decode (state) {
    if (state.end - state.start < 8) throw new Error('Out of bounds')
    const view = new DataView(state.buffer.buffer, state.start + state.buffer.byteOffset, 8)
    const float = view.getFloat64(0, true) // little endian
    state.start += 8
    return float
  }
}

const buffer = exports.buffer = {
  preencode (state, b) {
    if (b) uint8array.preencode(state, b)
    else state.end++
  },
  encode (state, b) {
    if (b) uint8array.encode(state, b)
    else state.buffer[state.start++] = 0
  },
  decode (state) {
    const len = uint.decode(state)
    if (len === 0) return null
    if (state.end - state.start < len) throw new Error('Out of bounds')
    return state.buffer.subarray(state.start, (state.start += len))
  }
}

exports.binary = {
  ...buffer,
  preencode (state, b) {
    if (typeof b === 'string') utf8.preencode(state, b)
    else buffer.preencode(state, b)
  },
  encode (state, b) {
    if (typeof b === 'string') utf8.encode(state, b)
    else buffer.encode(state, b)
  }
}

exports.arraybuffer = {
  preencode (state, b) {
    uint.preencode(state, b.byteLength)
    state.end += b.byteLength
  },
  encode (state, b) {
    uint.encode(state, b.byteLength)

    const view = new Uint8Array(b)

    state.buffer.set(view, state.start)
    state.start += b.byteLength
  },
  decode (state) {
    const len = uint.decode(state)

    const b = new ArrayBuffer(len)
    const view = new Uint8Array(b)

    view.set(state.buffer.subarray(state.start, state.start += len))

    return b
  }
}

function typedarray (TypedArray, swap) {
  const n = TypedArray.BYTES_PER_ELEMENT

  return {
    preencode (state, b) {
      uint.preencode(state, b.length)
      state.end += b.byteLength
    },
    encode (state, b) {
      uint.encode(state, b.length)

      const view = new Uint8Array(b.buffer, b.byteOffset, b.byteLength)

      if (BE && swap) swap(view)

      state.buffer.set(view, state.start)
      state.start += b.byteLength
    },
    decode (state) {
      const len = uint.decode(state)

      let b = state.buffer.subarray(state.start, state.start += len * n)
      if (b.byteLength !== len * n) throw new Error('Out of bounds')
      if ((b.byteOffset % n) !== 0) b = new Uint8Array(b)

      if (BE && swap) swap(b)

      return new TypedArray(b.buffer, b.byteOffset, b.byteLength / n)
    }
  }
}

const uint8array = exports.uint8array = typedarray(Uint8Array)
exports.uint16array = typedarray(Uint16Array, b4a.swap16)
exports.uint32array = typedarray(Uint32Array, b4a.swap32)

exports.int8array = typedarray(Int8Array)
exports.int16array = typedarray(Int16Array, b4a.swap16)
exports.int32array = typedarray(Int32Array, b4a.swap32)

exports.biguint64array = typedarray(BigUint64Array, b4a.swap64)
exports.bigint64array = typedarray(BigInt64Array, b4a.swap64)

exports.float32array = typedarray(Float32Array, b4a.swap32)
exports.float64array = typedarray(Float64Array, b4a.swap64)

function string (encoding) {
  return {
    preencode (state, s) {
      const len = b4a.byteLength(s, encoding)
      uint.preencode(state, len)
      state.end += len
    },
    encode (state, s) {
      const len = b4a.byteLength(s, encoding)
      uint.encode(state, len)
      b4a.write(state.buffer, s, state.start, encoding)
      state.start += len
    },
    decode (state) {
      const len = uint.decode(state)
      if (state.end - state.start < len) throw new Error('Out of bounds')
      return b4a.toString(state.buffer, encoding, state.start, (state.start += len))
    },
    fixed (n) {
      return {
        preencode (state) {
          state.end += n
        },
        encode (state, s) {
          b4a.write(state.buffer, s, state.start, n, encoding)
          state.start += n
        },
        decode (state) {
          if (state.end - state.start < n) throw new Error('Out of bounds')
          return b4a.toString(state.buffer, encoding, state.start, (state.start += n))
        }
      }
    }
  }
}

const utf8 = exports.string = exports.utf8 = string('utf-8')
exports.ascii = string('ascii')
exports.hex = string('hex')
exports.base64 = string('base64')
exports.ucs2 = exports.utf16le = string('utf16le')

exports.bool = {
  preencode (state, b) {
    state.end++
  },
  encode (state, b) {
    state.buffer[state.start++] = b ? 1 : 0
  },
  decode (state) {
    if (state.start >= state.end) throw Error('Out of bounds')
    return state.buffer[state.start++] === 1
  }
}

const fixed = exports.fixed = function fixed (n) {
  return {
    preencode (state, s) {
      if (s.byteLength !== n) throw new Error('Incorrect buffer size')
      state.end += n
    },
    encode (state, s) {
      state.buffer.set(s, state.start)
      state.start += n
    },
    decode (state) {
      if (state.end - state.start < n) throw new Error('Out of bounds')
      return state.buffer.subarray(state.start, (state.start += n))
    }
  }
}

exports.fixed32 = fixed(32)
exports.fixed64 = fixed(64)

exports.array = function array (enc) {
  return {
    preencode (state, list) {
      uint.preencode(state, list.length)
      for (let i = 0; i < list.length; i++) enc.preencode(state, list[i])
    },
    encode (state, list) {
      uint.encode(state, list.length)
      for (let i = 0; i < list.length; i++) enc.encode(state, list[i])
    },
    decode (state) {
      const len = uint.decode(state)
      if (len > 0x100000) throw new Error('Array is too big')
      const arr = new Array(len)
      for (let i = 0; i < len; i++) arr[i] = enc.decode(state)
      return arr
    }
  }
}

exports.frame = function frame (enc) {
  const dummy = exports.state()

  return {
    preencode (state, m) {
      const end = state.end
      enc.preencode(state, m)
      uint.preencode(state, state.end - end)
    },
    encode (state, m) {
      dummy.end = 0
      enc.preencode(dummy, m)
      uint.encode(state, dummy.end)
      enc.encode(state, m)
    },
    decode (state) {
      const end = state.end
      const len = uint.decode(state)
      state.end = state.start + len
      const m = enc.decode(state)
      state.start = state.end
      state.end = end
      return m
    }
  }
}

exports.date = {
  preencode (state, d) {
    int.preencode(state, d.getTime())
  },
  encode (state, d) {
    int.encode(state, d.getTime())
  },
  decode (state, d) {
    return new Date(int.decode(state))
  }
}

exports.json = {
  preencode (state, v) {
    utf8.preencode(state, JSON.stringify(v))
  },
  encode (state, v) {
    utf8.encode(state, JSON.stringify(v))
  },
  decode (state) {
    return JSON.parse(utf8.decode(state))
  }
}

exports.ndjson = {
  preencode (state, v) {
    utf8.preencode(state, JSON.stringify(v) + '\n')
  },
  encode (state, v) {
    utf8.encode(state, JSON.stringify(v) + '\n')
  },
  decode (state) {
    return JSON.parse(utf8.decode(state))
  }
}

// simple helper for when you want to just express nothing
exports.none = {
  preencode (state, n) {
    // do nothing
  },
  encode (state, n) {
    // do nothing
  },
  decode (state) {
    return null
  }
}

// "any" encoders here for helping just structure any object without schematising it

const anyArray = {
  preencode (state, arr) {
    uint.preencode(state, arr.length)
    for (let i = 0; i < arr.length; i++) {
      any.preencode(state, arr[i])
    }
  },
  encode (state, arr) {
    uint.encode(state, arr.length)
    for (let i = 0; i < arr.length; i++) {
      any.encode(state, arr[i])
    }
  },
  decode (state) {
    const arr = []
    let len = uint.decode(state)
    while (len-- > 0) {
      arr.push(any.decode(state))
    }
    return arr
  }
}

const anyObject = {
  preencode (state, o) {
    const keys = Object.keys(o)
    uint.preencode(state, keys.length)
    for (const key of keys) {
      utf8.preencode(state, key)
      any.preencode(state, o[key])
    }
  },
  encode (state, o) {
    const keys = Object.keys(o)
    uint.encode(state, keys.length)
    for (const key of keys) {
      utf8.encode(state, key)
      any.encode(state, o[key])
    }
  },
  decode (state) {
    let len = uint.decode(state)
    const o = {}
    while (len-- > 0) {
      const key = utf8.decode(state)
      o[key] = any.decode(state)
    }
    return o
  }
}

const anyTypes = [
  exports.none,
  exports.bool,
  exports.string,
  exports.buffer,
  exports.uint,
  exports.int,
  exports.float64,
  anyArray,
  anyObject,
  exports.date
]

const any = exports.any = {
  preencode (state, o) {
    const t = getType(o)
    uint.preencode(state, t)
    anyTypes[t].preencode(state, o)
  },
  encode (state, o) {
    const t = getType(o)
    uint.encode(state, t)
    anyTypes[t].encode(state, o)
  },
  decode (state) {
    const t = uint.decode(state)
    if (t >= anyTypes.length) throw new Error('Unknown type: ' + t)
    return anyTypes[t].decode(state)
  }
}

function getType (o) {
  if (o === null || o === undefined) return 0
  if (typeof o === 'boolean') return 1
  if (typeof o === 'string') return 2
  if (b4a.isBuffer(o)) return 3
  if (typeof o === 'number') {
    if (Number.isInteger(o)) return o >= 0 ? 4 : 5
    return 6
  }
  if (Array.isArray(o)) return 7
  if (o instanceof Date) return 9
  if (typeof o === 'object') return 8

  throw new Error('Unsupported type for ' + o)
}

exports.from = function from (enc) {
  if (typeof enc === 'string') return fromNamed(enc)
  if (enc.preencode) return enc
  if (enc.encodingLength) return fromAbstractEncoder(enc)
  return fromCodec(enc)
}

function fromNamed (enc) {
  switch (enc) {
    case 'ascii': return raw.ascii
    case 'utf-8':
    case 'utf8': return raw.utf8
    case 'hex': return raw.hex
    case 'base64': return raw.base64
    case 'utf16-le':
    case 'utf16le':
    case 'ucs-2':
    case 'ucs2': return raw.ucs2
    case 'ndjson': return raw.ndjson
    case 'json': return raw.json
    case 'binary':
    default: return raw.binary
  }
}

function fromCodec (enc) {
  let tmpM = null
  let tmpBuf = null

  return {
    preencode (state, m) {
      tmpM = m
      tmpBuf = enc.encode(m)
      state.end += tmpBuf.byteLength
    },
    encode (state, m) {
      raw.encode(state, m === tmpM ? tmpBuf : enc.encode(m))
      tmpM = tmpBuf = null
    },
    decode (state) {
      return enc.decode(raw.decode(state))
    }
  }
}

function fromAbstractEncoder (enc) {
  return {
    preencode (state, m) {
      state.end += enc.encodingLength(m)
    },
    encode (state, m) {
      enc.encode(m, state.buffer, state.start)
      state.start += enc.encode.bytes
    },
    decode (state) {
      const m = enc.decode(state.buffer, state.start, state.end)
      state.start += enc.decode.bytes
      return m
    }
  }
}

exports.encode = function encode (enc, m) {
  const state = exports.state()
  enc.preencode(state, m)
  state.buffer = b4a.allocUnsafe(state.end)
  enc.encode(state, m)
  return state.buffer
}

exports.decode = function decode (enc, buffer) {
  return enc.decode(exports.state(0, buffer.byteLength, buffer))
}

function zigZagInt (enc) {
  return {
    preencode (state, n) {
      enc.preencode(state, zigZagEncodeInt(n))
    },
    encode (state, n) {
      enc.encode(state, zigZagEncodeInt(n))
    },
    decode (state) {
      return zigZagDecodeInt(enc.decode(state))
    }
  }
}

function zigZagDecodeInt (n) {
  return n === 0 ? n : (n & 1) === 0 ? n / 2 : -(n + 1) / 2
}

function zigZagEncodeInt (n) {
  // 0, -1, 1, -2, 2, ...
  return n < 0 ? (2 * -n) - 1 : n === 0 ? 0 : 2 * n
}

function zigZagBigInt (enc) {
  return {
    preencode (state, n) {
      enc.preencode(state, zigZagEncodeBigInt(n))
    },
    encode (state, n) {
      enc.encode(state, zigZagEncodeBigInt(n))
    },
    decode (state) {
      return zigZagDecodeBigInt(enc.decode(state))
    }
  }
}

function zigZagDecodeBigInt (n) {
  return n === 0n ? n : (n & 1n) === 0n ? n / 2n : -(n + 1n) / 2n
}

function zigZagEncodeBigInt (n) {
  // 0, -1, 1, -2, 2, ...
  return n < 0n ? (2n * -n) - 1n : n === 0n ? 0n : 2n * n
}

function validateUint (n) {
  if ((n >= 0) === false /* Handles NaN as well */) throw new Error('uint must be positive')
}
module.exports = {
  preencode,
  encode,
  decode
}

function preencode (state, num) {
  if (num < 251) {
    state.end++
  } else if (num < 256) {
    state.end += 2
  } else if (num < 0x10000) {
    state.end += 3
  } else if (num < 0x1000000) {
    state.end += 4
  } else if (num < 0x100000000) {
    state.end += 5
  } else {
    state.end++
    const exp = Math.floor(Math.log(num) / Math.log(2)) - 32
    preencode(state, exp)
    state.end += 6
  }
}

function encode (state, num) {
  const max = 251
  const x = num - max

  if (num < max) {
    state.buffer[state.start++] = num
  } else if (num < 256) {
    state.buffer[state.start++] = max
    state.buffer[state.start++] = x
  } else if (num < 0x10000) {
    state.buffer[state.start++] = max + 1
    state.buffer[state.start++] = x >> 8 & 0xff
    state.buffer[state.start++] = x & 0xff
  } else if (num < 0x1000000) {
    state.buffer[state.start++] = max + 2
    state.buffer[state.start++] = x >> 16
    state.buffer[state.start++] = x >> 8 & 0xff
    state.buffer[state.start++] = x & 0xff
  } else if (num < 0x100000000) {
    state.buffer[state.start++] = max + 3
    state.buffer[state.start++] = x >> 24
    state.buffer[state.start++] = x >> 16 & 0xff
    state.buffer[state.start++] = x >> 8 & 0xff
    state.buffer[state.start++] = x & 0xff
  } else {
    // need to use Math here as bitwise ops are 32 bit
    const exp = Math.floor(Math.log(x) / Math.log(2)) - 32
    state.buffer[state.start++] = 0xff

    encode(state, exp)
    const rem = x / Math.pow(2, exp - 11)

    for (let i = 5; i >= 0; i--) {
      state.buffer[state.start++] = rem / Math.pow(2, 8 * i) & 0xff
    }
  }
}

function decode (state) {
  const max = 251

  if (state.end - state.start < 1) throw new Error('Out of bounds')

  const flag = state.buffer[state.start++]

  if (flag < max) return flag

  if (state.end - state.start < flag - max + 1) {
    throw new Error('Out of bounds.')
  }

  if (flag < 252) {
    return state.buffer[state.start++] +
      max
  }

  if (flag < 253) {
    return (state.buffer[state.start++] << 8) +
      state.buffer[state.start++] +
      max
  }

  if (flag < 254) {
    return (state.buffer[state.start++] << 16) +
      (state.buffer[state.start++] << 8) +
      state.buffer[state.start++] +
      max
  }

  // << 24 result may be interpreted as negative
  if (flag < 255) {
    return (state.buffer[state.start++] * 0x1000000) +
      (state.buffer[state.start++] << 16) +
      (state.buffer[state.start++] << 8) +
      state.buffer[state.start++] +
      max
  }

  const exp = decode(state)

  if (state.end - state.start < 6) throw new Error('Out of bounds')

  let rem = 0
  for (let i = 5; i >= 0; i--) {
    rem += state.buffer[state.start++] * Math.pow(2, 8 * i)
  }

  return (rem * Math.pow(2, exp - 11)) + max
}
{
  "name": "compact-encoding",
  "version": "2.16.1",
  "description": "A series of compact encoding schemes for building small and fast parsers and serializers",
  "main": "index.js",
  "dependencies": {
    "b4a": "^1.3.0"
  },
  "devDependencies": {
    "brittle": "^3.0.0",
    "standard": "^16.0.3"
  },
  "scripts": {
    "test": "standard && brittle test.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/compact-encoding/compact-encoding.git"
  },
  "author": "Mathias Buus (@mafintosh)",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/compact-encoding/compact-encoding/issues"
  },
  "homepage": "https://github.com/compact-encoding/compact-encoding"
}
const b4a = require('b4a')

const { BE } = require('./endian')

exports = module.exports = {
  preencode (state, b) {
    state.end += b.byteLength
  },
  encode (state, b) {
    state.buffer.set(b, state.start)
    state.start += b.byteLength
  },
  decode (state) {
    const b = state.buffer.subarray(state.start, state.end)
    state.start = state.end
    return b
  }
}

const buffer = exports.buffer = {
  preencode (state, b) {
    if (b) uint8array.preencode(state, b)
    else state.end++
  },
  encode (state, b) {
    if (b) uint8array.encode(state, b)
    else state.buffer[state.start++] = 0
  },
  decode (state) {
    const b = state.buffer.subarray(state.start)
    if (b.byteLength === 0) return null
    state.start = state.end
    return b
  }
}

exports.binary = {
  ...buffer,
  preencode (state, b) {
    if (typeof b === 'string') utf8.preencode(state, b)
    else buffer.preencode(state, b)
  },
  encode (state, b) {
    if (typeof b === 'string') utf8.encode(state, b)
    else buffer.encode(state, b)
  }
}

exports.arraybuffer = {
  preencode (state, b) {
    state.end += b.byteLength
  },
  encode (state, b) {
    const view = new Uint8Array(b)

    state.buffer.set(view, state.start)
    state.start += b.byteLength
  },
  decode (state) {
    const b = new ArrayBuffer(state.end - state.start)
    const view = new Uint8Array(b)

    view.set(state.buffer.subarray(state.start))

    state.start = state.end

    return b
  }
}

function typedarray (TypedArray, swap) {
  const n = TypedArray.BYTES_PER_ELEMENT

  return {
    preencode (state, b) {
      state.end += b.byteLength
    },
    encode (state, b) {
      const view = new Uint8Array(b.buffer, b.byteOffset, b.byteLength)

      if (BE && swap) swap(view)

      state.buffer.set(view, state.start)
      state.start += b.byteLength
    },
    decode (state) {
      let b = state.buffer.subarray(state.start)
      if ((b.byteOffset % n) !== 0) b = new Uint8Array(b)

      if (BE && swap) swap(b)

      state.start = state.end

      return new TypedArray(b.buffer, b.byteOffset, b.byteLength / n)
    }
  }
}

const uint8array = exports.uint8array = typedarray(Uint8Array)
exports.uint16array = typedarray(Uint16Array, b4a.swap16)
exports.uint32array = typedarray(Uint32Array, b4a.swap32)

exports.int8array = typedarray(Int8Array)
exports.int16array = typedarray(Int16Array, b4a.swap16)
exports.int32array = typedarray(Int32Array, b4a.swap32)

exports.biguint64array = typedarray(BigUint64Array, b4a.swap64)
exports.bigint64array = typedarray(BigInt64Array, b4a.swap64)

exports.float32array = typedarray(Float32Array, b4a.swap32)
exports.float64array = typedarray(Float64Array, b4a.swap64)

function string (encoding) {
  return {
    preencode (state, s) {
      state.end += b4a.byteLength(s, encoding)
    },
    encode (state, s) {
      state.start += b4a.write(state.buffer, s, state.start, encoding)
    },
    decode (state) {
      const s = b4a.toString(state.buffer, encoding, state.start)
      state.start = state.end
      return s
    }
  }
}

const utf8 = exports.string = exports.utf8 = string('utf-8')
exports.ascii = string('ascii')
exports.hex = string('hex')
exports.base64 = string('base64')
exports.ucs2 = exports.utf16le = string('utf16le')

exports.array = function array (enc) {
  return {
    preencode (state, list) {
      for (const value of list) enc.preencode(state, value)
    },
    encode (state, list) {
      for (const value of list) enc.encode(state, value)
    },
    decode (state) {
      const arr = []
      while (state.start < state.end) arr.push(enc.decode(state))
      return arr
    }
  }
}

exports.json = {
  preencode (state, v) {
    utf8.preencode(state, JSON.stringify(v))
  },
  encode (state, v) {
    utf8.encode(state, JSON.stringify(v))
  },
  decode (state) {
    return JSON.parse(utf8.decode(state))
  }
}

exports.ndjson = {
  preencode (state, v) {
    utf8.preencode(state, JSON.stringify(v) + '\n')
  },
  encode (state, v) {
    utf8.encode(state, JSON.stringify(v) + '\n')
  },
  decode (state) {
    return JSON.parse(utf8.decode(state))
  }
}
module.exports = class FixedFIFO {
  constructor (hwm) {
    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) throw new Error('Max size for a FixedFIFO should be a power of two')
    this.buffer = new Array(hwm)
    this.mask = hwm - 1
    this.top = 0
    this.btm = 0
    this.next = null
  }

  clear () {
    this.top = this.btm = 0
    this.next = null
    this.buffer.fill(undefined)
  }

  push (data) {
    if (this.buffer[this.top] !== undefined) return false
    this.buffer[this.top] = data
    this.top = (this.top + 1) & this.mask
    return true
  }

  shift () {
    const last = this.buffer[this.btm]
    if (last === undefined) return undefined
    this.buffer[this.btm] = undefined
    this.btm = (this.btm + 1) & this.mask
    return last
  }

  peek () {
    return this.buffer[this.btm]
  }

  isEmpty () {
    return this.buffer[this.btm] === undefined
  }
}
const FixedFIFO = require('./fixed-size')

module.exports = class FastFIFO {
  constructor (hwm) {
    this.hwm = hwm || 16
    this.head = new FixedFIFO(this.hwm)
    this.tail = this.head
    this.length = 0
  }

  clear () {
    this.head = this.tail
    this.head.clear()
    this.length = 0
  }

  push (val) {
    this.length++
    if (!this.head.push(val)) {
      const prev = this.head
      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length)
      this.head.push(val)
    }
  }

  shift () {
    if (this.length !== 0) this.length--
    const val = this.tail.shift()
    if (val === undefined && this.tail.next) {
      const next = this.tail.next
      this.tail.next = null
      this.tail = next
      return this.tail.shift()
    }

    return val
  }

  peek () {
    const val = this.tail.peek()
    if (val === undefined && this.tail.next) return this.tail.next.peek()
    return val
  }

  isEmpty () {
    return this.length === 0
  }
}
{
  "name": "fast-fifo",
  "version": "1.3.2",
  "description": "A fast fifo implementation similar to the one powering nextTick in Node.js core",
  "main": "index.js",
  "files": [
    "./index.js",
    "./fixed-size.js"
  ],
  "dependencies": {},
  "devDependencies": {
    "standard": "^17.1.0",
    "brittle": "^3.3.2"
  },
  "scripts": {
    "test": "standard && brittle test.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mafintosh/fast-fifo.git"
  },
  "author": "Mathias Buus (@mafintosh)",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/mafintosh/fast-fifo/issues"
  },
  "homepage": "https://github.com/mafintosh/fast-fifo"
}
const { Duplex, getStreamError } = require('streamx')
const b4a = require('b4a')

module.exports = class FramedStream extends Duplex {
  constructor (rawStream, { bits = 32 } = {}) {
    super({ mapWritable })

    if (bits !== 32 && bits !== 24 && bits !== 16 && bits !== 8) throw new Error('Frame bits is invalid')

    this.rawStream = rawStream
    this.frameBits = bits
    this.frameBytes = this.frameBits / 8
    this.maxMessageLength = 0xffffffff >>> (32 - this.frameBits)

    this._factor = 0
    this._missingBytes = 0
    this._message = null
    this._writeCallback = null
    this._ended = 2

    rawStream.on('data', this._ondata.bind(this))
    rawStream.on('end', this._onend.bind(this))
    rawStream.on('drain', this._ondrain.bind(this))
    rawStream.on('error', this._onerror.bind(this))
    rawStream.on('close', this._onclose.bind(this))
  }

  _predestroy () {
    this.rawStream.destroy(getStreamError(this))

    this._maybeContinue(new Error('Stream destroyed'))
  }

  _read (cb) {
    this.rawStream.resume() // restart state machine
    cb(null)
  }

  _write (data, cb) {
    const wrap = this._frame(data.byteLength)
    wrap.set(data, this.frameBytes)

    if (this.rawStream.write(wrap) === true) return cb(null)
    this._writeCallback = cb
  }

  _maybeContinue (err) {
    const cb = this._writeCallback
    this._writeCallback = null
    if (cb !== null) cb(err)
  }

  _frame (len) {
    if (len > this.maxMessageLength) throw new Error('Message length (' + len + ') is longer than max frame (' + this.maxMessageLength + ')')

    const wrap = b4a.allocUnsafe(len + this.frameBytes)

    for (let i = 0; i < this.frameBytes; i++) {
      wrap[i] = len
      len >>>= 8
    }

    return wrap
  }

  _onclose () {
    if (this._ended !== 0) this.destroy()
  }

  _ondrain () {
    this._maybeContinue(null)
  }

  _onerror (err) {
    this.destroy(err)
  }

  _ondata (data) {
    let read = 0

    while (read < data.byteLength && !this.destroying) {
      if (this._factor < this.frameBits) {
        const byte = data[read++]
        this._missingBytes += (1 << this._factor) * byte
        this._factor += 8

        if (this._factor === this.frameBits) {
          if (data.byteLength - read >= this._missingBytes) { // quick check if we can avoid a copy
            this._push(data.subarray(read, read += this._missingBytes))
          } else { // otherwise make a buffer to read into
            this._message = b4a.allocUnsafe(this._missingBytes)
          }
        }

        continue
      }

      const chunk = data.subarray(read, read += this._missingBytes)
      this._message.set(chunk, this._message.byteLength - this._missingBytes)

      if (read > data.byteLength) {
        this._missingBytes -= chunk.byteLength
        return
      }

      this._push(this._message)
    }
  }

  _push (message) {
    this._factor = 0
    this._missingBytes = 0
    this._message = null

    // pause state machine if our buffer is full
    if (this.push(message) === false) this.rawStream.pause()
  }

  _onend () {
    if (this._factor) {
      this.destroy(new Error('Stream interrupted'))
      return
    }

    this._ended--
    this.push(null)
  }

  _final (cb) {
    this._ended--
    this.rawStream.end()
    cb(null)
  }
}

function mapWritable (s) {
  return typeof s === 'string' ? b4a.from(s) : s
}
{
  "name": "framed-stream",
  "version": "1.0.1",
  "description": "Read/write stream messages prefixed 8, 16, 24 or 32 bit length",
  "main": "index.js",
  "scripts": {
    "test": "standard && brittle test.js --coverage",
    "lint": "standard"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/holepunchto/framed-stream.git"
  },
  "author": "",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/holepunchto/framed-stream/issues"
  },
  "homepage": "https://github.com/holepunchto/framed-stream",
  "dependencies": {
    "b4a": "^1.6.1",
    "streamx": "^2.13.0"
  },
  "devDependencies": {
    "brittle": "^3.1.1",
    "duplex-through": "^1.0.2",
    "standard": "^17.0.0"
  }
}
require.addon = require('require-addon')

module.exports = require.addon('.', __filename)
const { isWindows } = require('which-runtime')
const binding = require('./binding')

function onwork(err, result) {
  if (err) this.reject(err)
  else this.resolve(result)
}

exports.tryLock = function tryLock(fd, offset = 0, length = 0, opts = {}) {
  if (typeof offset === 'object') {
    opts = offset
    offset = 0
  }

  if (typeof length === 'object') {
    opts = length
    length = 0
  }

  if (typeof opts !== 'object') {
    opts = {}
  }

  try {
    binding.fs_ext_napi_try_lock(fd, offset, length, opts.shared ? 0 : 1)
  } catch (err) {
    if (err.code === 'EAGAIN') return false
    throw err
  }

  return true
}

exports.waitForLock = function waitForLock(
  fd,
  offset = 0,
  length = 0,
  opts = {}
) {
  if (typeof offset === 'object') {
    opts = offset
    offset = 0
  }

  if (typeof length === 'object') {
    opts = length
    length = 0
  }

  if (typeof opts !== 'object') {
    opts = {}
  }

  const req = Buffer.alloc(binding.sizeof_fs_ext_napi_lock_t)
  const ctx = {
    req,
    resolve: null,
    reject: null
  }

  const promise = new Promise((resolve, reject) => {
    ctx.resolve = resolve
    ctx.reject = reject
  })

  try {
    binding.fs_ext_napi_wait_for_lock(
      req,
      fd,
      offset,
      length,
      opts.shared ? 0 : 1,
      ctx,
      onwork
    )
  } catch (err) {
    return Promise.reject(err)
  }

  return promise
}

exports.tryDowngradeLock = function tryDowngradeLock(
  fd,
  offset = 0,
  length = 0
) {
  try {
    binding.fs_ext_napi_try_downgrade_lock(fd, offset, length)
  } catch (err) {
    if (err.code === 'EAGAIN') return false
    throw err
  }

  return true
}

exports.waitForDowngradeLock = function downgradeLock(
  fd,
  offset = 0,
  length = 0
) {
  const req = Buffer.alloc(binding.sizeof_fs_ext_napi_lock_t)
  const ctx = {
    req,
    resolve: null,
    reject: null
  }

  const promise = new Promise((resolve, reject) => {
    ctx.resolve = resolve
    ctx.reject = reject
  })

  try {
    binding.fs_ext_napi_wait_for_downgrade_lock(
      req,
      fd,
      offset,
      length,
      ctx,
      onwork
    )
  } catch (err) {
    return Promise.reject(err)
  }

  return promise
}

exports.tryUpgradeLock = function tryUpgradeLock(fd, offset = 0, length = 0) {
  try {
    binding.fs_ext_napi_try_upgrade_lock(fd, offset, length)
  } catch (err) {
    if (err.code === 'EAGAIN') return false
    throw err
  }

  return true
}

exports.waitForUpgradeLock = function upgradeLock(fd, offset = 0, length = 0) {
  const req = Buffer.alloc(binding.sizeof_fs_ext_napi_lock_t)
  const ctx = {
    req,
    resolve: null,
    reject: null
  }

  const promise = new Promise((resolve, reject) => {
    ctx.resolve = resolve
    ctx.reject = reject
  })

  try {
    binding.fs_ext_napi_wait_for_upgrade_lock(
      req,
      fd,
      offset,
      length,
      ctx,
      onwork
    )
  } catch (err) {
    return Promise.reject(err)
  }

  return promise
}

exports.unlock = function unlock(fd, offset = 0, length = 0) {
  binding.fs_ext_napi_unlock(fd, offset, length)
}

exports.trim = function trim(fd, offset, length) {
  const req = Buffer.alloc(binding.sizeof_fs_ext_napi_trim_t)
  const ctx = {
    req,
    resolve: null,
    reject: null
  }

  const promise = new Promise((resolve, reject) => {
    ctx.resolve = resolve
    ctx.reject = reject
  })

  try {
    binding.fs_ext_napi_trim(req, fd, offset, length, ctx, onwork)
  } catch (err) {
    return Promise.reject(err)
  }

  return promise
}

exports.sparse = function sparse(fd) {
  // Short circuit on everything but Windows
  if (!isWindows) return Promise.resolve()

  const req = Buffer.alloc(binding.sizeof_fs_ext_napi_sparse_t)
  const ctx = {
    req,
    resolve: null,
    reject: null
  }

  const promise = new Promise((resolve, reject) => {
    ctx.resolve = resolve
    ctx.reject = reject
  })

  try {
    binding.fs_ext_napi_sparse(req, fd, ctx, onwork)
  } catch (err) {
    return Promise.reject(err)
  }

  return promise
}

exports.swap = function swap(from, to) {
  const req = Buffer.alloc(binding.sizeof_fs_ext_napi_swap_t)
  const ctx = {
    req,
    resolve: null,
    reject: null
  }

  const promise = new Promise((resolve, reject) => {
    ctx.resolve = resolve
    ctx.reject = reject
  })

  try {
    binding.fs_ext_napi_swap(req, from, to, ctx, onwork)
  } catch (err) {
    return Promise.reject(err)
  }

  return promise
}

exports.getAttr = function getAttr(fd, name) {
  const req = Buffer.alloc(binding.sizeof_fs_ext_napi_get_attr_t)
  const ctx = {
    req,
    resolve: null,
    reject: null
  }

  const promise = new Promise((resolve, reject) => {
    ctx.resolve = resolve
    ctx.reject = reject
  })

  try {
    binding.fs_ext_napi_get_attr(req, fd, name, ctx, onwork)
  } catch (err) {
    return Promise.reject(err)
  }

  return promise.then((buffer) =>
    buffer === null ? null : Buffer.from(buffer)
  )
}

exports.setAttr = function setAttr(fd, name, value, encoding) {
  if (typeof value === 'string') value = Buffer.from(value, encoding)

  const req = Buffer.alloc(binding.sizeof_fs_ext_napi_set_attr_t)
  const ctx = {
    req,
    value,
    resolve: null,
    reject: null
  }

  const promise = new Promise((resolve, reject) => {
    ctx.resolve = resolve
    ctx.reject = reject
  })

  try {
    binding.fs_ext_napi_set_attr(req, fd, name, value, ctx, onwork)
  } catch (err) {
    return Promise.reject(err)
  }

  return promise
}

exports.removeAttr = function removeAttr(fd, name) {
  const req = Buffer.alloc(binding.sizeof_fs_ext_napi_remove_attr_t)
  const ctx = {
    req,
    resolve: null,
    reject: null
  }

  const promise = new Promise((resolve, reject) => {
    ctx.resolve = resolve
    ctx.reject = reject
  })

  try {
    binding.fs_ext_napi_remove_attr(req, fd, name, ctx, onwork)
  } catch (err) {
    return Promise.reject(err)
  }

  return promise
}

exports.listAttrs = function listAttrs(fd) {
  const req = Buffer.alloc(binding.sizeof_fs_ext_napi_list_attrs_t)
  const ctx = {
    req,
    resolve: null,
    reject: null
  }

  const promise = new Promise((resolve, reject) => {
    ctx.resolve = resolve
    ctx.reject = reject
  })

  try {
    binding.fs_ext_napi_list_attrs(req, fd, ctx, onwork)
  } catch (err) {
    return Promise.reject(err)
  }

  return promise
}
{
  "name": "fs-native-extensions",
  "version": "1.4.2",
  "description": "Native file system extensions for advanced file operations",
  "main": "index.js",
  "files": [
    "index.js",
    "macros.h",
    "binding.c",
    "binding.js",
    "CMakeLists.txt",
    "include",
    "src",
    "prebuilds"
  ],
  "imports": {
    "child_process": {
      "bare": "bare-subprocess",
      "default": "child_process"
    },
    "fs": {
      "bare": "bare-fs",
      "default": "fs"
    },
    "fs/*": {
      "bare": "bare-fs/*",
      "default": "fs/*"
    },
    "path": {
      "bare": "bare-path",
      "default": "path"
    }
  },
  "addon": true,
  "scripts": {
    "test": "npm run lint && npm run test:bare && npm run test:node",
    "test:bare": "bare test.js",
    "test:node": "node test.js",
    "lint": "prettier . --check"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/holepunchto/fs-native-extensions.git"
  },
  "author": "Kasper Isager Dalsgar <kasper@funktionel.co>",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/holepunchto/fs-native-extensions/issues"
  },
  "homepage": "https://github.com/holepunchto/fs-native-extensions#readme",
  "dependencies": {
    "require-addon": "^1.1.0",
    "which-runtime": "^1.2.0"
  },
  "devDependencies": {
    "bare-fs": "^3.0.2",
    "bare-path": "^3.0.0",
    "bare-subprocess": "^4.0.1",
    "brittle": "^3.1.1",
    "cmake-bare": "^1.1.10",
    "cmake-napi": "^1.0.5",
    "minimist": "^1.2.6",
    "prettier": "^3.5.3",
    "prettier-config-standard": "^7.0.0",
    "test-tmp": "^1.2.1"
  }
}
ELF          >            @                 @ 8 
 @         @       @       @       0      0                                           C      C                   C      S      S      \      \                                     0      0                                                                                                   Rtd                     0      @             Ptd   6      6      6      4      4             Qtd                                                         p      p      p                                    GNU (R                                                                      ,                       F   "                   j                                                                                                                                                                                                    5                     L                     g                     }                                                                                                                                                   (                     A                     a                     t                                                                                    "                     ;                     B                     i                                                                                                         J                     f                                                                                                                                                                                             '                     /                     9                     C                     P                     [                     b                     j                         d            7          
                 
                 =       8          #       u                                  7           #            r                @      V           `            O    0b      {      n          J       U     pT                P\                 ^      {      q    P      ;                 *                 V                  7                  #                 #           `f      {      ]          +       n    x                                 `      q                 )           `      #           @      4                 5       !          }                ;           0l      }                      P          
       }          %                            PV                                       1                 
           0      ;                                                                                                             r         ui	   |     ii                         
   9                        @               @   
  @    @                     $         @ PP   9   ;   <   @   C   F   M   U   Y   _   +j;gU2*#R;C:5m/]=\"Zft!qTz
Gin>/]/zNN3 d'm$21=Dffvjh._b"qzO __gmon_start__ _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize fs_ext_napi_try_lock js_get_callback_info napi_set_last_error_info js_get_value_uint32 js_throw_error napi_get_value_uint32 napi_throw_error uv_get_osfhandle fs_ext_try_lock uv_err_name uv_strerror fs_ext_napi_wait_for_lock js_get_typedarray_info napi_clear_last_error_info napi_create_reference napi_get_uv_event_loop fs_ext_wait_for_lock js_open_handle_scope js_get_reference_value js_get_null js_create_string_utf8 js_create_error js_call_function_with_checkpoint napi_get_last_error_info js_get_and_clear_last_exception js_fatal_exception js_close_handle_scope js_delete_reference fs_ext_napi_try_downgrade_lock fs_ext_try_downgrade_lock fs_ext_napi_wait_for_downgrade_lock fs_ext_wait_for_downgrade_lock fs_ext_napi_try_upgrade_lock fs_ext_try_upgrade_lock fs_ext_napi_wait_for_upgrade_lock fs_ext_wait_for_upgrade_lock fs_ext_napi_unlock fs_ext_unlock fs_ext_napi_trim fs_ext_trim fs_ext_napi_sparse js_create_reference js_get_env_loop fs_ext_sparse fs_ext_napi_swap js_get_value_string_utf8 malloc napi_get_value_string_utf8 fs_ext_swap free fs_ext_napi_get_attr fs_ext_get_attr js_create_arraybuffer memcpy fs_ext_napi_set_attr napi_get_buffer_info uv_buf_init fs_ext_set_attr fs_ext_napi_remove_attr fs_ext_remove_attr fs_ext_napi_list_attrs fs_ext_list_attrs js_create_array_with_length js_set_element napi_register_module_v1 js_create_uint32 js_set_named_property js_create_function fs_ext__try_lock uv_queue_work fs_ext__wait_for_lock fs_ext__try_downgrade_lock fs_ext__wait_for_downgrade_lock fs_ext__try_upgrade_lock fs_ext__wait_for_upgrade_lock fs_ext__unlock fs_ext__trim fs_ext__sparse fs_ext__swap fs_ext__get_attr fs_ext__set_attr fs_ext__remove_attr fs_ext__list_attrs fcntl __errno_location uv_translate_sys_error fallocate syscall fgetxattr fsetxattr fremovexattr flistxattr strlen realloc memmove libc.so.6 GLIBC_2.2.5 GLIBC_2.3 GLIBC_2.10 GLIBC_2.14 fs-native-extensions@1.bare               T                   `T                         `                    h                    p                    x                             9                    A                    C                    D                    F                    G                    H                    O                    Q                    R                    X                    Z                    [                    _                                                                        (                    0                    8         	           @         
           H                    P         M           X                    `                    h                    p                    x                                                 <                                                                                                                                                                                                                                                N                    Y                    @                     I                    `                    a                                                    (         U           0                    8                     @         !           H         P           P         "           X         V           `         #           h         $           p         %           x         &                    W                    J                    =                    '                    (                    )                    *                    +                    K                    ,                    B                    ;                    b                    :                    \                    E                     ]                    ?                    L                    S                     T           (         ^           0         c           8         -           @         .           H         /           P         0           X         1           `         2           h         3           p         4           x         5                    6                    7                    8           napi_get_value_string_utf8(env, argv[2], NULL, 0, &to_path_size) failed! napi_set_named_property(env, exports, "fs_ext_napi_trim", fs_ext_napi_trim_fn) failed! napi_set_named_property(env, exports, "sizeof_" "fs_ext_napi_set_attr_t", fs_ext_napi_set_attr_t_sizeof) failed! napi_set_named_property(env, exports, "fs_ext_napi_wait_for_downgrade_lock", fs_ext_napi_wait_for_downgrade_lock_fn) failed! napi_set_named_property(env, exports, "fs_ext_napi_remove_attr", fs_ext_napi_remove_attr_fn) failed! fs_ext_napi_sparse napi_get_cb_info(env, info, &argc, argv, NULL, NULL) failed! fs_ext_napi_try_downgrade_lock sizeof_fs_ext_napi_lock_t napi_create_function(env, NULL, 0, fs_ext_napi_trim, NULL, &fs_ext_napi_trim_fn) failed! napi_set_named_property(env, exports, "fs_ext_napi_get_attr", fs_ext_napi_get_attr_fn) failed! napi_create_uint32(env, sizeof(fs_ext_napi_get_attr_t), &fs_ext_napi_get_attr_t_sizeof) failed! napi_set_named_property(env, exports, "fs_ext_napi_wait_for_upgrade_lock", fs_ext_napi_wait_for_upgrade_lock_fn) failed! napi_get_buffer_info(env, argv[3], (void **) &value, &value_len) failed! napi_create_function(env, NULL, 0, fs_ext_napi_wait_for_lock, NULL, &fs_ext_napi_wait_for_lock_fn) failed! fs_ext_napi_trim napi_create_uint32(env, sizeof(fs_ext_napi_swap_t), &fs_ext_napi_swap_t_sizeof) failed! fs_ext_napi_try_lock napi_set_named_property(env, exports, "sizeof_" "fs_ext_napi_swap_t", fs_ext_napi_swap_t_sizeof) failed! napi_create_function(env, NULL, 0, fs_ext_napi_try_lock, NULL, &fs_ext_napi_try_lock_fn) failed! sizeof_fs_ext_napi_swap_t sizeof_fs_ext_napi_list_attrs_t napi_set_named_property(env, exports, "fs_ext_napi_list_attrs", fs_ext_napi_list_attrs_fn) failed! fs_ext_napi_swap napi_set_named_property(env, exports, "fs_ext_napi_swap", fs_ext_napi_swap_fn) failed! napi_get_value_string_utf8(env, argv[2], to_path, to_path_size + 1, &to_path_len) failed! napi_get_value_string_utf8(env, argv[2], name, name_size + 1, &name_len) failed! napi_set_named_property(env, exports, "fs_ext_napi_try_downgrade_lock", fs_ext_napi_try_downgrade_lock_fn) failed! napi_create_function(env, NULL, 0, fs_ext_napi_swap, NULL, &fs_ext_napi_swap_fn) failed! napi_get_value_string_utf8(env, argv[1], NULL, 0, &from_path_size) failed! napi_set_named_property(env, exports, "fs_ext_napi_try_upgrade_lock", fs_ext_napi_try_upgrade_lock_fn) failed! fs_ext_napi_wait_for_upgrade_lock napi_create_function(env, NULL, 0, fs_ext_napi_unlock, NULL, &fs_ext_napi_unlock_fn) failed! napi_create_function(env, NULL, 0, fs_ext_napi_set_attr, NULL, &fs_ext_napi_set_attr_fn) failed! napi_create_uint32(env, sizeof(fs_ext_napi_lock_t), &fs_ext_napi_lock_t_sizeof) failed! napi_set_named_property(env, exports, "fs_ext_napi_wait_for_lock", fs_ext_napi_wait_for_lock_fn) failed! napi_set_named_property(env, exports, "fs_ext_napi_sparse", fs_ext_napi_sparse_fn) failed! napi_get_value_string_utf8(env, argv[1], from_path, from_path_size + 1, &from_path_len) failed! napi_create_function(env, NULL, 0, fs_ext_napi_wait_for_downgrade_lock, NULL, &fs_ext_napi_wait_for_downgrade_lock_fn) failed! Expected unsigned number napi_create_uint32(env, sizeof(fs_ext_napi_trim_t), &fs_ext_napi_trim_t_sizeof) failed! napi_create_uint32(env, sizeof(fs_ext_napi_set_attr_t), &fs_ext_napi_set_attr_t_sizeof) failed! napi_set_named_property(env, exports, "sizeof_" "fs_ext_napi_remove_attr_t", fs_ext_napi_remove_attr_t_sizeof) failed! fs_ext_napi_unlock napi_create_function(env, NULL, 0, fs_ext_napi_sparse, NULL, &fs_ext_napi_sparse_fn) failed! sizeof_fs_ext_napi_set_attr_t napi_set_named_property(env, exports, "fs_ext_napi_try_lock", fs_ext_napi_try_lock_fn) failed! fs_ext_napi_wait_for_lock napi_create_function(env, NULL, 0, fs_ext_napi_wait_for_upgrade_lock, NULL, &fs_ext_napi_wait_for_upgrade_lock_fn) failed! fs_ext_napi_set_attr napi_set_named_property(env, exports, "sizeof_" "fs_ext_napi_get_attr_t", fs_ext_napi_get_attr_t_sizeof) failed! napi_create_uint32(env, sizeof(fs_ext_napi_remove_attr_t), &fs_ext_napi_remove_attr_t_sizeof) failed! napi_set_named_property(env, exports, "sizeof_" "fs_ext_napi_list_attrs_t", fs_ext_napi_list_attrs_t_sizeof) failed! fs_ext_napi_wait_for_downgrade_lock EINVAL napi_set_named_property(env, exports, "sizeof_" "fs_ext_napi_lock_t", fs_ext_napi_lock_t_sizeof) failed! napi_set_named_property(env, exports, "sizeof_" "fs_ext_napi_trim_t", fs_ext_napi_trim_t_sizeof) failed! napi_create_uint32(env, sizeof(fs_ext_napi_sparse_t), &fs_ext_napi_sparse_t_sizeof) failed! sizeof_fs_ext_napi_get_attr_t napi_create_uint32(env, sizeof(fs_ext_napi_list_attrs_t), &fs_ext_napi_list_attrs_t_sizeof) failed! napi_create_function(env, NULL, 0, fs_ext_napi_try_upgrade_lock, NULL, &fs_ext_napi_try_upgrade_lock_fn) failed! napi_create_function(env, NULL, 0, fs_ext_napi_get_attr, NULL, &fs_ext_napi_get_attr_fn) failed! sizeof_fs_ext_napi_remove_attr_t napi_set_named_property(env, exports, "fs_ext_napi_unlock", fs_ext_napi_unlock_fn) failed! napi_create_function(env, NULL, 0, fs_ext_napi_remove_attr, NULL, &fs_ext_napi_remove_attr_fn) failed! fs_ext_napi_list_attrs sizeof_fs_ext_napi_sparse_t napi_create_function(env, NULL, 0, fs_ext_napi_try_downgrade_lock, NULL, &fs_ext_napi_try_downgrade_lock_fn) failed! fs_ext_napi_remove_attr napi_get_buffer_info(env, argv[0], (void **) &req, &req_len) failed! napi_set_named_property(env, exports, "fs_ext_napi_set_attr", fs_ext_napi_set_attr_fn) failed! napi_get_value_string_utf8(env, argv[2], NULL, 0, &name_size) failed! sizeof_fs_ext_napi_trim_t napi_set_named_property(env, exports, "sizeof_" "fs_ext_napi_sparse_t", fs_ext_napi_sparse_t_sizeof) failed! fs_ext_napi_try_upgrade_lock fs_ext_napi_get_attr napi_create_function(env, NULL, 0, fs_ext_napi_list_attrs, NULL, &fs_ext_napi_list_attrs_fn) failed!                                                            
   
       ;0  E     L      \"    %    \'  ,  )  d  +    .    /    <2  D  5  |  8    \;    l>  4  A  l  D    H    K  ,  <O  d  Q    LU    W    |\  d  j    Lj    j    j    j    k    Lk  ,  |k  L  k  d  k  |  l    ,l    ll    l    l  	  l  	  m  <	  ,m  T	  \m  l	  |m  	  m  	  m  	  n  	  Ln  	  n  
  n  ,
  n  D
  o  \
  ,o  |
  Lo  
  |o  
  o  
  o  
  o    p    p  4  ,p  L  <p  d  p    p    Lq    |q    q    <r  T  lr  t  r           zR x  4      x     ABA D`\ ABAA`    4   T         ABA G ABAA   4        I   ABA DP< ABA       4      "     ABA D`\ ABAA`    4      ($  {   ABA D ABAA   4   4  p&     ABA D`\ ABAA`    4   l  '  {   ABA D ABAA   4     0*     ABA D`\ ABAA`    4     +  {   ABA D ABAA   4     -  I   ABA DP< ABA       4   L  1  }   ABA Dp ABAAp     4     P3  I   ABA DP< ABA       D     h6     ABB B(A0G0A(B BBAA  4     09  a   ABA DPT ABA       <   <  h<     ABB A(D(A BBAA   <   |  >  J   ABB A(D`9(A BBA       <     B      ABB A(G(A BBAA   4     E  U   ABA DPH ABA       <   4  H     ABB A(D(A BBAA   4   t  @K  _   ABA DPR ABA       4     hN  }   ABA Dp ABAAp     L     P     ABB B(B0A8D8A0B(B BBA      ,   4  U     BAA AB          d  b  #    Aa    |  b  =                b  +    Ai            b                  b  #    Aa      b  ;                c  %    Ac            (c  #    Aa    4  @c  ;              L  hc  %    Ac          l  xc                  pc  1                c  %    Ac            c                  c  #                c      AU            c                $  c  +              <  c      A]          \  c                t  c  4                d  %    Ac            (d  7    D r      Pd  5                xd  %    Ac            d                  d  *              ,  d      A\          L  d                d  d  #              |  d  %    Ac            d  2    Al            d  
                d  
                d  
              	  d  
              	  d                4	  d  V    D0@A0P     T	  e  V    D0@A0P     t	  Pe  J    D0tA0P      	  e  %    AVAH      	  e  7    AhAH   L   	  e  q    ABB A(A0M(A BBAA0K(A BBA         $
  e  )    AZAH      D
  e      AMAH   d   d
  e  ;   ABB B(B0A8A@8A0B(B BBAE@8A0B(B BBA                       H=A~  H:~  H9tHm  Ht	        H=~  H5
~  H)HH?HHHtHem  HtfD      =m   u+UH=Bm   HtH=}  iV  dE  ]     wUAVSH@HHD$   HT$HL$ E1E1'V  	   wHcH4H1V  tHH1   Ht$ HT$HU  	   wHcH4H1U  u|Ht$(HT$HU  	   wHcHY4H1U  u>Ht$0HT$H|U  	   wHcH4H1DU  tIH5H4HJU  	   wHcH4H1U  1H@[A^]Ht$8HT$HU  tH5+HHU  |$U  t$|$T$    U  yU  IU  HLHfUAVSH   HHD$8   HT$8HL$@E1E1DT  	   wHcH4H1,T  t	H[Ht$@H$    HT$HL$LD$0HE1T  xpD$wHHgHd$0HoT  tbHAH1S  	   wHcHi4H1S  1H   [A^]	   H1mS  uHt$HHT$,HgS  	   wHcH4H1/S  u>Ht$PHT$(H)S  	   wHcH4H1R  tH57HHHt$XHT$$HR  uHt$`HT$ HR  tH5HHR  HL$H   Ht$hH   H   S  Ht$p   HL$H   R  Ht$HS  Hl$Lt$|$,R  L$(|$ DD$$A   A H@   H$HLR  e^R  IdR  HLH<fD  UAVSH0IH   Ht$(HR  	   	   wHcH[4H1Q  I   HT$ H`R  wHcH$,H1KQ  I   HT$H'R  	   wHcH4H1Q  A   xHt$HQ     ]Q  HL$HHHQ  	   	   wHcH4H1P  A   Q  HHHHQ  wHcH<,H1cP  Ht$H$HL$HmQ  	   wHcH4H1%P  Ht$ HT$LD$   HE16Q  	   wHcH4H1O  
   Ht$HQ  HD$xuH$    HMP  nHHP  	   wHcHO4H1xO  H4$Ht2HP  	   wHcH4H1?O  HO  Ht$(HP  	   	   wHcH4H1N  I   HlP  wHcH,H1N  I   H8P  	   wHcHg4H1N  H0[A^]    UAVSH@HHD$   HT$HL$ E1E1GN  	   wHcH4H1/N  tHH1   Ht$ HT$HN  	   wHcH4H1M  u|Ht$(HT$HM  	   wHcHy4H1M  u>Ht$0HT$HM  	   wHcH;4H1dM  tIH5HTHjM  	   wHcH4H1"M  1H@[A^]|$^M  t$T$N  ybM  IhM  HLHM       UAVSHpHHD$8   HT$8HL$@E1E1L  	   wHcHV4H1L  t	Hb[Ht$@H$    HT$HL$LD$0HE1L  xmD$wHHHd$0HL  t_HH1-L  	   wHcH4H1K  1Hp[A^]	   H1K  uHt$HHT$,HK  	   wHcH\4H1K  u>Ht$PHT$(HK  	   wHcH4H1GK  tH5H7HHt$XHT$$HKK  tH5aHHAK  HL$H   Ht$`H   H   K  Ht$h   HL$H   kK  Ht$HnK  Hl$Lt$|$,J  L$(DD$$LHLL  J  IJ  HLHOD  UAVSH@HHD$   HT$HL$ E1E1J  	   wHcH4H1I  tHH1   Ht$ HT$HI  	   wHcH4H1I  u|Ht$(HT$HI  	   wHcHI4H1rI  u>Ht$0HT$HlI  	   wHcH4H14I  tIH5zH$H:I  	   wHcH4H1H  1H@[A^]|$.I  t$T$J  y2I  I8I  HLHH       UAVSHpHHD$8   HT$8HL$@E1E1gH  	   wHcH&4H1OH  t	H2[Ht$@H$    HT$HL$LD$0HE1H  xmD$wHHHd$0HH  t_HdH1G  	   wHcH4H1G  1Hp[A^]	   H1G  uHt$HHT$,HG  	   wHcH,4H1UG  u>Ht$PHT$(HOG  	   wHcH4H1G  tH5]HHHt$XHT$$HG  tH51HHG  HL$H   Ht$`H   H   WG  Ht$h   HL$H   ;G  Ht$H>G  Hl$Lt$|$,F  L$(DD$$LHLH  F  IF  HLHOD  UAVSH@HHD$   HT$HL$ E1E1E  	   wHcH4H1E  tHH1   Ht$ HT$HE  	   wHcHW4H1E  u|Ht$(HT$HzE  	   wHcH4H1BE  u>Ht$0HT$H<E  	   wHcH4H1E  tIH5JHH
E  	   wHcH4H1D  1H@[A^]|$D  t$T$oF  yE  IE  HLHD       UAVSHpHHD$8   HT$8HL$@E1E17D  	   wHcH4H1D  t	H[Ht$@H$    HT$HL$LD$0HE1{D  xmD$wHHZHd$0HbD  t_H4H1C  	   wHcH\4H1C  1Hp[A^]	   H1cC  uHt$HHT$,H]C  	   wHcH4H1%C  u>Ht$PHT$(HC  	   wHcH4H1B  tH5-HHHt$XHT$$HB  tH5HHB  HL$H   Ht$`H   H   'C  Ht$h   HL$H   C  Ht$HC  Hl$Lt$|$,B  L$(DD$$L;   HLC  }B  IB  HLHOD  UAVSH0IH   Ht$(HB  	   	   wHcH{4H1A  I   HT$ HB  wHcHD,H1kA  I   HT$HGB  	   wHcH4H1/A  A   xHt$HB     }A  HL$HHHB  	   	   wHcH4H1@  A   =A  HHHHA  wHcH\,H1@  Ht$H$HL$HA  	   wHcH4H1E@  Ht$ HT$LD$   HE1VA  	   wHcH4H1?  
   Ht$H(A  HD$xuH$    Hm@  nHHA  	   wHcHo4H1?  H4$Ht2H@  	   wHcH64H1_?  H?  Ht$(H@  	   	   wHcH4H1?  I   H@  wHcH,H1>  I   HX@  	   wHcH4H1>  H0[A^]    UAVSHPHHD$(   HT$(HL$0E1E1g>  	   wHcH&4H1O>  t	H2[Ht$0H$    HT$HL$LD$ HE1>  xmD$wHHHd$ H>  t_HdH1=  	   wHcH4H1=  1HP[A^]	   H1=  uHt$8HT$H=  	   wHcH,4H1U=  tH5HEHYHL$H   Ht$@H   H   ?  	   	   wHcH4H1<  Ht$H   HL$H   >  wHcH,H1<  Ht$H>  	   wHcHJ4H1s<  Hl$Lt$|$<  H9   HL\>  <  I<  HLHA UAVSH0IH   Ht$(H<  	   	   wHcH4H1;  I   HT$ H<  wHcHt,H1;  I   HT$Hw<  	   wHcH64H1_;  A   xHt$HG<     ;  HL$HHH6<  	   	   wHcH4H1:  A   m;  HHHH;  wHcH,H1:  Ht$H$HL$H;  	   wHcHL4H1u:  Ht$ HT$LD$   HE1;  	   wHcH4H1.:  
   Ht$HX;  HD$xuH$    H:  nHH@;  	   wHcH4H19  H4$Ht2H;  	   wHcHf4H19  H%:  Ht$(H:  	   	   wHcH"4H1K9  I   H:  wHcH,H19  I   H:  	   wHcH4H18  H0[A^]    UAWAVATSH   HHD$8   HT$8HL$@E1E18  	   wHcHO4H1x8  tH[#  Ht$@H$    HT$HL$ LD$0HE18  x5D$wHHHd$0H8  t'H   	   H17  uHD$    Ht$HLD$H119  xHb8  t$H$p	   H17  uLd$1MIIEL9  IHt$HLD$xHHH9  xaMtC& H7  tfHhH1[7  	   wHcH4H17  1H   [A\A^A_]	   H16  uHD$A HD$    Ht$PLD$H118  t	H7Hl$HH8  IHt$PLD$pHHH8  tHoH16  WHD$A HL$ H   Ht$XH   H   6  Ht$`   HL$ H   6  Ht$(H6  H|$(Ht$ LA   LLF8  U6  I[6  HLHYf.      UAVSH0IH   Ht$(H6  	   	   wHcHK4H1t5  I   HT$ HP6  wHcH,H1;5  I   HT$H6  	   wHcH4H14  A   xHt$H5     M5  HL$HHH5  	   	   wHcHp4H14  A   5  HHHH5  wHcH,,H1S4  Ht$H$HL$H]5  	   wHcH4H14  Ht$ HT$LD$   HE1&5  	   wHcH4H13  
   Ht$H4  HD$xuH$    H=4  nHH4  	   wHcH?4H1h3  H4$Ht2H4  	   wHcH4H1/3  H3  Ht$(H4  	   	   wHcH4H12  I   ?5  I   35  I   HD4  wHcHx,H12  I   H4  	   wHcH?4H1h2  H0[A^]f.     D  UAWAVSHxHHD$8   HT$8HL$@E1E12  	   wHcH4H11  t	H[Ht$@H$    HT$HL$LD$0HE1Y2  xoD$wHH8Hd$0H@2  taHH11  	   wHcH:4H1c1  1Hx[A^A_]	   H1?1  uHt$HHT$$H91  	   wHcH4H11  tH5GHHWHD$    Ht$PLD$H112  xH\1  t'H	   H10  uHl$HH2  IHt$PLD$pHHH2  tHH10  HD$A HL$H   Ht$XH   H   0  Ht$`   HL$H   0  Ht$(H0  Hl$(L|$|$$00  L9   HLL92  ^(0  I.0  HLHKUAWAVSH8IIH   Ht$0H\0  	   	   wHcH&4H1O/  I   HT$(H+0  wHcH,H1/  I   HT$ H/  	   wHcH4H1.  A        -/  HHHH/  	   	   wHcHR4H1{.  A   .  HL$HHHh/  wHcH,H13.  H4$HT$HL$H=/  	   	   wHcH4H1-  Ht$H.  wHcH,HkHt$H.  	   wHcHg4H1-  A   u7Ht$Hy.  	   wHcH(4H1Q-  LIwHL$HH/  	   wHcH4H1-  H<$I7IW/  Ht$(HT$ LD$   HE1.  	   wHcH4H1,  
   HH-  H$xuHD$    H--  qHt$H-  	   wHcH-4H1V,  Ht$Ht2H-  	   wHcH4H1,  H,  Ht$0Hu-  	   	   wHcH4H1+  I   ,.  I   H=-  wHcHq,H1+  I   H	-  	   wHcH84H1a+  H8[A^A_]fD  UAWAVSH   HHD$X   HT$XHL$`E1E1+  	   wHcH4H1*  t	H[Ht$`H$    HT$(HL$LD$PHE1V+  xrD$(wHH5Hd$PH=+  tdHH1*  	   wHcH74H1`*  1H   [A^A_]	   H19*  uHt$hHT$$H3*  	   wHcH4H1)  tH5AHHTHD$    Ht$pLD$H11+  xHV*  t'H	   H1)  uHl$HH+  IHt$pL$   HHH+  t	H,HD$A Ht$xHT$HHL$@H+  tHH1Y)  HL$H   H$   H   H   )  H$      HL$H   })  Ht$8H)  H|$Ht$@b+  HD$(HT$0Hl$8L|$|$$(  L>   LD$(HLL9+  (  I(  HLH2UAVSH0IH   Ht$(H)  	   	   wHcH4H1(  I   HT$ H(  wHcH,H1'  I   HT$H(  	   wHcHf4H1'  A   xHt$Hw(     '  HL$HHHf(  	   	   wHcH 4H1)'  A   '  HHHH(  wHcH,H1&  Ht$H$HL$H'  	   wHcH|4H1&  Ht$ HT$LD$   HE1'  	   wHcH54H1^&  
   Ht$H'  HD$xuH$    H&  nHHp'  	   wHcH4H1%  H4$Ht2HG'  	   wHcH4H1%  HU&  Ht$(H'  	   	   wHcHR4H1{%  I   '  I   H&  wHcH,H1;%  I   H&  	   wHcH4H1%  H0[A^]f.     UAWAVSHxHHD$8   HT$8HL$@E1E1$  	   wHcHt4H1$  t	H[Ht$@H$    HT$HL$LD$0HE1$  xoD$wHHHd$0H$  taHH1K$  	   wHcH4H1$  1Hx[A^A_]	   H1#  uHt$HHT$$H#  	   wHcHx4H1#  tH5HHWHD$    Ht$PLD$H11%  xH#  t'Hr	   H15#  uHl$HHP%  IHt$PLD$pHHHE%  tHJH10#  HD$A HL$H   Ht$XH   H   l#  Ht$`   HL$H   P#  Ht$(HS#  Hl$(L|$|$$"  L9   HLL9%  ^"  I"  HLHKUAVSH0IH   Ht$(H#  	   	   wHcH4H1!  I   HT$ H"  wHcH,H1!  I   HT$H"  	   wHcHV4H1!  A         !  HL$HHH["  	   	   wHcH4H1!  A   !  HHHH"  wHcH,H1   Ht$H$HL$H!  Ht$H!  	   wHcHb4H1   Ht$ HT$LD$   HE1!  	   wHcH4H1D   
   Ht$Hn!  HD$xuH$    H   nHHV!  	   wHcH4H1  H4$Ht2H-!  	   wHcH|4H1  H;   Ht$(H   	   	   wHcH84H1a  I   !  I   H   wHcH,H1!  I   H   	   wHcH4H1  H0[A^]UAVSHPHHD$(   HT$(HL$0E1E1  	   wHcHf4H1  t	Hr[Ht$0H$    HT$HL$LD$ HE1  xmD$wHHHd$ H  t_HH1=  	   wHcH4H1  1HP[A^]	   H1  uHt$8HT$H  	   wHcHl4H1  tH5HHYHL$H   Ht$@H   H   F  	   	   wHcH 4H1)  Ht$H   HL$H     wHcH,H1  Ht$H  	   wHcH4H1  Hl$Lt$|$  H9   HLl    I  HLHA UAWAVAUATSHHIHT$(HL   Ht$@L  	   	   wHcH4L1  H   HT$8L  wHcHL1  H   HT$0L  	   wHcHh4L1     Hl$   Ht$Lq  	   	   wHcH4L1D  HT$LL$  wHcHL1  M  1HL%$     LD1  HI9k  HD$(H4LHH  HA	   	   wHcA4L1  Ht$H$L  HwHcE4|  HLHHb  	   	   wHcH4L1%       HL$LHH  wHcHL1  H4$HT$HL$L  	   	   wHcHr4L1  Ht$L  wHcHBL1i  Ht$8HT$0LD$   LE1z  	   wHcH4L1"  
Hl$    HLI  H$xuHD$    L  qHt$L/  	   wHcH4L1  Ht$Ht2L  	   wHcHT4L1}  L  Ht$@L  	   	   wHcH4L19  H   L  wHcHL1  H   Lv  	   wHcH4L1  HH[A\A]A^A_]f.     D  AVSPIHH     	   wHcHH4H1q  tHm  H$HHLk  	   wHcH4H1#  tHp  HH     	   wHcH4H1  tH|  H$H'HL  	   wHcHd4H1  tHC.  HH   }  	   wHcH4H1E  tHd  H$HHL?  	   wHcH4H1  tHm  HH     	   wHcH4H1  tH^P  H$HHL  	   wHcH84H1a  tH}  HH   Q  	   wHcH4H1  tH*
  H$HHL  	   wHcH4H1  tHl
  HH     	   wHcHZ4H1  tH$
  H$H"HL}  	   wHcH4H15  tH	  HH   %  	   wHcH4H1  tH4	  H$HHL  	   wHcHv4H1  tHg@	  HH     	   wHcH.4H1W  tH  H$HGHLQ  	   wHcH4H1	  tH  H)  IH11E1  	   wHcH4H1  tH=Y  H$HHL  	   wHcHA4H1j  tH7  H)  IH11E1q  	   wHcH4H1  tHL  H$H5HL  	   wHcH4H1  tHl  Ht(  IH11E1  	   wHcHQ4H1z  tH_  H$HHLt  	   wHcH4H1,  tH  H'  IH11E13  	   wHcH4H1  tHS|  H$HHL  	   wHcHd4H1  tH{.  HF'  IH11E1  	   wHcH4H1<  tH9  H$HHL6  	   wHcH4H1  tH  H&  IH11E1  	   wHcHt4H1  tH>  H$HHL  	   wHcH&4H1O  tH  H&  IH11E1V  	   wHcH4H1  tH<  H$H-HL  	   wHcH4H1  tHQ  H%  IH11E1  	   wHcH64H1_  tH   H$HHLY  	   wHcH4H1  tH7  H$  IH11E1  	   wHcH4H1  tHa  H$HHL  	   wHcHI4H1r  tH/  HS$  IH11E1y  	   wHcH4H1!  tH*  H$HHL  	   wHcH4H1  tHgt  H#  IH11E1  	   wHcHY4H1  tH#  H$HrHL|  	   wHcH4H14  tH  H%#  IH11E1;  	   wHcH4H1  tH~  H$HHL  	   wHcHl4H1  tHL6  H"  IH11E1  	   wHcH4H1D  tH   H$HHL>  	   wHcH4H1
  tHa   H!  IH11E1  	   wHcH|4H1
  t	HIH$HJHL  	   wHcH14H1Z
  t9HzH1e
  	   wHcH4H1
  LH[A^PJ  HDDYf.      HD$   H   L   D   H   H6H   H8      SH   H   H           [D  H?H   Ht        P  HDDYf.         H   L         L   H6H   Hz5  D  SH   H   H   C     [f.     P:  HDDYf.         H   L         L   H6H   H  D  SH   H   H        [f.       f.        H   L   L   H6H   HD     f.     D  SH   H   H   c     [f.     H?H   Ht           H   H6H   H2   
  f.      SH        [f     H?H   Ht        H   H   L   H6H   H*   %
  D  SHH   H   
     [H?H   Ht           H   W   L   H6H   HA   	  f.     fSH   H   H   #
     [f.     HH?   )$H   Ht   HH<$N  Hf        H   A    L   H6H   H@     f.     SH   H   H   	     [f.     H?H   Ht           H   L   H6H   H+   v  fD  SH   H   	     [fH?H   Ht           H   H6H   HB     f.      SH   H   H        [f.     SH?H   H   Ht   H   HH[     v  fD       fD     V  fD     f  fD  1H(1fD$fD$
  Ht$HT$D$     HT$%   1  tH(  8  H(f.     H(1fD$fD$
  Ht$HT$D$     HT$&   1  tH(  8  H(f.     H(D$   Ht$HT$D$     HT$%   11  tH(2  8;  H(fD  PHH   /  tY  8X  f.     PIH<  A   1  tY  8X  f     UAWAVSPII11  Ht;Hcx  H  HIIVLH  t1H[A^A_]P  8H[A^A_]O  f.     D  PHHJHE1m  t1Y  8X      PZ  t1Y  8X  @ UAWAVAUATSPII114  tqHcH  IIHH  tNM'I    IML4$tR   E1E1f.     J<3  III/IHM9rI  8H[A\A]A^A_]D  E1K4,H  IH$L8K,/HLL  MtNH|  HHI/L9s7A       H$L8K,/HHJ  HHK,7IL9r1H[A\A]A^A_] HH  HtH HH           5Z'  %\'  @ %Z'  h    %R'  h   %J'  h   %B'  h   %:'  h   %2'  h   %*'  h   %"'  h   p%'  h   `%'  h	   P%
'  h
   @%'  h   0%&  h    %&  h   %&  h    %&  h   %&  h   %&  h   %&  h   %&  h   %&  h   %&  h   %&  h   %&  h   p%&  h   `%&  h   P%&  h   @%&  h   0%z&  h    %r&  h   %j&  h    %b&  h   %Z&  h    %R&  h!   %J&  h"   %B&  h#   %:&  h$   %2&  h%   %*&  h&   %"&  h'   p%&  h(   `%&  h)   P%
&  h*   @%&  h+   0%%  h,    %%  h-   %%  h.    %%  h/   %%  h0   %%  h1   %%  h2   %%  h3   %%  h4   %%  h5   %%  h6   %%  h7   p%%  h8   `%%  h9   P%%  h:   @%%  h;   0%z%  h<    %r%  h=   %j%  h>    %b%  h?   %Z%  h@   %R%  hA   %J%  hB   %B%  hC   %:%  hD   %2%  hE   %*%  hF   %"%  hG   p%%  hH   `%%  hI   P%
%  hJ   @%%  hK   0%$  hL    %$  hM   %$  hN    %$  hO   %$  hP                          r                          (                   	              o                                                                                                   d      
             o                                                                        l                   o          o          o                                                                                                                                                                                                                                                   &      6      F      V      f      v                                                                  &      6      F      V      f      v                                                                  &      6      F      V      f      v                                                                  &      6      F      V      f      v                                                                  &      6      F      V      f      v                              Ubuntu clang version 14.0.0-1ubuntu1.1 GCC: (Ubuntu 12.3.0-1ubuntu1~22.04) 12.3.0  Linker: Ubuntu LLD 14.0.0                                                                        S              .     S              A      T              W                  c                        `T                                                                            Y      I           h      I           n      I           u      a           0{      J                U      #          _      9    p            N                   W    0      +       i    `                       %                 %                 %           @                                                                 !                  9          %       O          7       k    0      %           `                                                          %           P      2                                                                &    8              e                 C   l              _                 I                  
                  4                      q                                              "                       pT                                                                                                )                     ?                     P                     a          #       q                     }                         PV                                                                                                          =                            ,                     C                     O                     e                     u                                                                                                                                  P\            +          #       E     ^      {      i          ;           `                       #           0b      {          P      ;           d                                 `f      {      .          1       :    0l      }      M                     a                     q    `      #            r                                                                                     +                                x                @      4                                                                  3                     H                     T          5       d                |          *                 }                #                                                                                       	                     "	                     5	          V       F	                     T	    @      V       j	          
       	          
       	          
       	          
       	          J       	          %       	                 
           7       
    `      q       %
          )       6
                 J
    0      ;      ]
                     c
                     t
                     
                     
                     
                     
                     
                     
                     
                     
                     
                      .note.gnu.build-id .dynsym .gnu.version .gnu.version_r .gnu.hash .dynstr .rela.dyn .rela.plt .rodata .eh_frame_hdr .eh_frame .text .init .fini .plt .fini_array .init_array .dynamic .got .data .tm_clone_table .got.plt .bss .comment .symtab .shstrtab .strtab  crtstuff.c __TMC_LIST__ deregister_tm_clones register_tm_clones __do_global_dtors_aux completed.0 __do_global_dtors_aux_fini_array_entry frame_dummy __frame_dummy_init_array_entry binding.c on_fs_ext_lock on_fs_ext_trim on_fs_ext_sparse on_fs_ext_swap on_fs_ext_get_attr on_fs_ext_set_attr on_fs_ext_remove_attr on_fs_ext_list_attrs shared.c fs_ext__lock_work fs_ext__lock_after_work fs_ext__downgrade_lock_work fs_ext__upgrade_lock_work fs_ext__trim_work fs_ext__trim_after_work fs_ext__sparse_work fs_ext__sparse_after_work fs_ext__swap_work fs_ext__swap_after_work fs_ext__get_attr_work fs_ext__get_attr_after_work fs_ext__set_attr_work fs_ext__set_attr_after_work fs_ext__remove_attr_work fs_ext__remove_attr_after_work fs_ext__list_attrs_work fs_ext__list_attrs_after_work posix.c linux.c crtstuff.c __FRAME_END__ __gmon_start__ _init _GLOBAL_OFFSET_TABLE_ _fini __TMC_END__ _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __dso_handle __cxa_finalize fs_ext_napi_try_lock js_get_callback_info napi_set_last_error_info js_get_value_uint32 js_throw_error napi_get_value_uint32 napi_throw_error uv_get_osfhandle fs_ext_try_lock uv_err_name uv_strerror fs_ext_napi_wait_for_lock js_get_typedarray_info napi_clear_last_error_info napi_create_reference napi_get_uv_event_loop fs_ext_wait_for_lock js_open_handle_scope js_get_reference_value js_get_null js_create_string_utf8 js_create_error js_call_function_with_checkpoint napi_get_last_error_info js_get_and_clear_last_exception js_fatal_exception js_close_handle_scope js_delete_reference fs_ext_napi_try_downgrade_lock fs_ext_try_downgrade_lock fs_ext_napi_wait_for_downgrade_lock fs_ext_wait_for_downgrade_lock fs_ext_napi_try_upgrade_lock fs_ext_try_upgrade_lock fs_ext_napi_wait_for_upgrade_lock fs_ext_wait_for_upgrade_lock fs_ext_napi_unlock fs_ext_unlock fs_ext_napi_trim fs_ext_trim fs_ext_napi_sparse js_create_reference js_get_env_loop fs_ext_sparse fs_ext_napi_swap js_get_value_string_utf8 malloc napi_get_value_string_utf8 fs_ext_swap free fs_ext_napi_get_attr fs_ext_get_attr js_create_arraybuffer memcpy fs_ext_napi_set_attr napi_get_buffer_info uv_buf_init fs_ext_set_attr fs_ext_napi_remove_attr fs_ext_remove_attr fs_ext_napi_list_attrs fs_ext_list_attrs js_create_array_with_length js_set_element napi_register_module_v1 js_create_uint32 js_set_named_property js_create_function fs_ext__try_lock uv_queue_work fs_ext__wait_for_lock fs_ext__try_downgrade_lock fs_ext__wait_for_downgrade_lock fs_ext__try_upgrade_lock fs_ext__wait_for_upgrade_lock fs_ext__unlock fs_ext__trim fs_ext__sparse fs_ext__swap fs_ext__get_attr fs_ext__set_attr fs_ext__remove_attr fs_ext__list_attrs fcntl __errno_location uv_translate_sys_error fallocate syscall fgetxattr fsetxattr fremovexattr flistxattr strlen realloc memmove _DYNAMIC                                                                                   p      p                                                             `	                             o                                               )   o                   P                            8   o                     d                            B             d      d                                   J             (      (                                 T      B                                               ^      2                                                f             6      6      4                             t             8      8      
                             ~             S      C      V                                          l      l                                                                                                                                                                                                                                                                                                                               `      `                                                                                                                                                                                                                                                                      0                     m                                                                  0                                                                                                      
                             'use strict'
const fs = require('fs')
const fsext = require('fs-native-extensions')

const LOCK_POLL_INTERVAL = 500
const POLL_MAX_TRIES = 20

class Internal {
  _pinging = true
  _ping (method) { return () => this._pinging && method.request({ beat: 'ping' }) }
}

class API extends Internal {
  #ipc = null

  constructor (ipc) {
    super()
    this.#ipc = ipc
  }

  wakeup (method) {
    return (link, storage, appdev, selfwake, startId) => method.request({ args: [link, storage, appdev, selfwake, startId] })
  }

  shutdown (method) {
    return async () => {
      if (this.#ipc.closed || this.#ipc.closing) return
      this._pinging = false
      method.send()
      const fd = await new Promise((resolve, reject) => {
        let tries = 0
        let interval = null
        const poll = () => {
          fs.open(this.#ipc._lock, 'r+', (err, fd) => {
            if (!err) {
              clearInterval(interval)
              resolve(fd)
            } else {
              tries++
              if (tries > POLL_MAX_TRIES) {
                clearInterval(interval)
                reject(err)
              }
            }
          })
        }
        interval = setInterval(poll, LOCK_POLL_INTERVAL)
        poll()
      })

      await fsext.waitForLock(fd)
      fsext.unlock(fd)
      await new Promise((resolve, reject) => fs.close(fd, (err) => {
        if (err) {
          reject(err)
          return
        }
        resolve()
      }))
      await this.#ipc.close()
    }
  }
}

module.exports = API
'use strict'
const { isBare } = require('which-runtime')
const Pipe = require('net') // import mapped to bare-pipe, less resolves
const path = require('path')
const RPC = require('tiny-buffer-rpc')
const any = require('tiny-buffer-rpc/any')
const ReadyResource = require('ready-resource')
const FramedStream = require('framed-stream')

const API = require('./api')
const methods = require('./methods')
const constants = require('./constants')

class PearIPCClient extends ReadyResource {
  #connect = null
  constructor (opts = {}) {
    super()
    this._opts = opts
    this._socketPath = opts.socketPath
    this._methods = opts.methods ? [...methods, ...opts.methods] : methods
    this._lock = opts.lock || path.join(constants.PEAR_DIR, 'corestores', 'platform', 'db', 'LOCK')
    const api = new API(this)
    if (opts.api) Object.assign(api, opts.api)
    this._api = api
    this._connectTimeout = opts.connectTimeout || constants.CONNECT_TIMEOUT
    this.#connect = opts.connect || null
    this._rpc = null
    this._internalHandlers = null

    this._rawStream = opts.stream || null
    this._stream = null

    this.userData = opts.userData || null

    this._onclose = this.close.bind(this)
  }

  ref () {
    this._heartbeat?.ref()
    this._timeout?.ref()
    if (this._rawStream?.ref) this._rawStream.ref()
  }

  unref () {
    this._heartbeat?.unref()
    this._timeout?.unref()
    if (this._rawStream?.unref) this._rawStream.unref()
  }

  async _open () {
    if (this._rawStream === null) {
      await this._connect()
    }
  }

  _setup () {
    this._stream = new FramedStream(this._rawStream)

    this._rpc = new RPC((data) => { this._stream.write(data) })
    this._stream.on('data', (data) => { this._rpc.recv(data) })
    this._stream.on('end', () => { this._stream.end() })
    this._stream.on('error', this._onclose)
    this._stream.on('close', this._onclose)

    this._register()

    this._heartbeat = setInterval(() => {
      this._beat()
    }, constants.HEARTBEAT_INTERVAL)
    this._beat()
  }

  async _beat () {
    try { await this._ping() } catch { /* ignore */ }
  }

  _createSendMethod (method) {
    return (params = {}) => method.send(params)
  }

  _createRequestMethod (method) {
    return (params = {}) => method.request(params)
  }

  _createStreamMethod (method) {
    return (params = {}) => {
      const stream = method.createRequestStream()
      stream.on('end', () => { stream.end() })
      stream.write(params)
      return stream
    }
  }

  _createMethod (definition) {
    if (definition.send) {
      return this._createSendMethod
    }

    if (!definition.stream) {
      return this._createRequestMethod
    }

    return this._createStreamMethod
  }

  _register () {
    for (const { id, ...def } of this._methods) {
      if (constants.ILLEGAL_METHODS.has(def.name)) throw new Error('Illegal Method: ' + def.name)
      const api = this._api[def.name]?.bind(this._api) || this._createMethod(def)

      this[def.name] = api(this._rpc.register(+id, {
        request: any,
        response: any
      }), this)
    }
  }

  _pipe () {
    if (isBare) return new Pipe(this._socketPath)
    const sock = new Pipe.Socket()
    sock.setNoDelay(true)
    sock.connect(this._socketPath)
    return sock
  }

  async _connect () {
    let trycount = 0
    let timedout = false
    let next = null

    this._timeout = setTimeout(() => {
      timedout = true
      this.close()
    }, this._connectTimeout)

    const onerror = () => {
      this._rawStream.removeListener('error', onerror)
      this._rawStream.removeListener('connect', onconnect)
      next(false)
    }

    const onconnect = () => {
      this._rawStream.removeListener('error', onerror)
      this._rawStream.removeListener('connect', onconnect)
      clearTimeout(this._timeout)
      next(true)
    }

    while (!this.closing) {
      const promise = new Promise((resolve) => { next = resolve })
      this._rawStream = this._pipe(this._socketPath)
      this._rawStream.on('connect', onconnect)
      this._rawStream.on('error', onerror)

      if (await promise) break
      if (timedout) throw new Error('Could not connect in time')
      if (trycount++ === 0 && typeof this.#connect === 'function') this.#connect()

      await new Promise((resolve) => setTimeout(resolve, trycount < 2 ? 5 : trycount < 10 ? 10 : 100))
    }

    clearTimeout(this._timeout)

    this._setup()

    if (this.closing) {
      if (this._rawStream) this._rawStream.destroy()
    }
  }

  _waitForClose () {
    return new Promise((resolve) => {
      if (this._stream.destroyed) {
        resolve()
      } else {
        this._stream.once('close', resolve)
        this._stream.end()
      }
    })
  }

  async _close () { // never throws, must never throw
    clearInterval(this._heartbeat)
    clearTimeout(this._timeout)

    if (this._stream) {
      await this._waitForClose()
      this._rawStream = null
      this._stream = null
    }
    this._rpc.destroy()
  }
}

module.exports = PearIPCClient
const { isWindows, isMac } = require('which-runtime')
const path = require('path')
const os = require('os')

const PEAR_DIR = global.Pear?.config.pearDir || (isMac
  ? path.join(os.homedir(), 'Library', 'Application Support', 'pear')
  : isWindows
    ? path.join(os.homedir(), 'AppData', 'Roaming', 'pear')
    : path.join(os.homedir(), '.config', 'pear'))

const CONNECT_TIMEOUT = 20_000
const HEARTBEAT_INTERVAL = 1500
const HEARBEAT_CLOCK = 5
const ILLEGAL_METHODS = new Set(['id', 'userData', 'clients', 'hasClients', 'client', 'ref', 'unref', 'ready', 'opening', 'opened', 'close', 'closing', 'closed'])

module.exports = {
  PEAR_DIR,
  CONNECT_TIMEOUT,
  HEARTBEAT_INTERVAL,
  HEARBEAT_CLOCK,
  ILLEGAL_METHODS
}
'use strict'
const PearIPCServer = require('./server')
const PearIPCClient = require('./client')

module.exports = { Server: PearIPCServer, Client: PearIPCClient }
'use strict'
const methods = [
  { id: 0, name: 'info', stream: true },
  { id: 1, name: 'dump', stream: true },
  { id: 2, name: 'seed', stream: true },
  { id: 3, name: 'stage', stream: true },
  { id: 4, name: 'release', stream: true },
  { id: 5, name: 'messages', stream: true },
  { id: 6, name: 'message' },
  { id: 7, name: 'config' },
  { id: 8, name: 'checkpoint' },
  { id: 9, name: 'versions' },
  { id: 10, name: 'address' },
  { id: 11, name: 'detached' },
  { id: 12, name: 'permit' },
  { id: 13, name: 'identify' },
  { id: 14, name: 'wakeup' },
  { id: 15, name: 'warming', stream: true },
  { id: 16, name: 'warmup' },
  { id: 17, name: 'run', stream: true },
  { id: 18, name: 'restart' },
  { id: 19, name: 'unloading' },
  { id: 20, name: 'closeClients' },
  { id: 21, name: 'createReport' },
  { id: 22, name: 'reports', stream: true },
  { id: 23, name: 'shutdown', send: true },
  { id: 24, name: 'shift', stream: true },
  { id: 25, name: 'build', stream: true },
  { id: 26, name: 'gc', stream: true },
  { id: 27, name: 'clearIdentity' },
  { id: 28, name: 'shareIdentity' },
  { id: 29, name: 'requestIdentity' },
  { id: 30, name: 'trustIdentity' },
  { id: 31, name: 'encryptionKey', stream: true },
  { id: 32, name: 'trusted' },
  { id: 33, name: 'touch', stream: true },
  { id: 34, name: '_ping' },
  { id: 35, name: 'drop', stream: true },
  { id: 36, name: 'data', stream: true },
  { id: 37, name: 'get' },
  { id: 38, name: 'entry' },
  { id: 39, name: 'exists' },
  { id: 40, name: 'compare' },
  { id: 41, name: 'reported' },
  { id: 42, name: 'cutover' }
]

module.exports = methods
{
  "name": "pear-ipc",
  "version": "6.4.0",
  "description": "IPC for Pear",
  "main": "index.js",
  "scripts": {
    "test": "brittle test.js",
    "lint": "standard"
  },
  "files": [
    "api.js",
    "index.js",
    "methods.js",
    "server.js",
    "client.js",
    "constants.js"
  ],
  "keywords": [],
  "author": "Holepunch",
  "license": "Apache-2.0",
  "dependencies": {
    "bare-fs": "^4.0.1",
    "bare-os": "^3.2.0",
    "bare-path": "^3.0.0",
    "bare-pipe": "^4.0.5",
    "framed-stream": "^1.0.1",
    "fs-native-extensions": "^1.2.7",
    "ready-resource": "^1.0.3",
    "streamx": "^2.16.1",
    "tiny-buffer-rpc": "^2.2.0",
    "which-runtime": "^1.2.0"
  },
  "imports": {
    "fs": {
      "bare": "bare-fs",
      "default": "fs"
    },
    "os": {
      "bare": "bare-os",
      "default": "os"
    },
    "path": {
      "bare": "bare-path",
      "default": "path"
    },
    "net": {
      "bare": "bare-pipe",
      "default": "net"
    }
  },
  "devDependencies": {
    "brittle": "^3.4.0",
    "standard": "^17.1.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/holepunchto/pear-ipc.git"
  },
  "bugs": {
    "url": "https://github.com/holepunchto/pear-ipc/issues"
  },
  "homepage": "https://github.com/holepunchto/pear-ipc#readme"
}
'use strict'
const { isBare, isWindows } = require('which-runtime')
const Pipe = require('net') // import mapped to bare-pipe, less resolves
const path = require('path')
const fs = require('fs')
const streamx = require('streamx')
const RPC = require('tiny-buffer-rpc')
const any = require('tiny-buffer-rpc/any')
const ReadyResource = require('ready-resource')
const FramedStream = require('framed-stream')

const API = require('./api')
const methods = require('./methods')
const constants = require('./constants')

const noop = Function.prototype

class PearIPCServer extends ReadyResource {
  #connect = null
  constructor (opts = {}) {
    super()
    this._opts = opts
    this._socketPath = opts.socketPath
    this._handlers = opts.handlers || {}
    this._methods = opts.methods ? [...methods, ...opts.methods] : methods
    this._lock = opts.lock || path.join(constants.PEAR_DIR, 'corestores', 'platform', 'db', 'LOCK')
    const api = new API(this)
    if (opts.api) Object.assign(api, opts.api)
    this._api = api
    this._connectTimeout = opts.connectTimeout || constants.CONNECT_TIMEOUT
    this.#connect = opts.connect || null
    this._rpc = null
    this._clients = new Freelist()
    this.clock = constants.HEARBEAT_CLOCK
    this._internalHandlers = null

    this._server = null
    this._rawStream = opts.stream || null
    this._stream = null
    this._unhandled = opts.unhandled || ((def) => { throw new Error('Method not found:' + def.name) })

    this.id = null
    this.userData = opts.userData || null

    this._onclose = this.close.bind(this)
    this._onpipeline = opts.onpipeline || null
  }

  get clients () { return this._clients.alloced.filter(Boolean) }

  get hasClients () { return !this._clients.emptied() }

  client (id) { return this._clients.from(id) || null }

  ref () {
    this._heartbeat?.ref()
    if (this._rawStream?.ref) this._rawStream.ref()
    this._server?.ref()
  }

  unref () {
    this._heartbeat?.unref()
    if (this._rawStream?.unref) this._rawStream.unref()
    this._server?.unref()
  }

  async _open () {
    if (this._rawStream === null) {
      this._serve()
    }

    if (this.closing) return

    if (this._server) {
      try {
        if (!isWindows) await fs.promises.unlink(this._socketPath)
      } catch {}
      if (this.closing) return
      this._server.listen(this._socketPath)
    }
  }

  _setup (id) {
    this.id = id
    this._stream = new FramedStream(this._rawStream)

    this._rpc = new RPC((data) => { if (!this.closing) this._stream.write(data) })
    this._stream.on('data', (data) => { this._rpc.recv(data) })
    this._stream.on('end', () => { this._stream.end() })
    this._stream.on('error', this._onclose)
    this._stream.on('close', this._onclose)

    this._internalHandlers = {
      _ping: (_, client) => {
        client.clock = constants.HEARBEAT_CLOCK
        return { beat: 'pong' }
      }
    }

    this._register()
  }

  _createSendMethod (method) {
    return (params = {}) => method.send(params)
  }

  _createRequestMethod (method) {
    return (params = {}) => method.request(params)
  }

  _createStreamMethod (method) {
    return (params = {}) => {
      const stream = method.createRequestStream()
      stream.on('end', () => { stream.end() })
      stream.write(params)
      return stream
    }
  }

  _createMethod (definition) {
    if (definition.send) {
      return this._createSendMethod
    }

    if (!definition.stream) {
      return this._createRequestMethod
    }

    return this._createStreamMethod
  }

  _register () {
    for (const { id, ...def } of this._methods) {
      if (constants.ILLEGAL_METHODS.has(def.name)) throw new Error('Illegal Method: ' + def.name)
      const fn = this._handlers[def.name] || this._internalHandlers?.[def.name] || null
      const callHandler = (params = {}) => fn.call(this._handlers, params, this)
      const api = this._api[def.name]?.bind(this._api) || fn ? () => callHandler : this._createMethod(def)

      this[def.name] = api(this._rpc.register(+id, {
        request: any,
        response: any,
        onrequest: def.stream
          ? null
          : (params) => {
              return fn ? fn.call(this._handlers, params, this) : this._unhandled(def, params)
            },
        onstream: def.stream ? this._createOnStream(fn, (params) => this._unhandled(def, params)) : null
      }), this)
    }
  }

  _createOnStream (fn, unhandled) {
    if (fn === null) fn = unhandled
    return async (stream) => {
      stream.on('end', () => stream.end())
      stream.on('error', (err) => console.log(err))
      try {
        for await (const params of stream) {
          const src = fn.call(this._handlers, params, this)
          const isStream = streamx.isStream(src)
          if (isStream) {
            streamx.pipeline(src, stream)
            if (typeof this._onpipeline === 'function') this._onpipeline(src, stream)
          } else {
            if (typeof this._onpipeline === 'function') this._onpipeline(src, stream)
            for await (const data of src) stream.write(data)
            stream.end()
          }
        }
      } catch (err) {
        stream.destroy(err)
      }
    }
  }

  _serve () {
    this._server = Pipe.createServer()
    this._server.on('connection', (rawStream) => {
      const client = new this.constructor({ ...this._opts, stream: rawStream })
      const id = this._clients.alloc(client)
      client._setup(id)
      client.once('close', () => { this._clients.free(client.id) })
      this.emit('client', client)
    })
    this._heartbeat = setInterval(() => {
      for (const client of this.clients) {
        client.clock--
        if (client.clock <= 0) {
          client.close()
        }
      }
    }, constants.HEARTBEAT_INTERVAL)
    this._rpc = new RPC(noop)
    this._register()
  }

  _pipe () {
    if (isBare) return new Pipe(this._socketPath)
    const sock = new Pipe.Socket()
    sock.setNoDelay(true)
    sock.connect(this._socketPath)
    return sock
  }

  _waitForClose () {
    return new Promise((resolve) => {
      if (this._stream.destroyed) {
        resolve()
      } else {
        this._stream.once('close', resolve)
        if (this.clock > 0) {
          this._stream.end()
        } else {
          this._stream.destroy()
        }
      }
    })
  }

  async _close () { // never throws, must never throw
    clearInterval(this._heartbeat)

    if (this._stream) {
      await this._waitForClose()
      this._rawStream = null
      this._stream = null
    }
    if (this._server) {
      await new Promise((resolve) => {
        const closingClients = []
        for (const client of this._clients) closingClients.push(client.close())
        const clientsClosing = Promise.allSettled(closingClients)
        this._server.close(async () => {
          await clientsClosing
          resolve()
        })
      })
    }
  }
}

class Freelist {
  alloced = []
  freed = []

  nextId () {
    return this.freed.length === 0 ? this.alloced.length : this.freed[this.freed.length - 1]
  }

  alloc (item) {
    const id = this.freed.length === 0 ? this.alloced.push(null) - 1 : this.freed.pop()
    this.alloced[id] = item
    return id
  }

  free (id) {
    this.freed.push(id)
    this.alloced[id] = null
  }

  from (id) {
    return id < this.alloced.length ? this.alloced[id] : null
  }

  emptied () {
    return this.freed.length === this.alloced.length
  }

  * [Symbol.iterator] () {
    for (const item of this.alloced) {
      if (item === null) continue
      yield item
    }
  }
}

module.exports = PearIPCServer
const EventEmitter = require('events')

module.exports = class ReadyResource extends EventEmitter {
  constructor () {
    super()

    this.opening = null
    this.closing = null

    this.opened = false
    this.closed = false
  }

  ready () {
    if (this.opening !== null) return this.opening
    this.opening = open(this)
    return this.opening
  }

  close () {
    if (this.closing !== null) return this.closing
    this.closing = close(this)
    return this.closing
  }

  async _open () {
    // add impl here
  }

  async _close () {
    // add impl here
  }
}

async function open (self) {
  // open after close
  if (self.closing !== null) return

  try {
    await self._open()
  } catch (err) {
    self.close() // safe to run in bg
    throw err
  }

  self.opened = true
  self.emit('ready')
}

async function close (self) {
  try {
    if (self.opened === false && self.opening !== null) await self.opening
  } catch {
    // ignore errors on closing
  }
  if (self.opened === true || self.opening === null) await self._close()
  self.closed = true
  self.emit('close')
}
{
  "name": "ready-resource",
  "version": "1.1.2",
  "description": "Modern single resource management",
  "main": "index.js",
  "imports": {
    "events": {
      "bare": "bare-events",
      "default": "events"
    }
  },
  "files": [
    "index.js"
  ],
  "scripts": {
    "test": "standard && brittle test.js"
  },
  "devDependencies": {
    "brittle": "^3.1.0",
    "standard": "^17.0.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/holepunchto/ready-resource.git"
  },
  "author": "Mathias Buus (@mafintosh)",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/holepunchto/ready-resource/issues"
  },
  "homepage": "https://github.com/holepunchto/ready-resource",
  "dependencies": {
    "bare-events": "^2.2.0"
  }
}
const runtime = require('./lib/runtime')

if (runtime === 'bare') {
  module.exports = require('./lib/runtime/bare')
} else if (runtime === 'node') {
  module.exports = require('./lib/runtime/node')
} else {
  module.exports = require('./lib/runtime/default')
}
module.exports =
  typeof Bare !== 'undefined'
    ? 'bare'
    : typeof process !== 'undefined'
      ? 'node'
      : 'unknown'
module.exports = require.addon.bind(require)
if (typeof require.addon === 'function') {
  module.exports = require.addon.bind(require)
} else {
  module.exports = function addon(specifier, parentURL) {
    throw new Error(
      `Cannot find addon '${specifier}' imported from '${parentURL}'`
    )
  }
}
if (typeof require.addon === 'function') {
  module.exports = require.addon.bind(require)
} else {
  const url = require('url')
  const resolve = require('bare-addon-resolve')

  const host = process.platform + '-' + process.arch
  const conditions = ['node', process.platform, process.arch]
  const extensions = ['.node']

  module.exports = function addon(specifier, parentURL) {
    if (typeof parentURL === 'string') parentURL = url.pathToFileURL(parentURL)

    for (const resolution of resolve(
      specifier,
      parentURL,
      { host, conditions, extensions },
      readPackage
    )) {
      switch (resolution.protocol) {
        case 'file:':
          try {
            return require(url.fileURLToPath(resolution))
          } catch {
            continue
          }
      }
    }

    throw new Error(
      `Cannot find addon '${specifier}' imported from '${parentURL.href}'`
    )

    function readPackage(packageURL) {
      try {
        return require(url.fileURLToPath(packageURL))
      } catch (err) {
        return null
      }
    }
  }
}
{
  "name": "require-addon",
  "version": "1.1.0",
  "description": "Import native addons across JavaScript runtimes",
  "exports": {
    ".": "./index.js",
    "./package": "./package.json"
  },
  "imports": {
    "fs": {
      "bare": "bare-fs",
      "default": "fs"
    },
    "path": {
      "bare": "bare-path",
      "default": "path"
    },
    "url": {
      "bare": "bare-url",
      "default": "url"
    }
  },
  "files": [
    "index.js",
    "lib"
  ],
  "scripts": {
    "test": "npm run lint && npm run test:bare && npm run test:node",
    "test:bare": "bare test.js",
    "test:node": "node test.js",
    "lint": "prettier . --check"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/holepunchto/require-addon.git"
  },
  "author": "Holepunch",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/holepunchto/require-addon/issues"
  },
  "homepage": "https://github.com/holepunchto/require-addon#readme",
  "engines": {
    "bare": ">=1.10.0"
  },
  "dependencies": {
    "bare-addon-resolve": "^1.3.0",
    "bare-url": "^2.1.0"
  },
  "devDependencies": {
    "bare-bundle": "^1.8.1",
    "bare-bundle-evaluate": "^1.1.0",
    "bare-fs": "^4.0.0",
    "bare-path": "^3.0.0",
    "brittle": "^3.7.0",
    "prettier": "^3.4.1",
    "prettier-config-standard": "^7.0.0"
  }
}
module.exports = safetyCatch

function isActuallyUncaught (err) {
  if (!err) return false
  return err instanceof TypeError ||
    err instanceof SyntaxError ||
    err instanceof ReferenceError ||
    err instanceof EvalError ||
    err instanceof RangeError ||
    err instanceof URIError ||
    err.code === 'ERR_ASSERTION'
}

function throwErrorNT (err) {
  queueMicrotask(() => { throw err })
}

function safetyCatch (err) {
  if (isActuallyUncaught(err)) {
    throwErrorNT(err)
    throw err
  }
}
{
  "name": "safety-catch",
  "version": "1.0.2",
  "description": "Small module that makes sure your catch, caught an actual error and not a programming mistake or assertion",
  "main": "index.js",
  "dependencies": {},
  "devDependencies": {},
  "repository": {
    "type": "git",
    "url": "https://github.com/mafintosh/safety-catch.git"
  },
  "author": "Mathias Buus (@mafintosh)",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/mafintosh/safety-catch/issues"
  },
  "homepage": "https://github.com/mafintosh/safety-catch"
}
const { EventEmitter } = require('events')
const STREAM_DESTROYED = new Error('Stream was destroyed')
const PREMATURE_CLOSE = new Error('Premature close')

const FIFO = require('fast-fifo')
const TextDecoder = require('text-decoder')

// if we do a future major, expect queue microtask to be there always, for now a bit defensive
const qmt = typeof queueMicrotask === 'undefined' ? fn => global.process.nextTick(fn) : queueMicrotask

/* eslint-disable no-multi-spaces */

// 29 bits used total (4 from shared, 14 from read, and 11 from write)
const MAX = ((1 << 29) - 1)

// Shared state
const OPENING       = 0b0001
const PREDESTROYING = 0b0010
const DESTROYING    = 0b0100
const DESTROYED     = 0b1000

const NOT_OPENING = MAX ^ OPENING
const NOT_PREDESTROYING = MAX ^ PREDESTROYING

// Read state (4 bit offset from shared state)
const READ_ACTIVE           = 0b00000000000001 << 4
const READ_UPDATING         = 0b00000000000010 << 4
const READ_PRIMARY          = 0b00000000000100 << 4
const READ_QUEUED           = 0b00000000001000 << 4
const READ_RESUMED          = 0b00000000010000 << 4
const READ_PIPE_DRAINED     = 0b00000000100000 << 4
const READ_ENDING           = 0b00000001000000 << 4
const READ_EMIT_DATA        = 0b00000010000000 << 4
const READ_EMIT_READABLE    = 0b00000100000000 << 4
const READ_EMITTED_READABLE = 0b00001000000000 << 4
const READ_DONE             = 0b00010000000000 << 4
const READ_NEXT_TICK        = 0b00100000000000 << 4
const READ_NEEDS_PUSH       = 0b01000000000000 << 4
const READ_READ_AHEAD       = 0b10000000000000 << 4

// Combined read state
const READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED
const READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH
const READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE
const READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED
const READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD

const READ_NOT_ACTIVE             = MAX ^ READ_ACTIVE
const READ_NON_PRIMARY            = MAX ^ READ_PRIMARY
const READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH)
const READ_PUSHED                 = MAX ^ READ_NEEDS_PUSH
const READ_PAUSED                 = MAX ^ READ_RESUMED
const READ_NOT_QUEUED             = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE)
const READ_NOT_ENDING             = MAX ^ READ_ENDING
const READ_PIPE_NOT_DRAINED       = MAX ^ READ_FLOWING
const READ_NOT_NEXT_TICK          = MAX ^ READ_NEXT_TICK
const READ_NOT_UPDATING           = MAX ^ READ_UPDATING
const READ_NO_READ_AHEAD          = MAX ^ READ_READ_AHEAD
const READ_PAUSED_NO_READ_AHEAD   = MAX ^ READ_RESUMED_READ_AHEAD

// Write state (18 bit offset, 4 bit offset from shared state and 14 from read state)
const WRITE_ACTIVE     = 0b00000000001 << 18
const WRITE_UPDATING   = 0b00000000010 << 18
const WRITE_PRIMARY    = 0b00000000100 << 18
const WRITE_QUEUED     = 0b00000001000 << 18
const WRITE_UNDRAINED  = 0b00000010000 << 18
const WRITE_DONE       = 0b00000100000 << 18
const WRITE_EMIT_DRAIN = 0b00001000000 << 18
const WRITE_NEXT_TICK  = 0b00010000000 << 18
const WRITE_WRITING    = 0b00100000000 << 18
const WRITE_FINISHING  = 0b01000000000 << 18
const WRITE_CORKED     = 0b10000000000 << 18

const WRITE_NOT_ACTIVE    = MAX ^ (WRITE_ACTIVE | WRITE_WRITING)
const WRITE_NON_PRIMARY   = MAX ^ WRITE_PRIMARY
const WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING)
const WRITE_DRAINED       = MAX ^ WRITE_UNDRAINED
const WRITE_NOT_QUEUED    = MAX ^ WRITE_QUEUED
const WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK
const WRITE_NOT_UPDATING  = MAX ^ WRITE_UPDATING
const WRITE_NOT_CORKED    = MAX ^ WRITE_CORKED

// Combined shared state
const ACTIVE = READ_ACTIVE | WRITE_ACTIVE
const NOT_ACTIVE = MAX ^ ACTIVE
const DONE = READ_DONE | WRITE_DONE
const DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING
const OPEN_STATUS = DESTROY_STATUS | OPENING
const AUTO_DESTROY = DESTROY_STATUS | DONE
const NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY
const ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK
const TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE
const IS_OPENING = OPEN_STATUS | TICKING

// Combined shared state and read state
const READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE
const READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED
const READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED
const READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE
const SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD
const READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE
const READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY
const READ_NEXT_TICK_OR_OPENING = READ_NEXT_TICK | OPENING

// Combined write state
const WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE
const WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED
const WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE
const WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE
const WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED
const WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE
const WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING
const WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE
const WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE
const WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY
const WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS

const asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator')

class WritableState {
  constructor (stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {
    this.stream = stream
    this.queue = new FIFO()
    this.highWaterMark = highWaterMark
    this.buffered = 0
    this.error = null
    this.pipeline = null
    this.drains = null // if we add more seldomly used helpers we might them into a subobject so its a single ptr
    this.byteLength = byteLengthWritable || byteLength || defaultByteLength
    this.map = mapWritable || map
    this.afterWrite = afterWrite.bind(this)
    this.afterUpdateNextTick = updateWriteNT.bind(this)
  }

  get ended () {
    return (this.stream._duplexState & WRITE_DONE) !== 0
  }

  push (data) {
    if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0) return false
    if (this.map !== null) data = this.map(data)

    this.buffered += this.byteLength(data)
    this.queue.push(data)

    if (this.buffered < this.highWaterMark) {
      this.stream._duplexState |= WRITE_QUEUED
      return true
    }

    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED
    return false
  }

  shift () {
    const data = this.queue.shift()

    this.buffered -= this.byteLength(data)
    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED

    return data
  }

  end (data) {
    if (typeof data === 'function') this.stream.once('finish', data)
    else if (data !== undefined && data !== null) this.push(data)
    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY
  }

  autoBatch (data, cb) {
    const buffer = []
    const stream = this.stream

    buffer.push(data)
    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {
      buffer.push(stream._writableState.shift())
    }

    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null)
    stream._writev(buffer, cb)
  }

  update () {
    const stream = this.stream

    stream._duplexState |= WRITE_UPDATING

    do {
      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {
        const data = this.shift()
        stream._duplexState |= WRITE_ACTIVE_AND_WRITING
        stream._write(data, this.afterWrite)
      }

      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()
    } while (this.continueUpdate() === true)

    stream._duplexState &= WRITE_NOT_UPDATING
  }

  updateNonPrimary () {
    const stream = this.stream

    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {
      stream._duplexState = stream._duplexState | WRITE_ACTIVE
      stream._final(afterFinal.bind(this))
      return
    }

    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
        stream._duplexState |= ACTIVE
        stream._destroy(afterDestroy.bind(this))
      }
      return
    }

    if ((stream._duplexState & IS_OPENING) === OPENING) {
      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING
      stream._open(afterOpen.bind(this))
    }
  }

  continueUpdate () {
    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false
    this.stream._duplexState &= WRITE_NOT_NEXT_TICK
    return true
  }

  updateCallback () {
    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update()
    else this.updateNextTick()
  }

  updateNextTick () {
    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return
    this.stream._duplexState |= WRITE_NEXT_TICK
    if ((this.stream._duplexState & WRITE_UPDATING) === 0) qmt(this.afterUpdateNextTick)
  }
}

class ReadableState {
  constructor (stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {
    this.stream = stream
    this.queue = new FIFO()
    this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark
    this.buffered = 0
    this.readAhead = highWaterMark > 0
    this.error = null
    this.pipeline = null
    this.byteLength = byteLengthReadable || byteLength || defaultByteLength
    this.map = mapReadable || map
    this.pipeTo = null
    this.afterRead = afterRead.bind(this)
    this.afterUpdateNextTick = updateReadNT.bind(this)
  }

  get ended () {
    return (this.stream._duplexState & READ_DONE) !== 0
  }

  pipe (pipeTo, cb) {
    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination')
    if (typeof cb !== 'function') cb = null

    this.stream._duplexState |= READ_PIPE_DRAINED
    this.pipeTo = pipeTo
    this.pipeline = new Pipeline(this.stream, pipeTo, cb)

    if (cb) this.stream.on('error', noop) // We already error handle this so supress crashes

    if (isStreamx(pipeTo)) {
      pipeTo._writableState.pipeline = this.pipeline
      if (cb) pipeTo.on('error', noop) // We already error handle this so supress crashes
      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)) // TODO: just call finished from pipeTo itself
    } else {
      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo)
      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null) // onclose has a weird bool arg
      pipeTo.on('error', onerror)
      pipeTo.on('close', onclose)
      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline))
    }

    pipeTo.on('drain', afterDrain.bind(this))
    this.stream.emit('piping', pipeTo)
    pipeTo.emit('pipe', this.stream)
  }

  push (data) {
    const stream = this.stream

    if (data === null) {
      this.highWaterMark = 0
      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED
      return false
    }

    if (this.map !== null) {
      data = this.map(data)
      if (data === null) {
        stream._duplexState &= READ_PUSHED
        return this.buffered < this.highWaterMark
      }
    }

    this.buffered += this.byteLength(data)
    this.queue.push(data)

    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED

    return this.buffered < this.highWaterMark
  }

  shift () {
    const data = this.queue.shift()

    this.buffered -= this.byteLength(data)
    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED
    return data
  }

  unshift (data) {
    const pending = [this.map !== null ? this.map(data) : data]
    while (this.buffered > 0) pending.push(this.shift())

    for (let i = 0; i < pending.length - 1; i++) {
      const data = pending[i]
      this.buffered += this.byteLength(data)
      this.queue.push(data)
    }

    this.push(pending[pending.length - 1])
  }

  read () {
    const stream = this.stream

    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {
      const data = this.shift()
      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED
      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)
      return data
    }

    if (this.readAhead === false) {
      stream._duplexState |= READ_READ_AHEAD
      this.updateNextTick()
    }

    return null
  }

  drain () {
    const stream = this.stream

    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {
      const data = this.shift()
      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED
      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)
    }
  }

  update () {
    const stream = this.stream

    stream._duplexState |= READ_UPDATING

    do {
      this.drain()

      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {
        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH
        stream._read(this.afterRead)
        this.drain()
      }

      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {
        stream._duplexState |= READ_EMITTED_READABLE
        stream.emit('readable')
      }

      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()
    } while (this.continueUpdate() === true)

    stream._duplexState &= READ_NOT_UPDATING
  }

  updateNonPrimary () {
    const stream = this.stream

    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {
      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING
      stream.emit('end')
      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING
      if (this.pipeTo !== null) this.pipeTo.end()
    }

    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
        stream._duplexState |= ACTIVE
        stream._destroy(afterDestroy.bind(this))
      }
      return
    }

    if ((stream._duplexState & IS_OPENING) === OPENING) {
      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING
      stream._open(afterOpen.bind(this))
    }
  }

  continueUpdate () {
    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false
    this.stream._duplexState &= READ_NOT_NEXT_TICK
    return true
  }

  updateCallback () {
    if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update()
    else this.updateNextTick()
  }

  updateNextTickIfOpen () {
    if ((this.stream._duplexState & READ_NEXT_TICK_OR_OPENING) !== 0) return
    this.stream._duplexState |= READ_NEXT_TICK
    if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick)
  }

  updateNextTick () {
    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return
    this.stream._duplexState |= READ_NEXT_TICK
    if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick)
  }
}

class TransformState {
  constructor (stream) {
    this.data = null
    this.afterTransform = afterTransform.bind(stream)
    this.afterFinal = null
  }
}

class Pipeline {
  constructor (src, dst, cb) {
    this.from = src
    this.to = dst
    this.afterPipe = cb
    this.error = null
    this.pipeToFinished = false
  }

  finished () {
    this.pipeToFinished = true
  }

  done (stream, err) {
    if (err) this.error = err

    if (stream === this.to) {
      this.to = null

      if (this.from !== null) {
        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {
          this.from.destroy(this.error || new Error('Writable stream closed prematurely'))
        }
        return
      }
    }

    if (stream === this.from) {
      this.from = null

      if (this.to !== null) {
        if ((stream._duplexState & READ_DONE) === 0) {
          this.to.destroy(this.error || new Error('Readable stream closed before ending'))
        }
        return
      }
    }

    if (this.afterPipe !== null) this.afterPipe(this.error)
    this.to = this.from = this.afterPipe = null
  }
}

function afterDrain () {
  this.stream._duplexState |= READ_PIPE_DRAINED
  this.updateCallback()
}

function afterFinal (err) {
  const stream = this.stream
  if (err) stream.destroy(err)
  if ((stream._duplexState & DESTROY_STATUS) === 0) {
    stream._duplexState |= WRITE_DONE
    stream.emit('finish')
  }
  if ((stream._duplexState & AUTO_DESTROY) === DONE) {
    stream._duplexState |= DESTROYING
  }

  stream._duplexState &= WRITE_NOT_FINISHING

  // no need to wait the extra tick here, so we short circuit that
  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update()
  else this.updateNextTick()
}

function afterDestroy (err) {
  const stream = this.stream

  if (!err && this.error !== STREAM_DESTROYED) err = this.error
  if (err) stream.emit('error', err)
  stream._duplexState |= DESTROYED
  stream.emit('close')

  const rs = stream._readableState
  const ws = stream._writableState

  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err)

  if (ws !== null) {
    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false)
    if (ws.pipeline !== null) ws.pipeline.done(stream, err)
  }
}

function afterWrite (err) {
  const stream = this.stream

  if (err) stream.destroy(err)
  stream._duplexState &= WRITE_NOT_ACTIVE

  if (this.drains !== null) tickDrains(this.drains)

  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {
    stream._duplexState &= WRITE_DRAINED
    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {
      stream.emit('drain')
    }
  }

  this.updateCallback()
}

function afterRead (err) {
  if (err) this.stream.destroy(err)
  this.stream._duplexState &= READ_NOT_ACTIVE
  if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD
  this.updateCallback()
}

function updateReadNT () {
  if ((this.stream._duplexState & READ_UPDATING) === 0) {
    this.stream._duplexState &= READ_NOT_NEXT_TICK
    this.update()
  }
}

function updateWriteNT () {
  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {
    this.stream._duplexState &= WRITE_NOT_NEXT_TICK
    this.update()
  }
}

function tickDrains (drains) {
  for (let i = 0; i < drains.length; i++) {
    // drains.writes are monotonic, so if one is 0 its always the first one
    if (--drains[i].writes === 0) {
      drains.shift().resolve(true)
      i--
    }
  }
}

function afterOpen (err) {
  const stream = this.stream

  if (err) stream.destroy(err)

  if ((stream._duplexState & DESTROYING) === 0) {
    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY
    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY
    stream.emit('open')
  }

  stream._duplexState &= NOT_ACTIVE

  if (stream._writableState !== null) {
    stream._writableState.updateCallback()
  }

  if (stream._readableState !== null) {
    stream._readableState.updateCallback()
  }
}

function afterTransform (err, data) {
  if (data !== undefined && data !== null) this.push(data)
  this._writableState.afterWrite(err)
}

function newListener (name) {
  if (this._readableState !== null) {
    if (name === 'data') {
      this._duplexState |= (READ_EMIT_DATA | READ_RESUMED_READ_AHEAD)
      this._readableState.updateNextTick()
    }
    if (name === 'readable') {
      this._duplexState |= READ_EMIT_READABLE
      this._readableState.updateNextTick()
    }
  }

  if (this._writableState !== null) {
    if (name === 'drain') {
      this._duplexState |= WRITE_EMIT_DRAIN
      this._writableState.updateNextTick()
    }
  }
}

class Stream extends EventEmitter {
  constructor (opts) {
    super()

    this._duplexState = 0
    this._readableState = null
    this._writableState = null

    if (opts) {
      if (opts.open) this._open = opts.open
      if (opts.destroy) this._destroy = opts.destroy
      if (opts.predestroy) this._predestroy = opts.predestroy
      if (opts.signal) {
        opts.signal.addEventListener('abort', abort.bind(this))
      }
    }

    this.on('newListener', newListener)
  }

  _open (cb) {
    cb(null)
  }

  _destroy (cb) {
    cb(null)
  }

  _predestroy () {
    // does nothing
  }

  get readable () {
    return this._readableState !== null ? true : undefined
  }

  get writable () {
    return this._writableState !== null ? true : undefined
  }

  get destroyed () {
    return (this._duplexState & DESTROYED) !== 0
  }

  get destroying () {
    return (this._duplexState & DESTROY_STATUS) !== 0
  }

  destroy (err) {
    if ((this._duplexState & DESTROY_STATUS) === 0) {
      if (!err) err = STREAM_DESTROYED
      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY

      if (this._readableState !== null) {
        this._readableState.highWaterMark = 0
        this._readableState.error = err
      }
      if (this._writableState !== null) {
        this._writableState.highWaterMark = 0
        this._writableState.error = err
      }

      this._duplexState |= PREDESTROYING
      this._predestroy()
      this._duplexState &= NOT_PREDESTROYING

      if (this._readableState !== null) this._readableState.updateNextTick()
      if (this._writableState !== null) this._writableState.updateNextTick()
    }
  }
}

class Readable extends Stream {
  constructor (opts) {
    super(opts)

    this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD
    this._readableState = new ReadableState(this, opts)

    if (opts) {
      if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD
      if (opts.read) this._read = opts.read
      if (opts.eagerOpen) this._readableState.updateNextTick()
      if (opts.encoding) this.setEncoding(opts.encoding)
    }
  }

  setEncoding (encoding) {
    const dec = new TextDecoder(encoding)
    const map = this._readableState.map || echo
    this._readableState.map = mapOrSkip
    return this

    function mapOrSkip (data) {
      const next = dec.push(data)
      return next === '' && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next)
    }
  }

  _read (cb) {
    cb(null)
  }

  pipe (dest, cb) {
    this._readableState.updateNextTick()
    this._readableState.pipe(dest, cb)
    return dest
  }

  read () {
    this._readableState.updateNextTick()
    return this._readableState.read()
  }

  push (data) {
    this._readableState.updateNextTickIfOpen()
    return this._readableState.push(data)
  }

  unshift (data) {
    this._readableState.updateNextTickIfOpen()
    return this._readableState.unshift(data)
  }

  resume () {
    this._duplexState |= READ_RESUMED_READ_AHEAD
    this._readableState.updateNextTick()
    return this
  }

  pause () {
    this._duplexState &= (this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED)
    return this
  }

  static _fromAsyncIterator (ite, opts) {
    let destroy

    const rs = new Readable({
      ...opts,
      read (cb) {
        ite.next().then(push).then(cb.bind(null, null)).catch(cb)
      },
      predestroy () {
        destroy = ite.return()
      },
      destroy (cb) {
        if (!destroy) return cb(null)
        destroy.then(cb.bind(null, null)).catch(cb)
      }
    })

    return rs

    function push (data) {
      if (data.done) rs.push(null)
      else rs.push(data.value)
    }
  }

  static from (data, opts) {
    if (isReadStreamx(data)) return data
    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts)
    if (!Array.isArray(data)) data = data === undefined ? [] : [data]

    let i = 0
    return new Readable({
      ...opts,
      read (cb) {
        this.push(i === data.length ? null : data[i++])
        cb(null)
      }
    })
  }

  static isBackpressured (rs) {
    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark
  }

  static isPaused (rs) {
    return (rs._duplexState & READ_RESUMED) === 0
  }

  [asyncIterator] () {
    const stream = this

    let error = null
    let promiseResolve = null
    let promiseReject = null

    this.on('error', (err) => { error = err })
    this.on('readable', onreadable)
    this.on('close', onclose)

    return {
      [asyncIterator] () {
        return this
      },
      next () {
        return new Promise(function (resolve, reject) {
          promiseResolve = resolve
          promiseReject = reject
          const data = stream.read()
          if (data !== null) ondata(data)
          else if ((stream._duplexState & DESTROYED) !== 0) ondata(null)
        })
      },
      return () {
        return destroy(null)
      },
      throw (err) {
        return destroy(err)
      }
    }

    function onreadable () {
      if (promiseResolve !== null) ondata(stream.read())
    }

    function onclose () {
      if (promiseResolve !== null) ondata(null)
    }

    function ondata (data) {
      if (promiseReject === null) return
      if (error) promiseReject(error)
      else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED)
      else promiseResolve({ value: data, done: data === null })
      promiseReject = promiseResolve = null
    }

    function destroy (err) {
      stream.destroy(err)
      return new Promise((resolve, reject) => {
        if (stream._duplexState & DESTROYED) return resolve({ value: undefined, done: true })
        stream.once('close', function () {
          if (err) reject(err)
          else resolve({ value: undefined, done: true })
        })
      })
    }
  }
}

class Writable extends Stream {
  constructor (opts) {
    super(opts)

    this._duplexState |= OPENING | READ_DONE
    this._writableState = new WritableState(this, opts)

    if (opts) {
      if (opts.writev) this._writev = opts.writev
      if (opts.write) this._write = opts.write
      if (opts.final) this._final = opts.final
      if (opts.eagerOpen) this._writableState.updateNextTick()
    }
  }

  cork () {
    this._duplexState |= WRITE_CORKED
  }

  uncork () {
    this._duplexState &= WRITE_NOT_CORKED
    this._writableState.updateNextTick()
  }

  _writev (batch, cb) {
    cb(null)
  }

  _write (data, cb) {
    this._writableState.autoBatch(data, cb)
  }

  _final (cb) {
    cb(null)
  }

  static isBackpressured (ws) {
    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0
  }

  static drained (ws) {
    if (ws.destroyed) return Promise.resolve(false)
    const state = ws._writableState
    const pending = (isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length)
    const writes = pending + ((ws._duplexState & WRITE_WRITING) ? 1 : 0)
    if (writes === 0) return Promise.resolve(true)
    if (state.drains === null) state.drains = []
    return new Promise((resolve) => {
      state.drains.push({ writes, resolve })
    })
  }

  write (data) {
    this._writableState.updateNextTick()
    return this._writableState.push(data)
  }

  end (data) {
    this._writableState.updateNextTick()
    this._writableState.end(data)
    return this
  }
}

class Duplex extends Readable { // and Writable
  constructor (opts) {
    super(opts)

    this._duplexState = OPENING | (this._duplexState & READ_READ_AHEAD)
    this._writableState = new WritableState(this, opts)

    if (opts) {
      if (opts.writev) this._writev = opts.writev
      if (opts.write) this._write = opts.write
      if (opts.final) this._final = opts.final
    }
  }

  cork () {
    this._duplexState |= WRITE_CORKED
  }

  uncork () {
    this._duplexState &= WRITE_NOT_CORKED
    this._writableState.updateNextTick()
  }

  _writev (batch, cb) {
    cb(null)
  }

  _write (data, cb) {
    this._writableState.autoBatch(data, cb)
  }

  _final (cb) {
    cb(null)
  }

  write (data) {
    this._writableState.updateNextTick()
    return this._writableState.push(data)
  }

  end (data) {
    this._writableState.updateNextTick()
    this._writableState.end(data)
    return this
  }
}

class Transform extends Duplex {
  constructor (opts) {
    super(opts)
    this._transformState = new TransformState(this)

    if (opts) {
      if (opts.transform) this._transform = opts.transform
      if (opts.flush) this._flush = opts.flush
    }
  }

  _write (data, cb) {
    if (this._readableState.buffered >= this._readableState.highWaterMark) {
      this._transformState.data = data
    } else {
      this._transform(data, this._transformState.afterTransform)
    }
  }

  _read (cb) {
    if (this._transformState.data !== null) {
      const data = this._transformState.data
      this._transformState.data = null
      cb(null)
      this._transform(data, this._transformState.afterTransform)
    } else {
      cb(null)
    }
  }

  destroy (err) {
    super.destroy(err)
    if (this._transformState.data !== null) {
      this._transformState.data = null
      this._transformState.afterTransform()
    }
  }

  _transform (data, cb) {
    cb(null, data)
  }

  _flush (cb) {
    cb(null)
  }

  _final (cb) {
    this._transformState.afterFinal = cb
    this._flush(transformAfterFlush.bind(this))
  }
}

class PassThrough extends Transform {}

function transformAfterFlush (err, data) {
  const cb = this._transformState.afterFinal
  if (err) return cb(err)
  if (data !== null && data !== undefined) this.push(data)
  this.push(null)
  cb(null)
}

function pipelinePromise (...streams) {
  return new Promise((resolve, reject) => {
    return pipeline(...streams, (err) => {
      if (err) return reject(err)
      resolve()
    })
  })
}

function pipeline (stream, ...streams) {
  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams]
  const done = (all.length && typeof all[all.length - 1] === 'function') ? all.pop() : null

  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams')

  let src = all[0]
  let dest = null
  let error = null

  for (let i = 1; i < all.length; i++) {
    dest = all[i]

    if (isStreamx(src)) {
      src.pipe(dest, onerror)
    } else {
      errorHandle(src, true, i > 1, onerror)
      src.pipe(dest)
    }

    src = dest
  }

  if (done) {
    let fin = false

    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy)

    dest.on('error', (err) => {
      if (error === null) error = err
    })

    dest.on('finish', () => {
      fin = true
      if (!autoDestroy) done(error)
    })

    if (autoDestroy) {
      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)))
    }
  }

  return dest

  function errorHandle (s, rd, wr, onerror) {
    s.on('error', onerror)
    s.on('close', onclose)

    function onclose () {
      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE)
      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE)
    }
  }

  function onerror (err) {
    if (!err || error) return
    error = err

    for (const s of all) {
      s.destroy(err)
    }
  }
}

function echo (s) {
  return s
}

function isStream (stream) {
  return !!stream._readableState || !!stream._writableState
}

function isStreamx (stream) {
  return typeof stream._duplexState === 'number' && isStream(stream)
}

function isEnded (stream) {
  return !!stream._readableState && stream._readableState.ended
}

function isFinished (stream) {
  return !!stream._writableState && stream._writableState.ended
}

function getStreamError (stream, opts = {}) {
  const err = (stream._readableState && stream._readableState.error) || (stream._writableState && stream._writableState.error)

  // avoid implicit errors by default
  return (!opts.all && err === STREAM_DESTROYED) ? null : err
}

function isReadStreamx (stream) {
  return isStreamx(stream) && stream.readable
}

function isDisturbed (stream) {
  return (stream._duplexState & OPENING) !== OPENING || (stream._duplexState & ACTIVE_OR_TICKING) !== 0
}

function isTypedArray (data) {
  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number'
}

function defaultByteLength (data) {
  return isTypedArray(data) ? data.byteLength : 1024
}

function noop () {}

function abort () {
  this.destroy(new Error('Stream aborted.'))
}

function isWritev (s) {
  return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev
}

module.exports = {
  pipeline,
  pipelinePromise,
  isStream,
  isStreamx,
  isEnded,
  isFinished,
  isDisturbed,
  getStreamError,
  Stream,
  Writable,
  Readable,
  Duplex,
  Transform,
  // Export PassThrough for compatibility with Node.js core's stream module
  PassThrough
}
{
  "name": "streamx",
  "version": "2.22.1",
  "description": "An iteration of the Node.js core streams with a series of improvements",
  "main": "index.js",
  "dependencies": {
    "fast-fifo": "^1.3.2",
    "text-decoder": "^1.1.0"
  },
  "devDependencies": {
    "b4a": "^1.6.6",
    "brittle": "^3.1.1",
    "end-of-stream": "^1.4.4",
    "standard": "^17.0.0"
  },
  "optionalDependencies": {
    "bare-events": "^2.2.0"
  },
  "files": [
    "index.js"
  ],
  "imports": {
    "events": {
      "bare": "bare-events",
      "default": "events"
    }
  },
  "scripts": {
    "test": "standard && brittle test/*.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mafintosh/streamx.git"
  },
  "author": "Mathias Buus (@mafintosh)",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/mafintosh/streamx/issues"
  },
  "homepage": "https://github.com/mafintosh/streamx"
}
const PassThroughDecoder = require('./lib/pass-through-decoder')
const UTF8Decoder = require('./lib/utf8-decoder')

module.exports = class TextDecoder {
  constructor (encoding = 'utf8') {
    this.encoding = normalizeEncoding(encoding)

    switch (this.encoding) {
      case 'utf8':
        this.decoder = new UTF8Decoder()
        break
      case 'utf16le':
      case 'base64':
        throw new Error('Unsupported encoding: ' + this.encoding)
      default:
        this.decoder = new PassThroughDecoder(this.encoding)
    }
  }

  get remaining () {
    return this.decoder.remaining
  }

  push (data) {
    if (typeof data === 'string') return data
    return this.decoder.decode(data)
  }

  // For Node.js compatibility
  write (data) {
    return this.push(data)
  }

  end (data) {
    let result = ''
    if (data) result = this.push(data)
    result += this.decoder.flush()
    return result
  }
}

function normalizeEncoding (encoding) {
  encoding = encoding.toLowerCase()

  switch (encoding) {
    case 'utf8':
    case 'utf-8':
      return 'utf8'
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return 'utf16le'
    case 'latin1':
    case 'binary':
      return 'latin1'
    case 'base64':
    case 'ascii':
    case 'hex':
      return encoding
    default:
      throw new Error('Unknown encoding: ' + encoding)
  }
};
const b4a = require('b4a')

module.exports = class PassThroughDecoder {
  constructor (encoding) {
    this.encoding = encoding
  }

  get remaining () {
    return 0
  }

  decode (tail) {
    return b4a.toString(tail, this.encoding)
  }

  flush () {
    return ''
  }
}
const b4a = require('b4a')

/**
 * https://encoding.spec.whatwg.org/#utf-8-decoder
 */
module.exports = class UTF8Decoder {
  constructor () {
    this.codePoint = 0
    this.bytesSeen = 0
    this.bytesNeeded = 0
    this.lowerBoundary = 0x80
    this.upperBoundary = 0xbf
  }

  get remaining () {
    return this.bytesSeen
  }

  decode (data) {
    // If we have a fast path, just sniff if the last part is a boundary
    if (this.bytesNeeded === 0) {
      let isBoundary = true

      for (let i = Math.max(0, data.byteLength - 4), n = data.byteLength; i < n && isBoundary; i++) {
        isBoundary = data[i] <= 0x7f
      }

      if (isBoundary) return b4a.toString(data, 'utf8')
    }

    let result = ''

    for (let i = 0, n = data.byteLength; i < n; i++) {
      const byte = data[i]

      if (this.bytesNeeded === 0) {
        if (byte <= 0x7f) {
          result += String.fromCharCode(byte)
        } else {
          this.bytesSeen = 1

          if (byte >= 0xc2 && byte <= 0xdf) {
            this.bytesNeeded = 2
            this.codePoint = byte & 0x1f
          } else if (byte >= 0xe0 && byte <= 0xef) {
            if (byte === 0xe0) this.lowerBoundary = 0xa0
            else if (byte === 0xed) this.upperBoundary = 0x9f
            this.bytesNeeded = 3
            this.codePoint = byte & 0xf
          } else if (byte >= 0xf0 && byte <= 0xf4) {
            if (byte === 0xf0) this.lowerBoundary = 0x90
            if (byte === 0xf4) this.upperBoundary = 0x8f
            this.bytesNeeded = 4
            this.codePoint = byte & 0x7
          } else {
            result += '\ufffd'
          }
        }

        continue
      }

      if (byte < this.lowerBoundary || byte > this.upperBoundary) {
        this.codePoint = 0
        this.bytesNeeded = 0
        this.bytesSeen = 0
        this.lowerBoundary = 0x80
        this.upperBoundary = 0xbf

        result += '\ufffd'

        continue
      }

      this.lowerBoundary = 0x80
      this.upperBoundary = 0xbf

      this.codePoint = (this.codePoint << 6) | (byte & 0x3f)
      this.bytesSeen++

      if (this.bytesSeen !== this.bytesNeeded) continue

      result += String.fromCodePoint(this.codePoint)

      this.codePoint = 0
      this.bytesNeeded = 0
      this.bytesSeen = 0
    }

    return result
  }

  flush () {
    const result = this.bytesNeeded > 0 ? '\ufffd' : ''

    this.codePoint = 0
    this.bytesNeeded = 0
    this.bytesSeen = 0
    this.lowerBoundary = 0x80
    this.upperBoundary = 0xbf

    return result
  }
}
{
  "name": "text-decoder",
  "version": "1.2.3",
  "description": "Streaming text decoder that preserves multibyte Unicode characters",
  "main": "index.js",
  "files": [
    "index.js",
    "lib"
  ],
  "browser": {
    "./lib/pass-through-decoder.js": "./lib/browser-decoder.js",
    "./lib/utf8-decoder.js": "./lib/browser-decoder.js"
  },
  "react-native": {
    "./lib/pass-through-decoder.js": "./lib/pass-through-decoder.js",
    "./lib/utf8-decoder.js": "./lib/utf8-decoder.js"
  },
  "scripts": {
    "test": "standard && brittle test.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/holepunchto/text-decoder.git"
  },
  "author": "Holepunch",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/holepunchto/text-decoder/issues"
  },
  "homepage": "https://github.com/holepunchto/text-decoder#readme",
  "dependencies": {
    "b4a": "^1.6.4"
  },
  "devDependencies": {
    "brittle": "^3.3.2",
    "standard": "^17.0.0"
  }
}
// This file is a tmp workaround until variadic args land in tiny-buffer-rpc

const b4a = require('b4a')
const c = require('compact-encoding')
const { uint, utf8 } = c

const anyUndefined = {
  preencode (state, n) {
    // do nothing
  },
  encode (state, n) {
    // do nothing
  },
  decode (state) {
    return undefined
  }
}

// "any" encoders here for helping just structure any object without schematising it

const anyArray = {
  preencode (state, arr) {
    uint.preencode(state, arr.length)
    for (let i = 0; i < arr.length; i++) {
      any.preencode(state, arr[i])
    }
  },
  encode (state, arr) {
    uint.encode(state, arr.length)
    for (let i = 0; i < arr.length; i++) {
      any.encode(state, arr[i])
    }
  },
  decode (state) {
    const arr = []
    let len = uint.decode(state)
    while (len-- > 0) {
      arr.push(any.decode(state))
    }
    return arr
  }
}

const anyObject = {
  preencode (state, o) {
    const keys = Object.keys(o)
    uint.preencode(state, keys.length)
    for (const key of keys) {
      utf8.preencode(state, key)
      any.preencode(state, o[key])
    }
  },
  encode (state, o) {
    const keys = Object.keys(o)
    uint.encode(state, keys.length)
    for (const key of keys) {
      utf8.encode(state, key)
      any.encode(state, o[key])
    }
  },
  decode (state) {
    let len = uint.decode(state)
    const o = {}
    while (len-- > 0) {
      const key = utf8.decode(state)
      o[key] = any.decode(state)
    }
    return o
  }
}

const anyTypes = [
  c.none,
  anyUndefined,
  c.bool,
  c.string,
  c.buffer,
  c.uint,
  c.int,
  c.float64,
  anyArray,
  anyObject
]

const any = module.exports = {
  preencode (state, o) {
    const t = getType(o)
    uint.preencode(state, t)
    anyTypes[t].preencode(state, o)
  },
  encode (state, o) {
    const t = getType(o)
    uint.encode(state, t)
    anyTypes[t].encode(state, o)
  },
  decode (state) {
    const t = uint.decode(state)
    if (t >= anyTypes.length) throw new Error('Unknown type: ' + t)
    return anyTypes[t].decode(state)
  }
}

function getType (o) {
  if (o === null) return 0
  if (o === undefined) return 1
  if (typeof o === 'boolean') return 2
  if (typeof o === 'string') return 3
  if (b4a.isBuffer(o)) return 4
  if (typeof o === 'number') {
    if (Number.isInteger(o)) return o >= 0 ? 5 : 6
    return 7
  }
  if (Array.isArray(o)) return 8
  if (typeof o === 'object') return 9

  throw new Error('Unsupported type for ' + o)
}
const { getStreamError, Duplex } = require('streamx')
const c = require('compact-encoding')
const safetyCatch = require('safety-catch')
const b4a = require('b4a')

// Primary message flags (4 bits)
const MESSAGE_SEND = 0b0001
const MESSAGE_REQUEST = 0b0010
const MESSAGE_RESPONSE = 0b0100
const MESSAGE_ERROR = 0b1000

// Stream message flags (6 bits, with a 4 bit offset for primary message flags)
const STREAMING_MASK = ((1 << 6) - 1) << 4
const STREAM_OPEN = 0b000001 << 4
const STREAM_CLOSE = 0b000010 << 4
const STREAM_PAUSE = 0b000100 << 4
const STREAM_RESUME = 0b001000 << 4
const STREAM_DATA = 0b010000 << 4
const STREAM_END = 0b100000 << 4

// Stream status flags (2 bits, with a 10 bit offset)
const STREAM_IS_INITIATOR = 0b01 << 10
const STREAM_HAS_ERROR = 0b10 << 10

const REQUEST = MESSAGE_SEND | MESSAGE_REQUEST

const {
  Header,
  Message,
  ErrorMessage
} = require('./messages.js')

class Request {
  constructor (method, id, type, data) {
    this.type = type
    this.id = id
    this.method = method
    this.sent = false
    this.data = data
  }

  _respond (data) {
    if (this._sent) throw new Error('Response already sent')
    this.sent = true
    this.method._rpc._sendMessage({
      bitfield: MESSAGE_RESPONSE,
      id: this.id,
      method: this.method._method,
      data: c.encode(this.method._response, data)
    })
  }

  _error (err) {
    if (this._sent) throw new Error('Response already sent')
    this.sent = true
    this.method._rpc._sendMessage({
      bitfield: MESSAGE_ERROR,
      id: this.id,
      method: this.method._method,
      data: c.encode(ErrorMessage, err)
    })
  }
}

class RPCStream extends Duplex {
  constructor (method, id, initiator, remoteId, dedup) {
    super({ eagerOpen: true })

    this._method = method
    this._initiator = initiator

    this._localId = id
    this._remoteId = remoteId
    this._dedup = dedup
    this._lastMessage = null

    this._remotePaused = true
    this._sentPause = false
    this._sentOpen = false
    this._initiatedDestroy = false

    this._writeBatch = null
    this._writeCallback = null
    this._openCallback = null
  }

  _sendBatch (batch) {
    const bitfield = MESSAGE_SEND | STREAM_DATA
    const dataEncoding = this._initiator ? this._method._responseArray : this._method._requestArray
    const data = c.encode(dataEncoding, batch)

    if (this._dedup) {
      if (this._lastMessage && b4a.equals(this._lastMessage, data)) return
      this._lastMessage = data
    }

    this._method._sendMessage(this._remoteId, bitfield, data)
  }

  _remoteOpened (remoteId) {
    this._remoteId = remoteId
    this._continueOpen(null)
  }

  _remoteClosed (err) {
    this._remoteId = -1
    this.destroy(err)
  }

  _remotePause () {
    this._remotePaused = true
  }

  _remoteResume () {
    this._remotePaused = false
    if (!this._writeBatch) return

    this._sendBatch(this._writeBatch)
    this._writeBatch = null
    this._continueWrite(null)
  }

  _sendOpen () {
    if (this._sentOpen) return

    let bitfield = MESSAGE_SEND | STREAM_OPEN
    if (this._initiator) bitfield |= STREAM_IS_INITIATOR

    const id = this._initiator ? this._localId : this._remoteId
    const data = this._initiator ? null : c.encode(c.uint, this._localId)

    this._sentOpen = true
    this._method._sendMessage(id, bitfield, data)
  }

  _open (cb) {
    this._sendOpen()

    if (this._initiator) {
      this._openCallback = cb
    } else {
      cb()
    }
  }

  _continueOpen (err) {
    if (this._openCallback === null) return
    const cb = this._openCallback
    this._openCallback = null
    cb(err)
  }

  _read (cb) {
    this._method._sendMessage(this._remoteId, MESSAGE_SEND | STREAM_RESUME)
    cb()
  }

  _writev (batch, cb) {
    if (this._remotePaused) {
      this._writeBatch = batch
      this._writeCallback = cb
    } else {
      this._sendBatch(batch)
      cb()
    }
  }

  _continueWrite (err) {
    if (this._writeCallback === null) return
    const cb = this._writeCallback
    this._writeCallback = null
    cb(err)
  }

  _final (cb) {
    this._method._sendMessage(this._remoteId, MESSAGE_SEND | STREAM_END)
    cb()
  }

  _predestroy () {
    this._initiatedDestroy = true
    this._continueWrite(null)
  }

  _destroy (cb) {
    if (this._remoteId === -1 || this._initiatedDestroy === false || this._method.destroyed) {
      // if the remote side already sent a close or we are the initiator and we didn't open,
      // then we don't need to send a close message
      cb()
      return
    }

    const err = getStreamError(this)

    let bitfield = MESSAGE_SEND | STREAM_CLOSE
    if (err) bitfield |= STREAM_HAS_ERROR
    const data = err ? c.encode(ErrorMessage, err) : null

    this._method._sendMessage(this._remoteId, bitfield, data)
    cb()
  }
}

class Method {
  constructor (rpc, method, { request, response, dedup = false, onrequest, onstream } = {}) {
    this.destroyed = false

    this._rpc = rpc
    this._method = method

    this._request = request || c.buffer
    this._response = response || c.buffer
    this._requestArray = c.array(this._request)
    this._responseArray = c.array(this._response)

    this._dedup = dedup
    this._onrequest = onrequest
    this._onstream = onstream

    this._streams = []
    this._free = []
  }

  async _callOnRequest (req) {
    try {
      const data = await this._onrequest(req.data)
      req._respond(data)
    } catch (err) {
      req._error(err)
    }
  }

  async _callOnSend (data) {
    try {
      await this._onrequest(data)
    } catch (err) {
      safetyCatch(err)
    }
  }

  _createStream (initiator, remoteId) {
    const id = this._free.length ? this._free.pop() : (this._streams.push(null) - 1)
    const stream = new RPCStream(this, id, initiator, remoteId, this._dedup)
    this._streams[id] = stream
    return stream
  }

  _handleStreamOpen (id, bitfield, state) {
    if (bitfield & STREAM_IS_INITIATOR) {
      // Create the responder stream
      const stream = this._createStream(false, id)
      this._onstream(stream)
    } else {
      const stream = this._streams[id]
      stream._remoteOpened(c.uint.decode(state))
    }
  }

  _handleStreamClose (id, bitfield, state) {
    const stream = this._streams[id]
    if (bitfield & STREAM_HAS_ERROR) {
      const err = ErrorMessage.decode(state)
      stream._remoteClosed(err)
    } else {
      stream._remoteClosed(null)
    }
    this._streams[id] = null
    this._free.push(id)
  }

  _handleStreamPause (id) {
    const stream = this._streams[id]
    if (stream) stream._remotePause()
  }

  _handleStreamResume (id) {
    const stream = this._streams[id]
    if (stream) stream._remoteResume()
  }

  _handleStreamEnd (id) {
    const stream = this._streams[id]
    if (stream) stream.push(null)
  }

  _handleStreamData (id, state) {
    const stream = this._streams[id]
    if (!stream) return

    let data = null
    if (stream._initiator) {
      data = this._responseArray.decode(state)
    } else {
      data = this._requestArray.decode(state)
    }

    // TODO: Should we buffer the remainder of the array?
    let stop = false
    for (const item of data) {
      stop = stream.push(item)
    }

    if (stop === false) {
      if (!stream._sentPause) {
        stream._sentPause = true
        this._sendMessage(stream._remoteId, MESSAGE_SEND | STREAM_PAUSE)
      }
    }
  }

  _handleStreamSend (id, bitfield, state) {
    if (bitfield & STREAM_OPEN) {
      this._handleStreamOpen(id, bitfield, state)
    } else if (bitfield & STREAM_CLOSE) {
      this._handleStreamClose(id, bitfield, state)
    } else if (bitfield & STREAM_PAUSE) {
      this._handleStreamPause(id)
    } else if (bitfield & STREAM_RESUME) {
      this._handleStreamResume(id)
    } else if (bitfield & STREAM_DATA) {
      this._handleStreamData(id, state)
    } else if (bitfield & STREAM_END) {
      this._handleStreamEnd(id)
    }
  }

  _handleSend (id, bitfield, state) {
    if (bitfield & STREAMING_MASK) {
      this._handleStreamSend(id, bitfield, state)
    } else {
      this._callOnSend(this._request.decode(state))
    }
  }

  _handleRequest (id, bitfield, state) {
    if (this.destroyed) return
    if (bitfield & MESSAGE_SEND) {
      this._handleSend(id, bitfield, state)
    } else {
      const req = new Request(this, id, bitfield, this._request.decode(state))
      this._callOnRequest(req)
    }
  }

  _handleResponse (req, bitfield, state) {
    if (this.destroyed) return
    if (bitfield & MESSAGE_ERROR) {
      const { errno, message, stack, code } = ErrorMessage.decode(state)
      const err = new Error()
      err.errno = errno
      err.message = message
      err.stack = stack
      err.code = code
      req.reject(err)
    } else {
      req.resolve(this._response.decode(state))
    }
    this._rpc._reqs[req.id] = null
    this._rpc._free.push(req.id)
  }

  _sendMessage (id, bitfield, data) {
    this._rpc._sendMessage({
      method: this._method,
      bitfield,
      id,
      data
    })
  }

  request (data) {
    if (this.destroyed) return Promise.reject(new Error('RPC destroyed'))
    const req = this._rpc._createRequest()
    this._sendMessage(req.id, MESSAGE_REQUEST, c.encode(this._request, data))
    return req.promise
  }

  send (data) {
    if (this.destroyed) return
    this._sendMessage(0, MESSAGE_SEND, c.encode(this._request, data))
  }

  createRequestStream () {
    if (this.destroyed) throw new Error('RPC destroyed')
    return this._createStream(true, -1)
  }

  destroy () {
    this.destroyed = true
    for (const s of this._streams) {
      if (s === null) continue
      s.destroy(new Error('RPC destroyed'))
    }
  }
}

module.exports = class TinyBufferRPC {
  constructor (send) {
    this.destroyed = false
    this._send = send
    this._handlers = []
    this._pending = []
    this._reqs = []
    this._free = []
    this._corked = false
  }

  _createRequest () {
    const id = this._free.length ? this._free.pop() : (this._reqs.push(null) - 1)
    const req = { id, promise: null, resolve: null, reject: null }
    this._reqs[id] = req
    req.promise = new Promise((resolve, reject) => {
      req.resolve = resolve
      req.reject = reject
    })
    return req
  }

  _sendMessage (msg) {
    if (this.destroyed) return
    const data = c.encode(Message, msg)
    if (this._corked) {
      this._pending.push(data)
      return
    }
    this._send(data)
  }

  register (id, opts = {}) {
    if (this._handlers[id]) throw new Error('Handler for this ID already exists')
    while (this._handlers.length <= id) this._handlers.push(null)
    const method = new Method(this, id, opts)
    this._handlers[id] = method
    return method
  }

  cork () {
    this._corked = true
  }

  uncork () {
    this._corked = false
    // TODO: Use a slab pattern here to avoid the concat
    if (!this.destroyed) this._send(b4a.concat(this._pending))
    this._pending = []
  }

  recv (buf) {
    const state = { start: 0, end: buf.length, buffer: buf }
    while (state.start < state.end) {
      const { id, bitfield, method } = Header.decode(state)
      if (bitfield & REQUEST) {
        const handler = this._handlers[method]
        if (!handler) throw new Error('Got a request for an unsupported method')
        else handler._handleRequest(id, bitfield, state)
      } else {
        const req = this._reqs[id]
        const handler = this._handlers[method]
        if (!req) throw new Error('Got a response for an invalid request ID')
        if (!handler) throw new Error('Got a response for an invalid method ID')
        handler._handleResponse(req, bitfield, state)
      }
    }
  }

  destroy () {
    this.destroyed = true
    while (this._reqs.length) {
      const req = this._reqs.pop()
      if (req === null) continue
      req.reject(new Error('RPC destroyed'))
    }
    for (const h of this._handlers) {
      if (h === null) continue
      h.destroy()
    }
  }
}
const c = require('compact-encoding')

const KNOWN_BYTE = 0x74 // 't' for tiny-buffer-rpc

const Header = {
  preencode (state, h) {
    c.uint.preencode(state, KNOWN_BYTE)
    c.uint.preencode(state, h.method)
    c.uint.preencode(state, h.id)
    c.uint.preencode(state, h.bitfield)
  },
  encode (state, h) {
    c.uint.encode(state, KNOWN_BYTE)
    c.uint.encode(state, h.method)
    c.uint.encode(state, h.id)
    c.uint.encode(state, h.bitfield)
  },
  decode (state) {
    const known = c.uint.decode(state)
    if (known !== KNOWN_BYTE) throw Error('Message at start = ' + state.start + ' end = ' + state.end + ' does not look like a TinyRPC message')

    return {
      method: c.uint.decode(state),
      id: c.uint.decode(state),
      bitfield: c.uint.decode(state)
    }
  }
}
module.exports.Header = Header

module.exports.Message = {
  preencode (state, m) {
    Header.preencode(state, m)
    if (m.data) c.raw.preencode(state, m.data)
  },
  encode (state, m) {
    Header.encode(state, m)
    if (m.data) c.raw.encode(state, m.data)
  },
  decode (state) {
    return {
      ...Header.decode(state),
      data: c.raw.decode(state)
    }
  }
}

module.exports.ErrorMessage = {
  preencode (state, e) {
    state.end++ // flags
    c.int.preencode(state, e.errno || 0)
    if (e.message) c.string.preencode(state, e.message)
    if (e.stack) c.string.preencode(state, e.stack)
    if (e.code) c.string.preencode(state, e.code)
  },
  encode (state, e) {
    const start = state.start++ // flags
    c.int.encode(state, e.errno || 0)

    let flags = 0
    if (e.message) {
      flags |= 1
      c.string.encode(state, e.message)
    }
    if (e.stack) {
      flags |= 2
      c.string.encode(state, e.stack)
    }
    if (e.code) {
      flags |= 4
      c.string.encode(state, e.code)
    }

    state.buffer[start] = flags
  },
  decode (state) {
    const flags = c.uint.decode(state)
    return {
      errno: c.int.decode(state),
      message: (flags & 1) !== 0 ? c.string.decode(state) : null,
      stack: (flags & 2) !== 0 ? c.string.decode(state) : null,
      code: (flags & 4) !== 0 ? c.string.decode(state) : null
    }
  }
}
{
  "name": "tiny-buffer-rpc",
  "version": "2.3.0",
  "description": "Lightweight binary RPC",
  "main": "index.js",
  "scripts": {
    "test": "standard && brittle test.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/holepunchto/tiny-buffer-rpc.git"
  },
  "author": "Holepunch",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/holepunchto/tiny-buffer-rpc/issues"
  },
  "homepage": "https://github.com/holepunchto/tiny-buffer-rpc#readme",
  "devDependencies": {
    "brittle": "^3.2.1",
    "standard": "^17.0.0"
  },
  "dependencies": {
    "b4a": "^1.6.3",
    "compact-encoding": "^2.11.0",
    "safety-catch": "^1.0.2",
    "streamx": "^2.13.2"
  }
}
const { runtime, platform, arch } = typeof Bare !== 'undefined'
  ? { runtime: 'bare', platform: global.Bare.platform, arch: global.Bare.arch }
  : typeof process !== 'undefined'
    ? { runtime: 'node', platform: global.process.platform, arch: global.process.arch }
    : typeof Window !== 'undefined'
      ? { runtime: 'browser', platform: 'unknown', arch: 'unknown' }
      : { runtime: 'unknown', platform: 'unknown', arch: 'unknown' }

exports.runtime = runtime
exports.platform = platform
exports.arch = arch
exports.isBare = runtime === 'bare'
exports.isBareKit = exports.isBare && typeof BareKit !== 'undefined'
exports.isPear = exports.isBare && typeof Pear !== 'undefined'
exports.isNode = runtime === 'node'
exports.isBrowser = runtime === 'browser'
exports.isWindows = platform === 'win32'
exports.isLinux = platform === 'linux'
exports.isMac = platform === 'darwin'
exports.isIOS = platform === 'ios' || platform === 'ios-simulator'
exports.isAndroid = platform === 'android'
exports.isElectron = typeof process !== 'undefined' && !!global.process.versions.electron
exports.isElectronRenderer = exports.isElectron && global.process.type === 'renderer'
exports.isElectronWorker = exports.isElectron && global.process.type === 'worker'
{
  "name": "which-runtime",
  "version": "1.3.0",
  "description": "Detect if you are in Bare or Node and which os etc",
  "main": "index.js",
  "files": [
    "index.js"
  ],
  "dependencies": {},
  "devDependencies": {
    "standard": "^17.0.0"
  },
  "scripts": {
    "test": "standard"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/holepunchto/which-runtime.git"
  },
  "author": "Holepunch Inc.",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/holepunchto/which-runtime/issues"
  },
  "homepage": "https://github.com/holepunchto/which-runtime"
}
{
  "name": "pearpass-native-messaging-bridge",
  "version": "0.0.1",
  "description": "Native messaging bridge for PearPass browser extension",
  "main": "index.js",
  "type": "commonjs",
  "scripts": {
    "start": "node index.js",
    "bundle:darwin": "bare-pack --platform darwin --arch arm64 index.js -o dist/index-macos-arm64",
    "bundle:linux": "bare-pack --platform linux --arch x64 index.js -o dist/index-linux-x64",
    "bundle:win32": "bare-pack --platform win32 --arch x64 index.js -o dist/index-win-x64",
    "bundle:all": "npm run bundle:darwin && npm run bundle:linux && npm run bundle:win32"
  },
  "dependencies": {
    "bare-fs": "4.5.0",
    "bare-os": "3.6.2",
    "bare-path": "3.0.0",
    "pear-ipc": "6.4.0"
  },
  "devDependencies": {
    "bare-pack": "1.4.8"
  },
  "engines": {
    "node": ">=14.0.0"
  }
}
const fs = require('bare-fs')
const os = require('bare-os')
const path = require('bare-path')

const DEBUG_MODE = false

/**
 * Returns cross-platform IPC path
 * Socket is stored in temp directory
 * @param {string} socketName
 * @returns {string}
 */
const getIpcPath = (socketName) => {
  if (os.platform() === 'win32') {
    return `\\\\?\\pipe\\${socketName}`
  }

  // Socket is in temp directory
  return path.join(os.tmpdir(), `${socketName}.sock`)
}

/**
 * Dedicated logger for native messaging bridge
 * Logs to the logs directory within the bridge module directory when in debug mode
 * @param {'INFO'|'ERROR'|'DEBUG'|'WARN'} level - Log level
 * @param {string} message - Log message
 */
const log = (level, message) => {
  if (!DEBUG_MODE) return

  try {
    const bridgeDir = path.dirname(__dirname)
    const logDir = path.join(bridgeDir, 'logs')
    const logFile = path.join(logDir, 'native-messaging-bridge.log')

    // Create logs directory if it doesn't exist
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true })
    }

    const timestamp = new Date().toISOString()
    const logMsg = `${timestamp} [${level}] [IPC-BRIDGE] ${message}\n`
    fs.appendFileSync(logFile, logMsg)
  } catch (e) {
    // eslint-disable-next-line no-console
    console.error(`Failed to write log: ${e.message}`)
  }
}

module.exports = {
  getIpcPath,
  log
}
